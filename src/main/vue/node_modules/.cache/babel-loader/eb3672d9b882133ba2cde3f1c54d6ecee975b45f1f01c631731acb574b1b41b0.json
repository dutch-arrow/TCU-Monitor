{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nvar Mn = Object.defineProperty;\nvar Dn = (e, t, l) => t in e ? Mn(e, t, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: l\n}) : e[t] = l;\nvar Pe = (e, t, l) => (Dn(e, typeof t != \"symbol\" ? t + \"\" : t, l), l);\nimport { unref as $, computed as i, ref as M, shallowRef as za, watch as se, getCurrentScope as so, onScopeDispose as ro, shallowReadonly as vt, watchEffect as Rt, readonly as Be, effectScope as io, isRef as uo, toRef as Ae, customRef as jn, getCurrentInstance as ua, onMounted as qe, nextTick as Oe, reactive as Bt, defineComponent as H, h as ie, Teleport as Ha, toValue as at, onActivated as qn, onBeforeUnmount as co, openBlock as y, createElementBlock as A, Fragment as fe, createElementVNode as Y, renderSlot as O, normalizeProps as $e, guardReactiveProps as Ee, createVNode as _e, withCtx as j, mergeProps as ae, normalizeClass as R, normalizeStyle as De, createTextVNode as re, toDisplayString as Z, createCommentVNode as J, createApp as Gn, provide as Ke, createBlock as D, resolveDynamicComponent as oe, inject as Ie, toHandlers as Wn, Transition as Un, useSlots as xe, useAttrs as Ra, withModifiers as ut, renderList as we, withKeys as xt, TransitionGroup as Kn, withDirectives as rt, vShow as da, isReactive as Xn, onUnmounted as Yn, vModelCheckbox as Jn, vModelRadio as Zn, vModelSelect as Qn, createSlots as fo } from \"vue\";\nconst es = e => typeof e == \"boolean\" || e === \"\" || e === \"true\" || e === \"false\",\n  Ma = e => typeof e == \"boolean\" ? e : e === \"\" || e === \"true\";\nclass Je {\n  constructor(t, l = {}) {\n    Pe(this, \"cancelable\", !0);\n    Pe(this, \"componentId\", null);\n    Pe(this, \"_defaultPrevented\", !1);\n    Pe(this, \"eventType\", \"\");\n    Pe(this, \"nativeEvent\", null);\n    Pe(this, \"_preventDefault\");\n    Pe(this, \"relatedTarget\", null);\n    Pe(this, \"target\", null);\n    if (!t) throw new TypeError(`Failed to construct '${this.constructor.name}'. 1 argument required, ${arguments.length} given.`);\n    Object.assign(this, Je.Defaults, l, {\n      eventType: t\n    }), this._preventDefault = function () {\n      this.cancelable && (this.defaultPrevented = !0);\n    };\n  }\n  // Readable by everyone,\n  // But only overwritten by inherrited constructors\n  get defaultPrevented() {\n    return this._defaultPrevented;\n  }\n  set defaultPrevented(t) {\n    this._defaultPrevented = t;\n  }\n  // I think this is right\n  // We want to be able to have it callable to everyone,\n  // But only overwritten by inherrited constructors\n  get preventDefault() {\n    return this._preventDefault;\n  }\n  // This may not be correct, because it doesn't get correct type inferences in children\n  // Ex overwrite this.preventDefault = () => true is valid. Could be a TS issue\n  set preventDefault(t) {\n    this._preventDefault = t;\n  }\n  static get Defaults() {\n    return {\n      cancelable: !0,\n      componentId: null,\n      eventType: \"\",\n      nativeEvent: null,\n      relatedTarget: null,\n      target: null\n    };\n  }\n}\nclass Mt extends Je {\n  constructor(l, a = {}) {\n    super(l, a);\n    Pe(this, \"trigger\", null);\n    Object.assign(this, Je.Defaults, a, {\n      eventType: l\n    });\n  }\n  static get Defaults() {\n    return {\n      ...super.Defaults,\n      trigger: null\n    };\n  }\n}\nclass vo extends Je {\n  constructor(l, a) {\n    super(l, a);\n    Pe(this, \"from\");\n    Pe(this, \"to\");\n    Pe(this, \"direction\");\n    Object.assign(this, Je.Defaults, a, {\n      eventType: l\n    });\n    const {\n      from: o,\n      direction: n,\n      to: s\n    } = a;\n    this.from = o, this.to = s, this.direction = n;\n  }\n  static get Defaults() {\n    return {\n      ...super.Defaults\n    };\n  }\n}\nconst Sa = e => e !== null && typeof e == \"object\",\n  po = e => /^[0-9]*\\.?[0-9]+$/.test(String(e)),\n  ts = e => Object.prototype.toString.call(e) === \"[object Object]\",\n  mo = /_/g,\n  go = /([a-z])([A-Z])/g,\n  as = /(\\s|^)(\\w)/g,\n  ls = /(\\s|^)(\\w)/,\n  Yt = /\\s+/,\n  os = /^#/,\n  ns = /^#[A-Za-z]+[\\w\\-:.]*$/,\n  ss = /-u-.+/,\n  rs = /[-/\\\\^$*+?.()|[\\]{}]/g,\n  is = /[\\s\\uFEFF\\xA0]+/g,\n  Qt = (e, t = 2) => typeof e == \"string\" ? e : e == null ? \"\" : Array.isArray(e) || ts(e) && e.toString === Object.prototype.toString ? JSON.stringify(e, null, t) : String(e),\n  il = e => e.replace(mo, \" \").replace(go, (t, l, a) => `${l} ${a}`).replace(ls, (t, l, a) => l + a.toUpperCase()),\n  ul = e => e.replace(mo, \" \").replace(go, (t, l, a) => `${l} ${a}`).replace(as, (t, l, a) => l + a.toUpperCase()),\n  us = e => {\n    const t = e.trim();\n    return t.charAt(0).toUpperCase() + t.slice(1);\n  },\n  ds = e => e.replace(rs, \"\\\\$&\"),\n  cs = e => ds(e).replace(is, \"\\\\s\"),\n  ba = e => `\\\\${e}`,\n  fs = e => {\n    const t = Qt(e),\n      {\n        length: l\n      } = t,\n      a = t.charCodeAt(0);\n    return t.split(\"\").reduce((o, n, s) => {\n      const r = t.charCodeAt(s);\n      return r === 0 ? `${o}ï¿½` :\n      // ... is U+007F OR\n      r === 127 ||\n      // ... is in the range [\\1-\\1F] (U+0001 to U+001F) OR ...\n      r >= 1 && r <= 31 ||\n      // ... is the first character and is in the range [0-9] (U+0030 to U+0039) OR ...\n      s === 0 && r >= 48 && r <= 57 ||\n      // ... is the second character and is in the range [0-9] (U+0030 to U+0039)\n      // and the first character is a `-` (U+002D) ...\n      s === 1 && r >= 48 && r <= 57 && a === 45 ? o + ba(`${r.toString(16)} `) :\n      // ... is the first character AND ...\n      s === 0 &&\n      // ... is a `-` (U+002D) AND ...\n      r === 45 &&\n      // ... there is no second character ...\n      l === 1 ? o + ba(n) :\n      // ... is greater than or equal to U+0080 OR ...\n      r >= 128 ||\n      // ... is `-` (U+002D) OR ...\n      r === 45 ||\n      // ... is `_` (U+005F) OR ...\n      r === 95 ||\n      // ... is in the range [0-9] (U+0030 to U+0039) OR ...\n      r >= 48 && r <= 57 ||\n      // ... is in the range [A-Z] (U+0041 to U+005A) OR ...\n      r >= 65 && r <= 90 ||\n      // ... is in the range [a-z] (U+0061 to U+007A) ...\n      r >= 97 && r <= 122 ? o + n : o + ba(n);\n    }, \"\");\n  },\n  yo = typeof window < \"u\",\n  bo = typeof document < \"u\",\n  vs = typeof Element < \"u\",\n  ps = typeof navigator < \"u\",\n  ms = yo && bo && ps,\n  dl = yo ? window : {},\n  Da = bo ? document : {};\n(() => {\n  let e = !1;\n  if (ms) try {\n    const t = {\n      // This function will be called when the browser\n      // attempts to access the passive property\n      get passive() {\n        return e = !0, e;\n      }\n    };\n    dl.addEventListener(\"test\", t, t), dl.removeEventListener(\"test\", t, t);\n  } catch {\n    e = !1;\n  }\n  return e;\n})();\nconst ja = typeof window < \"u\",\n  gs = typeof document < \"u\",\n  ys = typeof navigator < \"u\",\n  qa = ja && gs && ys,\n  cl = ja ? window : {},\n  bs = (() => {\n    let e = !1;\n    if (qa) try {\n      const t = {\n        // This function will be called when the browser\n        // attempts to access the passive property\n        get passive() {\n          e = !0;\n        }\n      };\n      cl.addEventListener(\"test\", t, t), cl.removeEventListener(\"test\", t, t);\n    } catch {\n      e = !1;\n    }\n    return e;\n  })(),\n  He = vs ? Element.prototype : void 0,\n  hs = (He == null ? void 0 : He.matches) || (He == null ? void 0 : He.msMatchesSelector) || (He == null ? void 0 : He.webkitMatchesSelector),\n  Ze = e => !!(e && e.nodeType === Node.ELEMENT_NODE),\n  Bs = e => Ze(e) ? e.getBoundingClientRect() : null,\n  Ss = (e = []) => {\n    const {\n      activeElement: t\n    } = document;\n    return t && !e.some(l => l === t) ? t : null;\n  },\n  _s = e => Ze(e) && e === Ss(),\n  ws = (e, t = {}) => {\n    try {\n      e.focus(t);\n    } catch (l) {\n      console.error(l);\n    }\n    return _s(e);\n  },\n  $s = (e, t) => t && Ze(e) && e.getAttribute(t) || null,\n  ks = e => {\n    if ($s(e, \"display\") === \"none\") return !1;\n    const t = Bs(e);\n    return !!(t && t.height > 0 && t.width > 0);\n  },\n  Fe = e => ((e == null ? void 0 : e()) ?? []).length === 0,\n  ho = (e, t) => (Ze(t) ? t : Da).querySelector(e) || null,\n  Cs = (e, t) => Array.from([(Ze(t) ? t : Da).querySelectorAll(e)]),\n  Ga = (e, t) => t && Ze(e) ? e.getAttribute(t) : null,\n  Ts = e => Da.getElementById(/^#/.test(e) ? e.slice(1) : e) || null,\n  Vs = (e, t, l) => {\n    t && Ze(e) && e.setAttribute(t, l);\n  },\n  Os = (e, t) => {\n    t && Ze(e) && e.removeAttribute(t);\n  },\n  As = (e, t) => Qt(e).toLowerCase() === Qt(t).toLowerCase(),\n  Gt = ja ? window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || (\n  // Fallback, but not a true polyfill\n  // Only needed for Opera Mini\n  e => setTimeout(e, 16)) : e => setTimeout(e, 0),\n  Bo = (e, t) => Ze(e) ? hs.call(e, t) : !1,\n  Ps = (He == null ? void 0 : He.closest) || function (e) {\n    let t = this;\n    if (!t) return null;\n    do {\n      if (Bo(t, e)) return t;\n      t = t.parentElement || t.parentNode;\n    } while (t !== null && t.nodeType === Node.ELEMENT_NODE);\n    return null;\n  },\n  fl = (e, t, l = !1) => {\n    if (!Ze(t)) return null;\n    const a = Ps.call(t, e);\n    return l ? a : a === t ? null : a;\n  },\n  _a = e => {\n    const t = window.getComputedStyle(e),\n      l = t.transitionDelay.split(\",\")[0] || \"\",\n      a = t.transitionDuration.split(\",\")[0] || \"\",\n      o = Number(l.slice(0, -1)) * 1e3,\n      n = Number(a.slice(0, -1)) * 1e3;\n    return o + n;\n  },\n  ca = (e, t, l) => t.concat([\"sm\", \"md\", \"lg\", \"xl\", \"xxl\"]).reduce((a, o) => (a[e ? `${e}${o.charAt(0).toUpperCase() + o.slice(1)}` : o] = l, a), /* @__PURE__ */Object.create(null)),\n  So = (e, t, l, a = l) => Object.keys(t).reduce((o, n) => (e[n] && o.push([a, n.replace(l, \"\"), e[n]].filter(s => s && typeof s != \"boolean\").join(\"-\").toLowerCase()), o), []),\n  lt = (e = \"\") => `__BVID__${Math.random().toString().slice(2, 8)}___BV_${e}__`,\n  St = e => !!(e.href || e.to),\n  Me = (e, t = {}, l = {}) => {\n    const a = [e];\n    let o;\n    for (let n = 0; n < a.length && !o; n++) {\n      const s = a[n];\n      o = l[s];\n    }\n    return o && typeof o == \"function\" ? o(t) : o;\n  },\n  ot = (e, t = NaN) => Number.isInteger(e) ? e : t,\n  Es = (e, t = NaN) => {\n    const l = Number.parseInt(e, 10);\n    return Number.isNaN(l) ? t : l;\n  },\n  Et = (e, t = NaN) => {\n    const l = Number.parseFloat(e.toString());\n    return Number.isNaN(l) ? t : l;\n  },\n  Fs = (e, t) => Object.keys(e).filter(l => !t.includes(l)).reduce((l, a) => ({\n    ...l,\n    [a]: e[a]\n  }), {}),\n  ea = e => Array.isArray(e) ? e.map(t => ea(t)) : e instanceof Date ? new Date(e.getTime()) : e && typeof e == \"object\" ? Object.getOwnPropertyNames(e).reduce((t, l) => (Object.defineProperty(t, l, Object.getOwnPropertyDescriptor(e, l) ?? {}), t[l] = ea(e[l]), t), Object.create(Object.getPrototypeOf(e))) : e,\n  wa = e => new Promise(t => t(ea(e))),\n  vl = (e, t) => t + (e ? us(e) : \"\"),\n  Dt = (e, t) => (Array.isArray(t) ? t.slice() : Object.keys(t)).reduce((l, a) => (l[a] = e[a], l), {}),\n  fa = (e, t) => e === !0 || e === \"true\" || e === \"\" ? \"true\" : e === \"grammar\" || e === \"spelling\" ? e : t === !1 ? \"true\" : e === !1 || e === \"false\" ? \"false\" : void 0,\n  _o = Symbol(\"carousel\"),\n  wo = Symbol(\"tabs\"),\n  $o = Symbol(\"progress\"),\n  ko = Symbol(\"listGroup\"),\n  Co = Symbol(\"avatarGroup\"),\n  To = Symbol(\"accordion\"),\n  Vo = Symbol(\"checkboxGroup\"),\n  Oo = Symbol(\"radioGroup\"),\n  Wa = Symbol(\"collapse\"),\n  Ao = Symbol(\"collapse\"),\n  Ua = Symbol(\"navbar\"),\n  $a = (e, t) => ((e == null ? void 0 : e()) ?? []).reduce((l, a) => (typeof a.type == \"symbol\" ? l = l.concat(a.children) : l.push(a), l), []).filter(l => {\n    var a;\n    return ((a = l.type) == null ? void 0 : a.__name) === t;\n  });\nfunction Ye(e) {\n  return e.split(\"-\")[1];\n}\nfunction Ka(e) {\n  return e === \"y\" ? \"height\" : \"width\";\n}\nfunction Ge(e) {\n  return e.split(\"-\")[0];\n}\nfunction Ct(e) {\n  return [\"top\", \"bottom\"].includes(Ge(e)) ? \"x\" : \"y\";\n}\nfunction pl(e, t, l) {\n  let {\n    reference: a,\n    floating: o\n  } = e;\n  const n = a.x + a.width / 2 - o.width / 2,\n    s = a.y + a.height / 2 - o.height / 2,\n    r = Ct(t),\n    u = Ka(r),\n    f = a[u] / 2 - o[u] / 2,\n    v = r === \"x\";\n  let p;\n  switch (Ge(t)) {\n    case \"top\":\n      p = {\n        x: n,\n        y: a.y - o.height\n      };\n      break;\n    case \"bottom\":\n      p = {\n        x: n,\n        y: a.y + a.height\n      };\n      break;\n    case \"right\":\n      p = {\n        x: a.x + a.width,\n        y: s\n      };\n      break;\n    case \"left\":\n      p = {\n        x: a.x - o.width,\n        y: s\n      };\n      break;\n    default:\n      p = {\n        x: a.x,\n        y: a.y\n      };\n  }\n  switch (Ye(t)) {\n    case \"start\":\n      p[r] -= f * (l && v ? -1 : 1);\n      break;\n    case \"end\":\n      p[r] += f * (l && v ? -1 : 1);\n  }\n  return p;\n}\nconst Is = async (e, t, l) => {\n  const {\n      placement: a = \"bottom\",\n      strategy: o = \"absolute\",\n      middleware: n = [],\n      platform: s\n    } = l,\n    r = n.filter(Boolean),\n    u = await (s.isRTL == null ? void 0 : s.isRTL(t));\n  let f = await s.getElementRects({\n      reference: e,\n      floating: t,\n      strategy: o\n    }),\n    {\n      x: v,\n      y: p\n    } = pl(f, a, u),\n    c = a,\n    g = {},\n    B = 0;\n  for (let m = 0; m < r.length; m++) {\n    const {\n        name: V,\n        fn: b\n      } = r[m],\n      {\n        x: T,\n        y: _,\n        data: h,\n        reset: k\n      } = await b({\n        x: v,\n        y: p,\n        initialPlacement: a,\n        placement: c,\n        strategy: o,\n        middlewareData: g,\n        rects: f,\n        platform: s,\n        elements: {\n          reference: e,\n          floating: t\n        }\n      });\n    v = T ?? v, p = _ ?? p, g = {\n      ...g,\n      [V]: {\n        ...g[V],\n        ...h\n      }\n    }, k && B <= 50 && (B++, typeof k == \"object\" && (k.placement && (c = k.placement), k.rects && (f = k.rects === !0 ? await s.getElementRects({\n      reference: e,\n      floating: t,\n      strategy: o\n    }) : k.rects), ({\n      x: v,\n      y: p\n    } = pl(f, c, u))), m = -1);\n  }\n  return {\n    x: v,\n    y: p,\n    placement: c,\n    strategy: o,\n    middlewareData: g\n  };\n};\nfunction it(e, t) {\n  return typeof e == \"function\" ? e(t) : e;\n}\nfunction Xa(e) {\n  return typeof e != \"number\" ? function (t) {\n    return {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0,\n      ...t\n    };\n  }(e) : {\n    top: e,\n    right: e,\n    bottom: e,\n    left: e\n  };\n}\nfunction _t(e) {\n  return {\n    ...e,\n    top: e.y,\n    left: e.x,\n    right: e.x + e.width,\n    bottom: e.y + e.height\n  };\n}\nasync function Lt(e, t) {\n  var l;\n  t === void 0 && (t = {});\n  const {\n      x: a,\n      y: o,\n      platform: n,\n      rects: s,\n      elements: r,\n      strategy: u\n    } = e,\n    {\n      boundary: f = \"clippingAncestors\",\n      rootBoundary: v = \"viewport\",\n      elementContext: p = \"floating\",\n      altBoundary: c = !1,\n      padding: g = 0\n    } = it(t, e),\n    B = Xa(g),\n    m = r[c ? p === \"floating\" ? \"reference\" : \"floating\" : p],\n    V = _t(await n.getClippingRect({\n      element: (l = await (n.isElement == null ? void 0 : n.isElement(m))) == null || l ? m : m.contextElement || (await (n.getDocumentElement == null ? void 0 : n.getDocumentElement(r.floating))),\n      boundary: f,\n      rootBoundary: v,\n      strategy: u\n    })),\n    b = p === \"floating\" ? {\n      ...s.floating,\n      x: a,\n      y: o\n    } : s.reference,\n    T = await (n.getOffsetParent == null ? void 0 : n.getOffsetParent(r.floating)),\n    _ = (await (n.isElement == null ? void 0 : n.isElement(T))) && (await (n.getScale == null ? void 0 : n.getScale(T))) || {\n      x: 1,\n      y: 1\n    },\n    h = _t(n.convertOffsetParentRelativeRectToViewportRelativeRect ? await n.convertOffsetParentRelativeRectToViewportRelativeRect({\n      rect: b,\n      offsetParent: T,\n      strategy: u\n    }) : b);\n  return {\n    top: (V.top - h.top + B.top) / _.y,\n    bottom: (h.bottom - V.bottom + B.bottom) / _.y,\n    left: (V.left - h.left + B.left) / _.x,\n    right: (h.right - V.right + B.right) / _.x\n  };\n}\nconst wt = Math.min,\n  ta = Math.max;\nfunction ka(e, t, l) {\n  return ta(e, wt(t, l));\n}\nconst xs = e => ({\n    name: \"arrow\",\n    options: e,\n    async fn(t) {\n      const {\n          x: l,\n          y: a,\n          placement: o,\n          rects: n,\n          platform: s,\n          elements: r\n        } = t,\n        {\n          element: u,\n          padding: f = 0\n        } = it(e, t) || {};\n      if (u == null) return {};\n      const v = Xa(f),\n        p = {\n          x: l,\n          y: a\n        },\n        c = Ct(o),\n        g = Ka(c),\n        B = await s.getDimensions(u),\n        m = c === \"y\",\n        V = m ? \"top\" : \"left\",\n        b = m ? \"bottom\" : \"right\",\n        T = m ? \"clientHeight\" : \"clientWidth\",\n        _ = n.reference[g] + n.reference[c] - p[c] - n.floating[g],\n        h = p[c] - n.reference[c],\n        k = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(u));\n      let C = k ? k[T] : 0;\n      C && (await (s.isElement == null ? void 0 : s.isElement(k))) || (C = r.floating[T] || n.floating[g]);\n      const w = _ / 2 - h / 2,\n        P = C / 2 - B[g] / 2 - 1,\n        F = wt(v[V], P),\n        S = wt(v[b], P),\n        I = F,\n        x = C - B[g] - S,\n        z = C / 2 - B[g] / 2 + w,\n        te = ka(I, z, x),\n        Q = Ye(o) != null && z != te && n.reference[g] / 2 - (z < I ? F : S) - B[g] / 2 < 0 ? z < I ? I - z : x - z : 0;\n      return {\n        [c]: p[c] - Q,\n        data: {\n          [c]: te,\n          centerOffset: z - te + Q\n        }\n      };\n    }\n  }),\n  Po = [\"top\", \"right\", \"bottom\", \"left\"],\n  ml = Po.reduce((e, t) => e.concat(t, t + \"-start\", t + \"-end\"), []),\n  Ls = {\n    left: \"right\",\n    right: \"left\",\n    bottom: \"top\",\n    top: \"bottom\"\n  };\nfunction aa(e) {\n  return e.replace(/left|right|bottom|top/g, t => Ls[t]);\n}\nfunction Eo(e, t, l) {\n  l === void 0 && (l = !1);\n  const a = Ye(e),\n    o = Ct(e),\n    n = Ka(o);\n  let s = o === \"x\" ? a === (l ? \"end\" : \"start\") ? \"right\" : \"left\" : a === \"start\" ? \"bottom\" : \"top\";\n  return t.reference[n] > t.floating[n] && (s = aa(s)), {\n    main: s,\n    cross: aa(s)\n  };\n}\nconst Ns = {\n  start: \"end\",\n  end: \"start\"\n};\nfunction Jt(e) {\n  return e.replace(/start|end/g, t => Ns[t]);\n}\nconst zs = function (e) {\n    return e === void 0 && (e = {}), {\n      name: \"autoPlacement\",\n      options: e,\n      async fn(t) {\n        var l, a, o;\n        const {\n            rects: n,\n            middlewareData: s,\n            placement: r,\n            platform: u,\n            elements: f\n          } = t,\n          {\n            crossAxis: v = !1,\n            alignment: p,\n            allowedPlacements: c = ml,\n            autoAlignment: g = !0,\n            ...B\n          } = it(e, t),\n          m = p !== void 0 || c === ml ? function (S, I, x) {\n            return (S ? [...x.filter(z => Ye(z) === S), ...x.filter(z => Ye(z) !== S)] : x.filter(z => Ge(z) === z)).filter(z => !S || Ye(z) === S || !!I && Jt(z) !== z);\n          }(p || null, g, c) : c,\n          V = await Lt(t, B),\n          b = ((l = s.autoPlacement) == null ? void 0 : l.index) || 0,\n          T = m[b];\n        if (T == null) return {};\n        const {\n          main: _,\n          cross: h\n        } = Eo(T, n, await (u.isRTL == null ? void 0 : u.isRTL(f.floating)));\n        if (r !== T) return {\n          reset: {\n            placement: m[0]\n          }\n        };\n        const k = [V[Ge(T)], V[_], V[h]],\n          C = [...(((a = s.autoPlacement) == null ? void 0 : a.overflows) || []), {\n            placement: T,\n            overflows: k\n          }],\n          w = m[b + 1];\n        if (w) return {\n          data: {\n            index: b + 1,\n            overflows: C\n          },\n          reset: {\n            placement: w\n          }\n        };\n        const P = C.map(S => {\n            const I = Ye(S.placement);\n            return [S.placement, I && v ? S.overflows.slice(0, 2).reduce((x, z) => x + z, 0) : S.overflows[0], S.overflows];\n          }).sort((S, I) => S[1] - I[1]),\n          F = ((o = P.filter(S => S[2].slice(0, Ye(S[0]) ? 2 : 3).every(I => I <= 0))[0]) == null ? void 0 : o[0]) || P[0][0];\n        return F !== r ? {\n          data: {\n            index: b + 1,\n            overflows: C\n          },\n          reset: {\n            placement: F\n          }\n        } : {};\n      }\n    };\n  },\n  Fo = function (e) {\n    return e === void 0 && (e = {}), {\n      name: \"flip\",\n      options: e,\n      async fn(t) {\n        var l;\n        const {\n            placement: a,\n            middlewareData: o,\n            rects: n,\n            initialPlacement: s,\n            platform: r,\n            elements: u\n          } = t,\n          {\n            mainAxis: f = !0,\n            crossAxis: v = !0,\n            fallbackPlacements: p,\n            fallbackStrategy: c = \"bestFit\",\n            fallbackAxisSideDirection: g = \"none\",\n            flipAlignment: B = !0,\n            ...m\n          } = it(e, t),\n          V = Ge(a),\n          b = Ge(s) === s,\n          T = await (r.isRTL == null ? void 0 : r.isRTL(u.floating)),\n          _ = p || (b || !B ? [aa(s)] : function (I) {\n            const x = aa(I);\n            return [Jt(I), x, Jt(x)];\n          }(s));\n        p || g === \"none\" || _.push(...function (I, x, z, te) {\n          const Q = Ye(I);\n          let G = function (X, U, pe) {\n            const be = [\"left\", \"right\"],\n              he = [\"right\", \"left\"],\n              ye = [\"top\", \"bottom\"],\n              q = [\"bottom\", \"top\"];\n            switch (X) {\n              case \"top\":\n              case \"bottom\":\n                return pe ? U ? he : be : U ? be : he;\n              case \"left\":\n              case \"right\":\n                return U ? ye : q;\n              default:\n                return [];\n            }\n          }(Ge(I), z === \"start\", te);\n          return Q && (G = G.map(X => X + \"-\" + Q), x && (G = G.concat(G.map(Jt)))), G;\n        }(s, B, g, T));\n        const h = [s, ..._],\n          k = await Lt(t, m),\n          C = [];\n        let w = ((l = o.flip) == null ? void 0 : l.overflows) || [];\n        if (f && C.push(k[V]), v) {\n          const {\n            main: I,\n            cross: x\n          } = Eo(a, n, T);\n          C.push(k[I], k[x]);\n        }\n        if (w = [...w, {\n          placement: a,\n          overflows: C\n        }], !C.every(I => I <= 0)) {\n          var P, F;\n          const I = (((P = o.flip) == null ? void 0 : P.index) || 0) + 1,\n            x = h[I];\n          if (x) return {\n            data: {\n              index: I,\n              overflows: w\n            },\n            reset: {\n              placement: x\n            }\n          };\n          let z = (F = w.filter(te => te.overflows[0] <= 0).sort((te, Q) => te.overflows[1] - Q.overflows[1])[0]) == null ? void 0 : F.placement;\n          if (!z) switch (c) {\n            case \"bestFit\":\n              {\n                var S;\n                const te = (S = w.map(Q => [Q.placement, Q.overflows.filter(G => G > 0).reduce((G, X) => G + X, 0)]).sort((Q, G) => Q[1] - G[1])[0]) == null ? void 0 : S[0];\n                te && (z = te);\n                break;\n              }\n            case \"initialPlacement\":\n              z = s;\n          }\n          if (a !== z) return {\n            reset: {\n              placement: z\n            }\n          };\n        }\n        return {};\n      }\n    };\n  };\nfunction gl(e, t) {\n  return {\n    top: e.top - t.height,\n    right: e.right - t.width,\n    bottom: e.bottom - t.height,\n    left: e.left - t.width\n  };\n}\nfunction yl(e) {\n  return Po.some(t => e[t] >= 0);\n}\nconst Hs = function (e) {\n  return e === void 0 && (e = {}), {\n    name: \"hide\",\n    options: e,\n    async fn(t) {\n      const {\n          rects: l\n        } = t,\n        {\n          strategy: a = \"referenceHidden\",\n          ...o\n        } = it(e, t);\n      switch (a) {\n        case \"referenceHidden\":\n          {\n            const n = gl(await Lt(t, {\n              ...o,\n              elementContext: \"reference\"\n            }), l.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: n,\n                referenceHidden: yl(n)\n              }\n            };\n          }\n        case \"escaped\":\n          {\n            const n = gl(await Lt(t, {\n              ...o,\n              altBoundary: !0\n            }), l.floating);\n            return {\n              data: {\n                escapedOffsets: n,\n                escaped: yl(n)\n              }\n            };\n          }\n        default:\n          return {};\n      }\n    }\n  };\n};\nfunction bl(e) {\n  const t = wt(...e.map(a => a.left)),\n    l = wt(...e.map(a => a.top));\n  return {\n    x: t,\n    y: l,\n    width: ta(...e.map(a => a.right)) - t,\n    height: ta(...e.map(a => a.bottom)) - l\n  };\n}\nconst Rs = function (e) {\n    return e === void 0 && (e = {}), {\n      name: \"inline\",\n      options: e,\n      async fn(t) {\n        const {\n            placement: l,\n            elements: a,\n            rects: o,\n            platform: n,\n            strategy: s\n          } = t,\n          {\n            padding: r = 2,\n            x: u,\n            y: f\n          } = it(e, t),\n          v = Array.from((await (n.getClientRects == null ? void 0 : n.getClientRects(a.reference))) || []),\n          p = function (m) {\n            const V = m.slice().sort((_, h) => _.y - h.y),\n              b = [];\n            let T = null;\n            for (let _ = 0; _ < V.length; _++) {\n              const h = V[_];\n              !T || h.y - T.y > T.height / 2 ? b.push([h]) : b[b.length - 1].push(h), T = h;\n            }\n            return b.map(_ => _t(bl(_)));\n          }(v),\n          c = _t(bl(v)),\n          g = Xa(r),\n          B = await n.getElementRects({\n            reference: {\n              getBoundingClientRect: function () {\n                if (p.length === 2 && p[0].left > p[1].right && u != null && f != null) return p.find(m => u > m.left - g.left && u < m.right + g.right && f > m.top - g.top && f < m.bottom + g.bottom) || c;\n                if (p.length >= 2) {\n                  if (Ct(l) === \"x\") {\n                    const k = p[0],\n                      C = p[p.length - 1],\n                      w = Ge(l) === \"top\",\n                      P = k.top,\n                      F = C.bottom,\n                      S = w ? k.left : C.left,\n                      I = w ? k.right : C.right;\n                    return {\n                      top: P,\n                      bottom: F,\n                      left: S,\n                      right: I,\n                      width: I - S,\n                      height: F - P,\n                      x: S,\n                      y: P\n                    };\n                  }\n                  const m = Ge(l) === \"left\",\n                    V = ta(...p.map(k => k.right)),\n                    b = wt(...p.map(k => k.left)),\n                    T = p.filter(k => m ? k.left === b : k.right === V),\n                    _ = T[0].top,\n                    h = T[T.length - 1].bottom;\n                  return {\n                    top: _,\n                    bottom: h,\n                    left: b,\n                    right: V,\n                    width: V - b,\n                    height: h - _,\n                    x: b,\n                    y: _\n                  };\n                }\n                return c;\n              }\n            },\n            floating: a.floating,\n            strategy: s\n          });\n        return o.reference.x !== B.reference.x || o.reference.y !== B.reference.y || o.reference.width !== B.reference.width || o.reference.height !== B.reference.height ? {\n          reset: {\n            rects: B\n          }\n        } : {};\n      }\n    };\n  },\n  Io = function (e) {\n    return e === void 0 && (e = 0), {\n      name: \"offset\",\n      options: e,\n      async fn(t) {\n        const {\n            x: l,\n            y: a\n          } = t,\n          o = await async function (n, s) {\n            const {\n                placement: r,\n                platform: u,\n                elements: f\n              } = n,\n              v = await (u.isRTL == null ? void 0 : u.isRTL(f.floating)),\n              p = Ge(r),\n              c = Ye(r),\n              g = Ct(r) === \"x\",\n              B = [\"left\", \"top\"].includes(p) ? -1 : 1,\n              m = v && g ? -1 : 1,\n              V = it(s, n);\n            let {\n              mainAxis: b,\n              crossAxis: T,\n              alignmentAxis: _\n            } = typeof V == \"number\" ? {\n              mainAxis: V,\n              crossAxis: 0,\n              alignmentAxis: null\n            } : {\n              mainAxis: 0,\n              crossAxis: 0,\n              alignmentAxis: null,\n              ...V\n            };\n            return c && typeof _ == \"number\" && (T = c === \"end\" ? -1 * _ : _), g ? {\n              x: T * m,\n              y: b * B\n            } : {\n              x: b * B,\n              y: T * m\n            };\n          }(t, e);\n        return {\n          x: l + o.x,\n          y: a + o.y,\n          data: o\n        };\n      }\n    };\n  };\nfunction Ms(e) {\n  return e === \"x\" ? \"y\" : \"x\";\n}\nconst xo = function (e) {\n  return e === void 0 && (e = {}), {\n    name: \"shift\",\n    options: e,\n    async fn(t) {\n      const {\n          x: l,\n          y: a,\n          placement: o\n        } = t,\n        {\n          mainAxis: n = !0,\n          crossAxis: s = !1,\n          limiter: r = {\n            fn: V => {\n              let {\n                x: b,\n                y: T\n              } = V;\n              return {\n                x: b,\n                y: T\n              };\n            }\n          },\n          ...u\n        } = it(e, t),\n        f = {\n          x: l,\n          y: a\n        },\n        v = await Lt(t, u),\n        p = Ct(Ge(o)),\n        c = Ms(p);\n      let g = f[p],\n        B = f[c];\n      if (n) {\n        const V = p === \"y\" ? \"bottom\" : \"right\";\n        g = ka(g + v[p === \"y\" ? \"top\" : \"left\"], g, g - v[V]);\n      }\n      if (s) {\n        const V = c === \"y\" ? \"bottom\" : \"right\";\n        B = ka(B + v[c === \"y\" ? \"top\" : \"left\"], B, B - v[V]);\n      }\n      const m = r.fn({\n        ...t,\n        [p]: g,\n        [c]: B\n      });\n      return {\n        ...m,\n        data: {\n          x: m.x - l,\n          y: m.y - a\n        }\n      };\n    }\n  };\n};\nfunction je(e) {\n  var t;\n  return ((t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;\n}\nfunction We(e) {\n  return je(e).getComputedStyle(e);\n}\nfunction Lo(e) {\n  return e instanceof je(e).Node;\n}\nfunction st(e) {\n  return Lo(e) ? (e.nodeName || \"\").toLowerCase() : \"\";\n}\nfunction Ue(e) {\n  return e instanceof je(e).HTMLElement;\n}\nfunction Ne(e) {\n  return e instanceof je(e).Element;\n}\nfunction hl(e) {\n  return typeof ShadowRoot > \"u\" ? !1 : e instanceof je(e).ShadowRoot || e instanceof ShadowRoot;\n}\nfunction Nt(e) {\n  const {\n    overflow: t,\n    overflowX: l,\n    overflowY: a,\n    display: o\n  } = We(e);\n  return /auto|scroll|overlay|hidden|clip/.test(t + a + l) && ![\"inline\", \"contents\"].includes(o);\n}\nfunction Ds(e) {\n  return [\"table\", \"td\", \"th\"].includes(st(e));\n}\nfunction Ca(e) {\n  const t = Ya(),\n    l = We(e);\n  return l.transform !== \"none\" || l.perspective !== \"none\" || !t && !!l.backdropFilter && l.backdropFilter !== \"none\" || !t && !!l.filter && l.filter !== \"none\" || [\"transform\", \"perspective\", \"filter\"].some(a => (l.willChange || \"\").includes(a)) || [\"paint\", \"layout\", \"strict\", \"content\"].some(a => (l.contain || \"\").includes(a));\n}\nfunction Ya() {\n  return !(typeof CSS > \"u\" || !CSS.supports) && CSS.supports(\"-webkit-backdrop-filter\", \"none\");\n}\nfunction va(e) {\n  return [\"html\", \"body\", \"#document\"].includes(st(e));\n}\nconst Bl = Math.min,\n  Ft = Math.max,\n  la = Math.round;\nfunction No(e) {\n  const t = We(e);\n  let l = parseFloat(t.width) || 0,\n    a = parseFloat(t.height) || 0;\n  const o = Ue(e),\n    n = o ? e.offsetWidth : l,\n    s = o ? e.offsetHeight : a,\n    r = la(l) !== n || la(a) !== s;\n  return r && (l = n, a = s), {\n    width: l,\n    height: a,\n    fallback: r\n  };\n}\nfunction zo(e) {\n  return Ne(e) ? e : e.contextElement;\n}\nconst Ho = {\n  x: 1,\n  y: 1\n};\nfunction ht(e) {\n  const t = zo(e);\n  if (!Ue(t)) return Ho;\n  const l = t.getBoundingClientRect(),\n    {\n      width: a,\n      height: o,\n      fallback: n\n    } = No(t);\n  let s = (n ? la(l.width) : l.width) / a,\n    r = (n ? la(l.height) : l.height) / o;\n  return s && Number.isFinite(s) || (s = 1), r && Number.isFinite(r) || (r = 1), {\n    x: s,\n    y: r\n  };\n}\nconst Sl = {\n  x: 0,\n  y: 0\n};\nfunction Ro(e, t, l) {\n  var a, o;\n  if (t === void 0 && (t = !0), !Ya()) return Sl;\n  const n = e ? je(e) : window;\n  return !l || t && l !== n ? Sl : {\n    x: ((a = n.visualViewport) == null ? void 0 : a.offsetLeft) || 0,\n    y: ((o = n.visualViewport) == null ? void 0 : o.offsetTop) || 0\n  };\n}\nfunction dt(e, t, l, a) {\n  t === void 0 && (t = !1), l === void 0 && (l = !1);\n  const o = e.getBoundingClientRect(),\n    n = zo(e);\n  let s = Ho;\n  t && (a ? Ne(a) && (s = ht(a)) : s = ht(e));\n  const r = Ro(n, l, a);\n  let u = (o.left + r.x) / s.x,\n    f = (o.top + r.y) / s.y,\n    v = o.width / s.x,\n    p = o.height / s.y;\n  if (n) {\n    const c = je(n),\n      g = a && Ne(a) ? je(a) : a;\n    let B = c.frameElement;\n    for (; B && a && g !== c;) {\n      const m = ht(B),\n        V = B.getBoundingClientRect(),\n        b = getComputedStyle(B);\n      V.x += (B.clientLeft + parseFloat(b.paddingLeft)) * m.x, V.y += (B.clientTop + parseFloat(b.paddingTop)) * m.y, u *= m.x, f *= m.y, v *= m.x, p *= m.y, u += V.x, f += V.y, B = je(B).frameElement;\n    }\n  }\n  return _t({\n    width: v,\n    height: p,\n    x: u,\n    y: f\n  });\n}\nfunction nt(e) {\n  return ((Lo(e) ? e.ownerDocument : e.document) || window.document).documentElement;\n}\nfunction pa(e) {\n  return Ne(e) ? {\n    scrollLeft: e.scrollLeft,\n    scrollTop: e.scrollTop\n  } : {\n    scrollLeft: e.pageXOffset,\n    scrollTop: e.pageYOffset\n  };\n}\nfunction Mo(e) {\n  return dt(nt(e)).left + pa(e).scrollLeft;\n}\nfunction $t(e) {\n  if (st(e) === \"html\") return e;\n  const t = e.assignedSlot || e.parentNode || hl(e) && e.host || nt(e);\n  return hl(t) ? t.host : t;\n}\nfunction Do(e) {\n  const t = $t(e);\n  return va(t) ? t.ownerDocument.body : Ue(t) && Nt(t) ? t : Do(t);\n}\nfunction It(e, t) {\n  var l;\n  t === void 0 && (t = []);\n  const a = Do(e),\n    o = a === ((l = e.ownerDocument) == null ? void 0 : l.body),\n    n = je(a);\n  return o ? t.concat(n, n.visualViewport || [], Nt(a) ? a : []) : t.concat(a, It(a));\n}\nfunction _l(e, t, l) {\n  let a;\n  if (t === \"viewport\") a = function (o, n) {\n    const s = je(o),\n      r = nt(o),\n      u = s.visualViewport;\n    let f = r.clientWidth,\n      v = r.clientHeight,\n      p = 0,\n      c = 0;\n    if (u) {\n      f = u.width, v = u.height;\n      const g = Ya();\n      (!g || g && n === \"fixed\") && (p = u.offsetLeft, c = u.offsetTop);\n    }\n    return {\n      width: f,\n      height: v,\n      x: p,\n      y: c\n    };\n  }(e, l);else if (t === \"document\") a = function (o) {\n    const n = nt(o),\n      s = pa(o),\n      r = o.ownerDocument.body,\n      u = Ft(n.scrollWidth, n.clientWidth, r.scrollWidth, r.clientWidth),\n      f = Ft(n.scrollHeight, n.clientHeight, r.scrollHeight, r.clientHeight);\n    let v = -s.scrollLeft + Mo(o);\n    const p = -s.scrollTop;\n    return We(r).direction === \"rtl\" && (v += Ft(n.clientWidth, r.clientWidth) - u), {\n      width: u,\n      height: f,\n      x: v,\n      y: p\n    };\n  }(nt(e));else if (Ne(t)) a = function (o, n) {\n    const s = dt(o, !0, n === \"fixed\"),\n      r = s.top + o.clientTop,\n      u = s.left + o.clientLeft,\n      f = Ue(o) ? ht(o) : {\n        x: 1,\n        y: 1\n      };\n    return {\n      width: o.clientWidth * f.x,\n      height: o.clientHeight * f.y,\n      x: u * f.x,\n      y: r * f.y\n    };\n  }(t, l);else {\n    const o = Ro(e);\n    a = {\n      ...t,\n      x: t.x - o.x,\n      y: t.y - o.y\n    };\n  }\n  return _t(a);\n}\nfunction jo(e, t) {\n  const l = $t(e);\n  return !(l === t || !Ne(l) || va(l)) && (We(l).position === \"fixed\" || jo(l, t));\n}\nfunction wl(e, t) {\n  return Ue(e) && We(e).position !== \"fixed\" ? t ? t(e) : e.offsetParent : null;\n}\nfunction $l(e, t) {\n  const l = je(e);\n  if (!Ue(e)) return l;\n  let a = wl(e, t);\n  for (; a && Ds(a) && We(a).position === \"static\";) a = wl(a, t);\n  return a && (st(a) === \"html\" || st(a) === \"body\" && We(a).position === \"static\" && !Ca(a)) ? l : a || function (o) {\n    let n = $t(o);\n    for (; Ue(n) && !va(n);) {\n      if (Ca(n)) return n;\n      n = $t(n);\n    }\n    return null;\n  }(e) || l;\n}\nfunction js(e, t, l) {\n  const a = Ue(t),\n    o = nt(t),\n    n = l === \"fixed\",\n    s = dt(e, !0, n, t);\n  let r = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const u = {\n    x: 0,\n    y: 0\n  };\n  if (a || !a && !n) if ((st(t) !== \"body\" || Nt(o)) && (r = pa(t)), Ue(t)) {\n    const f = dt(t, !0, n, t);\n    u.x = f.x + t.clientLeft, u.y = f.y + t.clientTop;\n  } else o && (u.x = Mo(o));\n  return {\n    x: s.left + r.scrollLeft - u.x,\n    y: s.top + r.scrollTop - u.y,\n    width: s.width,\n    height: s.height\n  };\n}\nconst qs = {\n  getClippingRect: function (e) {\n    let {\n      element: t,\n      boundary: l,\n      rootBoundary: a,\n      strategy: o\n    } = e;\n    const n = l === \"clippingAncestors\" ? function (f, v) {\n        const p = v.get(f);\n        if (p) return p;\n        let c = It(f).filter(V => Ne(V) && st(V) !== \"body\"),\n          g = null;\n        const B = We(f).position === \"fixed\";\n        let m = B ? $t(f) : f;\n        for (; Ne(m) && !va(m);) {\n          const V = We(m),\n            b = Ca(m);\n          b || V.position !== \"fixed\" || (g = null), (B ? !b && !g : !b && V.position === \"static\" && g && [\"absolute\", \"fixed\"].includes(g.position) || Nt(m) && !b && jo(f, m)) ? c = c.filter(T => T !== m) : g = V, m = $t(m);\n        }\n        return v.set(f, c), c;\n      }(t, this._c) : [].concat(l),\n      s = [...n, a],\n      r = s[0],\n      u = s.reduce((f, v) => {\n        const p = _l(t, v, o);\n        return f.top = Ft(p.top, f.top), f.right = Bl(p.right, f.right), f.bottom = Bl(p.bottom, f.bottom), f.left = Ft(p.left, f.left), f;\n      }, _l(t, r, o));\n    return {\n      width: u.right - u.left,\n      height: u.bottom - u.top,\n      x: u.left,\n      y: u.top\n    };\n  },\n  convertOffsetParentRelativeRectToViewportRelativeRect: function (e) {\n    let {\n      rect: t,\n      offsetParent: l,\n      strategy: a\n    } = e;\n    const o = Ue(l),\n      n = nt(l);\n    if (l === n) return t;\n    let s = {\n        scrollLeft: 0,\n        scrollTop: 0\n      },\n      r = {\n        x: 1,\n        y: 1\n      };\n    const u = {\n      x: 0,\n      y: 0\n    };\n    if ((o || !o && a !== \"fixed\") && ((st(l) !== \"body\" || Nt(n)) && (s = pa(l)), Ue(l))) {\n      const f = dt(l);\n      r = ht(l), u.x = f.x + l.clientLeft, u.y = f.y + l.clientTop;\n    }\n    return {\n      width: t.width * r.x,\n      height: t.height * r.y,\n      x: t.x * r.x - s.scrollLeft * r.x + u.x,\n      y: t.y * r.y - s.scrollTop * r.y + u.y\n    };\n  },\n  isElement: Ne,\n  getDimensions: function (e) {\n    return No(e);\n  },\n  getOffsetParent: $l,\n  getDocumentElement: nt,\n  getScale: ht,\n  async getElementRects(e) {\n    let {\n      reference: t,\n      floating: l,\n      strategy: a\n    } = e;\n    const o = this.getOffsetParent || $l,\n      n = this.getDimensions;\n    return {\n      reference: js(t, await o(l), a),\n      floating: {\n        x: 0,\n        y: 0,\n        ...(await n(l))\n      }\n    };\n  },\n  getClientRects: e => Array.from(e.getClientRects()),\n  isRTL: e => We(e).direction === \"rtl\"\n};\nfunction Gs(e, t, l, a) {\n  a === void 0 && (a = {});\n  const {\n      ancestorScroll: o = !0,\n      ancestorResize: n = !0,\n      elementResize: s = !0,\n      animationFrame: r = !1\n    } = a,\n    u = o || n ? [...(Ne(e) ? It(e) : e.contextElement ? It(e.contextElement) : []), ...It(t)] : [];\n  u.forEach(c => {\n    const g = !Ne(c) && c.toString().includes(\"V\");\n    !o || r && !g || c.addEventListener(\"scroll\", l, {\n      passive: !0\n    }), n && c.addEventListener(\"resize\", l);\n  });\n  let f,\n    v = null;\n  s && (v = new ResizeObserver(() => {\n    l();\n  }), Ne(e) && !r && v.observe(e), Ne(e) || !e.contextElement || r || v.observe(e.contextElement), v.observe(t));\n  let p = r ? dt(e) : null;\n  return r && function c() {\n    const g = dt(e);\n    !p || g.x === p.x && g.y === p.y && g.width === p.width && g.height === p.height || l(), p = g, f = requestAnimationFrame(c);\n  }(), l(), () => {\n    var c;\n    u.forEach(g => {\n      o && g.removeEventListener(\"scroll\", l), n && g.removeEventListener(\"resize\", l);\n    }), (c = v) == null || c.disconnect(), v = null, r && cancelAnimationFrame(f);\n  };\n}\nconst Ws = (e, t, l) => {\n  const a = /* @__PURE__ */new Map(),\n    o = {\n      platform: qs,\n      ...l\n    },\n    n = {\n      ...o.platform,\n      _c: a\n    };\n  return Is(e, t, {\n    ...o,\n    platform: n\n  });\n};\nfunction Ta(e) {\n  var t;\n  return (t = e == null ? void 0 : e.$el) != null ? t : e;\n}\nfunction Us(e) {\n  return {\n    name: \"arrow\",\n    options: e,\n    fn(t) {\n      const l = Ta($(e.element));\n      return l == null ? {} : xs({\n        element: l,\n        padding: e.padding\n      }).fn(t);\n    }\n  };\n}\nfunction qo(e) {\n  return typeof window > \"u\" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;\n}\nfunction kl(e, t) {\n  const l = qo(e);\n  return Math.round(t * l) / l;\n}\nfunction Go(e, t, l) {\n  l === void 0 && (l = {});\n  const a = l.whileElementsMounted,\n    o = i(() => {\n      var w;\n      return (w = $(l.open)) != null ? w : !0;\n    }),\n    n = i(() => $(l.middleware)),\n    s = i(() => {\n      var w;\n      return (w = $(l.placement)) != null ? w : \"bottom\";\n    }),\n    r = i(() => {\n      var w;\n      return (w = $(l.strategy)) != null ? w : \"absolute\";\n    }),\n    u = i(() => {\n      var w;\n      return (w = $(l.transform)) != null ? w : !0;\n    }),\n    f = i(() => Ta(e.value)),\n    v = i(() => Ta(t.value)),\n    p = M(0),\n    c = M(0),\n    g = M(r.value),\n    B = M(s.value),\n    m = za({}),\n    V = M(!1),\n    b = i(() => {\n      const w = {\n        position: g.value,\n        left: \"0\",\n        top: \"0\"\n      };\n      if (!v.value) return w;\n      const P = kl(v.value, p.value),\n        F = kl(v.value, c.value);\n      return u.value ? {\n        ...w,\n        transform: \"translate(\" + P + \"px, \" + F + \"px)\",\n        ...(qo(v.value) >= 1.5 && {\n          willChange: \"transform\"\n        })\n      } : {\n        position: g.value,\n        left: P + \"px\",\n        top: F + \"px\"\n      };\n    });\n  let T;\n  function _() {\n    f.value == null || v.value == null || Ws(f.value, v.value, {\n      middleware: n.value,\n      placement: s.value,\n      strategy: r.value\n    }).then(w => {\n      p.value = w.x, c.value = w.y, g.value = w.strategy, B.value = w.placement, m.value = w.middlewareData, V.value = !0;\n    });\n  }\n  function h() {\n    typeof T == \"function\" && (T(), T = void 0);\n  }\n  function k() {\n    if (h(), a === void 0) {\n      _();\n      return;\n    }\n    if (f.value != null && v.value != null) {\n      T = a(f.value, v.value, _);\n      return;\n    }\n  }\n  function C() {\n    o.value || (V.value = !1);\n  }\n  return se([n, s, r], _, {\n    flush: \"sync\"\n  }), se([f, v], k, {\n    flush: \"sync\"\n  }), se(o, C, {\n    flush: \"sync\"\n  }), so() && ro(h), {\n    x: vt(p),\n    y: vt(c),\n    strategy: vt(g),\n    placement: vt(B),\n    middlewareData: vt(m),\n    isPositioned: vt(V),\n    floatingStyles: b,\n    update: _\n  };\n}\nconst Ks = /* @__PURE__ */new Set([\"background\", \"cite\", \"href\", \"itemtype\", \"longdesc\", \"poster\", \"src\", \"xlink:href\"]),\n  Xs = /^aria-[\\w-]*$/i,\n  Ys = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i,\n  Js = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[\\d+/a-z]+=*$/i,\n  Zs = (e, t) => {\n    const l = e.nodeName.toLowerCase();\n    return t.includes(l) ? Ks.has(l) ? !!(Ys.test(e.nodeValue || \"\") || Js.test(e.nodeValue || \"\")) : !0 : t.filter(a => a instanceof RegExp).some(a => a.test(l));\n  },\n  gt = {\n    // Global attributes allowed on any supplied element below.\n    \"*\": [\"class\", \"dir\", \"id\", \"lang\", \"role\", Xs],\n    a: [\"target\", \"href\", \"title\", \"rel\"],\n    area: [],\n    b: [],\n    br: [],\n    col: [],\n    code: [],\n    div: [],\n    em: [],\n    hr: [],\n    h1: [],\n    h2: [],\n    h3: [],\n    h4: [],\n    h5: [],\n    h6: [],\n    i: [],\n    img: [\"src\", \"srcset\", \"alt\", \"title\", \"width\", \"height\"],\n    li: [],\n    ol: [],\n    p: [],\n    pre: [],\n    s: [],\n    small: [],\n    span: [],\n    sub: [],\n    sup: [],\n    strong: [],\n    u: [],\n    ul: []\n  },\n  yt = (e, t, l) => {\n    if (!e.length) return e;\n    if (l && typeof l == \"function\") return l(e);\n    const o = new window.DOMParser().parseFromString(e, \"text/html\"),\n      n = o.body.querySelectorAll(\"*\");\n    for (const s of n) {\n      const r = s.nodeName.toLowerCase();\n      if (!Object.keys(t).includes(r)) {\n        s.remove();\n        continue;\n      }\n      const u = s.attributes,\n        f = [...(t[\"*\"] || []), ...(t[r] || [])];\n      for (const v of u) Zs(v, f) || s.removeAttribute(v.nodeName);\n    }\n    return o.body.innerHTML;\n  };\nvar Qs = Object.defineProperty,\n  er = Object.defineProperties,\n  tr = Object.getOwnPropertyDescriptors,\n  Cl = Object.getOwnPropertySymbols,\n  ar = Object.prototype.hasOwnProperty,\n  lr = Object.prototype.propertyIsEnumerable,\n  Tl = (e, t, l) => t in e ? Qs(e, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: l\n  }) : e[t] = l,\n  or = (e, t) => {\n    for (var l in t || (t = {})) ar.call(t, l) && Tl(e, l, t[l]);\n    if (Cl) for (var l of Cl(t)) lr.call(t, l) && Tl(e, l, t[l]);\n    return e;\n  },\n  nr = (e, t) => er(e, tr(t));\nfunction Wo(e, t) {\n  var l;\n  const a = za();\n  return Rt(() => {\n    a.value = e();\n  }, nr(or({}, t), {\n    flush: (l = t == null ? void 0 : t.flush) != null ? l : \"sync\"\n  })), Be(a);\n}\nfunction ct(e) {\n  return so() ? (ro(e), !0) : !1;\n}\nfunction sr(e) {\n  let t = !1,\n    l;\n  const a = io(!0);\n  return (...o) => (t || (l = a.run(() => e(...o)), t = !0), l);\n}\nfunction rr(e) {\n  let t = 0,\n    l,\n    a;\n  const o = () => {\n    t -= 1, a && t <= 0 && (a.stop(), l = void 0, a = void 0);\n  };\n  return (...n) => (t += 1, l || (a = io(!0), l = a.run(() => e(...n))), ct(o), l);\n}\nfunction ft(e) {\n  return typeof e == \"function\" ? e() : $(e);\n}\nconst oa = typeof window < \"u\",\n  ir = e => typeof e < \"u\",\n  zt = () => {},\n  Va = /* @__PURE__ */ur();\nfunction ur() {\n  var e;\n  return oa && ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.userAgent) && /* @__PURE__ */ /iP(ad|hone|od)/.test(window.navigator.userAgent);\n}\nfunction dr(e, t) {\n  function l(...a) {\n    return new Promise((o, n) => {\n      Promise.resolve(e(() => t.apply(this, a), {\n        fn: t,\n        thisArg: this,\n        args: a\n      })).then(o).catch(n);\n    });\n  }\n  return l;\n}\nconst Uo = e => e();\nfunction cr(e = Uo) {\n  const t = M(!0);\n  function l() {\n    t.value = !1;\n  }\n  function a() {\n    t.value = !0;\n  }\n  const o = (...n) => {\n    t.value && e(...n);\n  };\n  return {\n    isActive: Be(t),\n    pause: l,\n    resume: a,\n    eventFilter: o\n  };\n}\nfunction Ja(...e) {\n  if (e.length !== 1) return Ae(...e);\n  const t = e[0];\n  return typeof t == \"function\" ? Be(jn(() => ({\n    get: t,\n    set: zt\n  }))) : M(t);\n}\nfunction fr(e, t = !0) {\n  ua() ? qe(e) : t ? e() : Oe(e);\n}\nfunction vr(e = 0, t = {}) {\n  const l = M(e),\n    {\n      max: a = 1 / 0,\n      min: o = -1 / 0\n    } = t,\n    n = (v = 1) => l.value = Math.min(a, l.value + v),\n    s = (v = 1) => l.value = Math.max(o, l.value - v),\n    r = () => l.value,\n    u = v => l.value = Math.max(o, Math.min(a, v));\n  return {\n    count: l,\n    inc: n,\n    dec: s,\n    get: r,\n    set: u,\n    reset: (v = e) => (e = v, u(v))\n  };\n}\nfunction Ko(e, t = 1e3, l = {}) {\n  const {\n    immediate: a = !0,\n    immediateCallback: o = !1\n  } = l;\n  let n = null;\n  const s = M(!1);\n  function r() {\n    n && (clearInterval(n), n = null);\n  }\n  function u() {\n    s.value = !1, r();\n  }\n  function f() {\n    const v = ft(t);\n    v <= 0 || (s.value = !0, o && e(), r(), n = setInterval(e, v));\n  }\n  if (a && oa && f(), uo(t) || typeof t == \"function\") {\n    const v = se(t, () => {\n      s.value && oa && f();\n    });\n    ct(v);\n  }\n  return ct(u), {\n    isActive: s,\n    pause: u,\n    resume: f\n  };\n}\nfunction bt(e, t = {}) {\n  const {\n    method: l = \"parseFloat\",\n    radix: a,\n    nanToZero: o\n  } = t;\n  return i(() => {\n    let n = ft(e);\n    return typeof n == \"string\" && (n = Number[l](n, a)), o && Number.isNaN(n) && (n = 0), n;\n  });\n}\nvar Vl = Object.getOwnPropertySymbols,\n  pr = Object.prototype.hasOwnProperty,\n  mr = Object.prototype.propertyIsEnumerable,\n  gr = (e, t) => {\n    var l = {};\n    for (var a in e) pr.call(e, a) && t.indexOf(a) < 0 && (l[a] = e[a]);\n    if (e != null && Vl) for (var a of Vl(e)) t.indexOf(a) < 0 && mr.call(e, a) && (l[a] = e[a]);\n    return l;\n  };\nfunction yr(e, t, l = {}) {\n  const a = l,\n    {\n      eventFilter: o = Uo\n    } = a,\n    n = gr(a, [\"eventFilter\"]);\n  return se(e, dr(o, t), n);\n}\nvar br = Object.defineProperty,\n  hr = Object.defineProperties,\n  Br = Object.getOwnPropertyDescriptors,\n  na = Object.getOwnPropertySymbols,\n  Xo = Object.prototype.hasOwnProperty,\n  Yo = Object.prototype.propertyIsEnumerable,\n  Ol = (e, t, l) => t in e ? br(e, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: l\n  }) : e[t] = l,\n  Sr = (e, t) => {\n    for (var l in t || (t = {})) Xo.call(t, l) && Ol(e, l, t[l]);\n    if (na) for (var l of na(t)) Yo.call(t, l) && Ol(e, l, t[l]);\n    return e;\n  },\n  _r = (e, t) => hr(e, Br(t)),\n  wr = (e, t) => {\n    var l = {};\n    for (var a in e) Xo.call(e, a) && t.indexOf(a) < 0 && (l[a] = e[a]);\n    if (e != null && na) for (var a of na(e)) t.indexOf(a) < 0 && Yo.call(e, a) && (l[a] = e[a]);\n    return l;\n  };\nfunction $r(e, t, l = {}) {\n  const a = l,\n    {\n      eventFilter: o\n    } = a,\n    n = wr(a, [\"eventFilter\"]),\n    {\n      eventFilter: s,\n      pause: r,\n      resume: u,\n      isActive: f\n    } = cr(o);\n  return {\n    stop: yr(e, t, _r(Sr({}, n), {\n      eventFilter: s\n    })),\n    pause: r,\n    resume: u,\n    isActive: f\n  };\n}\nfunction et(e) {\n  var t;\n  const l = ft(e);\n  return (t = l == null ? void 0 : l.$el) != null ? t : l;\n}\nconst tt = oa ? window : void 0;\nfunction Te(...e) {\n  let t, l, a, o;\n  if (typeof e[0] == \"string\" || Array.isArray(e[0]) ? ([l, a, o] = e, t = tt) : [t, l, a, o] = e, !t) return zt;\n  Array.isArray(l) || (l = [l]), Array.isArray(a) || (a = [a]);\n  const n = [],\n    s = () => {\n      n.forEach(v => v()), n.length = 0;\n    },\n    r = (v, p, c, g) => (v.addEventListener(p, c, g), () => v.removeEventListener(p, c, g)),\n    u = se(() => [et(t), ft(o)], ([v, p]) => {\n      s(), v && n.push(...l.flatMap(c => a.map(g => r(v, c, g, p))));\n    }, {\n      immediate: !0,\n      flush: \"post\"\n    }),\n    f = () => {\n      u(), s();\n    };\n  return ct(f), f;\n}\nlet Al = !1;\nfunction Jo(e, t, l = {}) {\n  const {\n    window: a = tt,\n    ignore: o = [],\n    capture: n = !0,\n    detectIframe: s = !1\n  } = l;\n  if (!a) return;\n  Va && !Al && (Al = !0, Array.from(a.document.body.children).forEach(c => c.addEventListener(\"click\", zt)));\n  let r = !0;\n  const u = c => o.some(g => {\n      if (typeof g == \"string\") return Array.from(a.document.querySelectorAll(g)).some(B => B === c.target || c.composedPath().includes(B));\n      {\n        const B = et(g);\n        return B && (c.target === B || c.composedPath().includes(B));\n      }\n    }),\n    v = [Te(a, \"click\", c => {\n      const g = et(e);\n      if (!(!g || g === c.target || c.composedPath().includes(g))) {\n        if (c.detail === 0 && (r = !u(c)), !r) {\n          r = !0;\n          return;\n        }\n        t(c);\n      }\n    }, {\n      passive: !0,\n      capture: n\n    }), Te(a, \"pointerdown\", c => {\n      const g = et(e);\n      g && (r = !c.composedPath().includes(g) && !u(c));\n    }, {\n      passive: !0\n    }), s && Te(a, \"blur\", c => {\n      setTimeout(() => {\n        var g;\n        const B = et(e);\n        ((g = a.document.activeElement) == null ? void 0 : g.tagName) === \"IFRAME\" && !(B != null && B.contains(a.document.activeElement)) && t(c);\n      }, 0);\n    })].filter(Boolean);\n  return () => v.forEach(c => c());\n}\nfunction kr() {\n  const e = M(!1);\n  return ua() && qe(() => {\n    e.value = !0;\n  }), e;\n}\nfunction Cr(e) {\n  const t = kr();\n  return i(() => (t.value, !!e()));\n}\nfunction Tr(e, t = {}) {\n  const {\n      window: l = tt\n    } = t,\n    a = Cr(() => l && \"matchMedia\" in l && typeof l.matchMedia == \"function\");\n  let o;\n  const n = M(!1),\n    s = () => {\n      o && (\"removeEventListener\" in o ? o.removeEventListener(\"change\", r) : o.removeListener(r));\n    },\n    r = () => {\n      a.value && (s(), o = l.matchMedia(Ja(e).value), n.value = !!(o != null && o.matches), o && (\"addEventListener\" in o ? o.addEventListener(\"change\", r) : o.addListener(r)));\n    };\n  return Rt(r), ct(() => s()), n;\n}\nfunction Vr(e) {\n  return JSON.parse(JSON.stringify(e));\n}\nconst Wt = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {},\n  Ut = \"__vueuse_ssr_handlers__\",\n  Or = /* @__PURE__ */Ar();\nfunction Ar() {\n  return Ut in Wt || (Wt[Ut] = Wt[Ut] || {}), Wt[Ut];\n}\nfunction Za(e, t) {\n  return Or[e] || t;\n}\nfunction Pr(e) {\n  return e == null ? \"any\" : e instanceof Set ? \"set\" : e instanceof Map ? \"map\" : e instanceof Date ? \"date\" : typeof e == \"boolean\" ? \"boolean\" : typeof e == \"string\" ? \"string\" : typeof e == \"object\" ? \"object\" : Number.isNaN(e) ? \"any\" : \"number\";\n}\nvar Er = Object.defineProperty,\n  Pl = Object.getOwnPropertySymbols,\n  Fr = Object.prototype.hasOwnProperty,\n  Ir = Object.prototype.propertyIsEnumerable,\n  El = (e, t, l) => t in e ? Er(e, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: l\n  }) : e[t] = l,\n  Fl = (e, t) => {\n    for (var l in t || (t = {})) Fr.call(t, l) && El(e, l, t[l]);\n    if (Pl) for (var l of Pl(t)) Ir.call(t, l) && El(e, l, t[l]);\n    return e;\n  };\nconst xr = {\n    boolean: {\n      read: e => e === \"true\",\n      write: e => String(e)\n    },\n    object: {\n      read: e => JSON.parse(e),\n      write: e => JSON.stringify(e)\n    },\n    number: {\n      read: e => Number.parseFloat(e),\n      write: e => String(e)\n    },\n    any: {\n      read: e => e,\n      write: e => String(e)\n    },\n    string: {\n      read: e => e,\n      write: e => String(e)\n    },\n    map: {\n      read: e => new Map(JSON.parse(e)),\n      write: e => JSON.stringify(Array.from(e.entries()))\n    },\n    set: {\n      read: e => new Set(JSON.parse(e)),\n      write: e => JSON.stringify(Array.from(e))\n    },\n    date: {\n      read: e => new Date(e),\n      write: e => e.toISOString()\n    }\n  },\n  Il = \"vueuse-storage\";\nfunction Lr(e, t, l, a = {}) {\n  var o;\n  const {\n      flush: n = \"pre\",\n      deep: s = !0,\n      listenToStorageChanges: r = !0,\n      writeDefaults: u = !0,\n      mergeDefaults: f = !1,\n      shallow: v,\n      window: p = tt,\n      eventFilter: c,\n      onError: g = P => {\n        console.error(P);\n      }\n    } = a,\n    B = (v ? za : M)(t);\n  if (!l) try {\n    l = Za(\"getDefaultStorage\", () => {\n      var P;\n      return (P = tt) == null ? void 0 : P.localStorage;\n    })();\n  } catch (P) {\n    g(P);\n  }\n  if (!l) return B;\n  const m = ft(t),\n    V = Pr(m),\n    b = (o = a.serializer) != null ? o : xr[V],\n    {\n      pause: T,\n      resume: _\n    } = $r(B, () => h(B.value), {\n      flush: n,\n      deep: s,\n      eventFilter: c\n    });\n  return p && r && (Te(p, \"storage\", w), Te(p, Il, C)), w(), B;\n  function h(P) {\n    try {\n      if (P == null) l.removeItem(e);else {\n        const F = b.write(P),\n          S = l.getItem(e);\n        S !== F && (l.setItem(e, F), p && p.dispatchEvent(new CustomEvent(Il, {\n          detail: {\n            key: e,\n            oldValue: S,\n            newValue: F,\n            storageArea: l\n          }\n        })));\n      }\n    } catch (F) {\n      g(F);\n    }\n  }\n  function k(P) {\n    const F = P ? P.newValue : l.getItem(e);\n    if (F == null) return u && m !== null && l.setItem(e, b.write(m)), m;\n    if (!P && f) {\n      const S = b.read(F);\n      return typeof f == \"function\" ? f(S, m) : V === \"object\" && !Array.isArray(S) ? Fl(Fl({}, m), S) : S;\n    } else return typeof F != \"string\" ? F : b.read(F);\n  }\n  function C(P) {\n    w(P.detail);\n  }\n  function w(P) {\n    if (!(P && P.storageArea !== l)) {\n      if (P && P.key == null) {\n        B.value = m;\n        return;\n      }\n      if (!(P && P.key !== e)) {\n        T();\n        try {\n          B.value = k(P);\n        } catch (F) {\n          g(F);\n        } finally {\n          P ? Oe(_) : _();\n        }\n      }\n    }\n  }\n}\nfunction Nr(e) {\n  return Tr(\"(prefers-color-scheme: dark)\", e);\n}\nvar zr = Object.defineProperty,\n  xl = Object.getOwnPropertySymbols,\n  Hr = Object.prototype.hasOwnProperty,\n  Rr = Object.prototype.propertyIsEnumerable,\n  Ll = (e, t, l) => t in e ? zr(e, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: l\n  }) : e[t] = l,\n  Mr = (e, t) => {\n    for (var l in t || (t = {})) Hr.call(t, l) && Ll(e, l, t[l]);\n    if (xl) for (var l of xl(t)) Rr.call(t, l) && Ll(e, l, t[l]);\n    return e;\n  };\nfunction Dr(e = {}) {\n  const {\n      selector: t = \"html\",\n      attribute: l = \"class\",\n      initialValue: a = \"auto\",\n      window: o = tt,\n      storage: n,\n      storageKey: s = \"vueuse-color-scheme\",\n      listenToStorageChanges: r = !0,\n      storageRef: u,\n      emitAuto: f,\n      disableTransition: v = !0\n    } = e,\n    p = Mr({\n      auto: \"\",\n      light: \"light\",\n      dark: \"dark\"\n    }, e.modes || {}),\n    c = Nr({\n      window: o\n    }),\n    g = i(() => c.value ? \"dark\" : \"light\"),\n    B = u || (s == null ? Ja(a) : Lr(s, a, n, {\n      window: o,\n      listenToStorageChanges: r\n    })),\n    m = i(() => B.value === \"auto\" ? g.value : B.value),\n    V = Za(\"updateHTMLAttrs\", (h, k, C) => {\n      const w = typeof h == \"string\" ? o == null ? void 0 : o.document.querySelector(h) : et(h);\n      if (!w) return;\n      let P;\n      if (v) {\n        P = o.document.createElement(\"style\");\n        const F = \"*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}\";\n        P.appendChild(document.createTextNode(F)), o.document.head.appendChild(P);\n      }\n      if (k === \"class\") {\n        const F = C.split(/\\s/g);\n        Object.values(p).flatMap(S => (S || \"\").split(/\\s/g)).filter(Boolean).forEach(S => {\n          F.includes(S) ? w.classList.add(S) : w.classList.remove(S);\n        });\n      } else w.setAttribute(k, C);\n      v && (o.getComputedStyle(P).opacity, document.head.removeChild(P));\n    });\n  function b(h) {\n    var k;\n    V(t, l, (k = p[h]) != null ? k : h);\n  }\n  function T(h) {\n    e.onChanged ? e.onChanged(h, b) : b(h);\n  }\n  se(m, T, {\n    flush: \"post\",\n    immediate: !0\n  }), fr(() => T(m.value));\n  const _ = i({\n    get() {\n      return f ? B.value : m.value;\n    },\n    set(h) {\n      B.value = h;\n    }\n  });\n  try {\n    return Object.assign(_, {\n      store: B,\n      system: g,\n      state: m\n    });\n  } catch {\n    return _;\n  }\n}\nfunction ze(e, t = {}) {\n  const {\n      initialValue: l = !1\n    } = t,\n    a = M(!1),\n    o = i(() => et(e));\n  Te(o, \"focus\", () => a.value = !0), Te(o, \"blur\", () => a.value = !1);\n  const n = i({\n    get: () => a.value,\n    set(s) {\n      var r, u;\n      !s && a.value ? (r = o.value) == null || r.blur() : s && !a.value && ((u = o.value) == null || u.focus());\n    }\n  });\n  return se(o, () => {\n    n.value = l;\n  }, {\n    immediate: !0,\n    flush: \"post\"\n  }), {\n    focused: n\n  };\n}\nconst jr = {\n  page: e => [e.pageX, e.pageY],\n  client: e => [e.clientX, e.clientY],\n  screen: e => [e.screenX, e.screenY],\n  movement: e => e instanceof Touch ? null : [e.movementX, e.movementY]\n};\nfunction qr(e = {}) {\n  const {\n      type: t = \"page\",\n      touch: l = !0,\n      resetOnTouchEnds: a = !1,\n      initialValue: o = {\n        x: 0,\n        y: 0\n      },\n      window: n = tt,\n      target: s = n,\n      eventFilter: r\n    } = e,\n    u = M(o.x),\n    f = M(o.y),\n    v = M(null),\n    p = typeof t == \"function\" ? t : jr[t],\n    c = b => {\n      const T = p(b);\n      T && ([u.value, f.value] = T, v.value = \"mouse\");\n    },\n    g = b => {\n      if (b.touches.length > 0) {\n        const T = p(b.touches[0]);\n        T && ([u.value, f.value] = T, v.value = \"touch\");\n      }\n    },\n    B = () => {\n      u.value = o.x, f.value = o.y;\n    },\n    m = r ? b => r(() => c(b), {}) : b => c(b),\n    V = r ? b => r(() => g(b), {}) : b => g(b);\n  return s && (Te(s, \"mousemove\", m, {\n    passive: !0\n  }), Te(s, \"dragover\", m, {\n    passive: !0\n  }), l && t !== \"movement\" && (Te(s, \"touchstart\", V, {\n    passive: !0\n  }), Te(s, \"touchmove\", V, {\n    passive: !0\n  }), a && Te(s, \"touchend\", B, {\n    passive: !0\n  }))), {\n    x: u,\n    y: f,\n    sourceType: v\n  };\n}\nfunction Nl(e, t = {}) {\n  const {\n      handleOutside: l = !0,\n      window: a = tt\n    } = t,\n    {\n      x: o,\n      y: n,\n      sourceType: s\n    } = qr(t),\n    r = M(e ?? (a == null ? void 0 : a.document.body)),\n    u = M(0),\n    f = M(0),\n    v = M(0),\n    p = M(0),\n    c = M(0),\n    g = M(0),\n    B = M(!0);\n  let m = () => {};\n  return a && (m = se([r, o, n], () => {\n    const V = et(r);\n    if (!V) return;\n    const {\n      left: b,\n      top: T,\n      width: _,\n      height: h\n    } = V.getBoundingClientRect();\n    v.value = b + a.pageXOffset, p.value = T + a.pageYOffset, c.value = h, g.value = _;\n    const k = o.value - v.value,\n      C = n.value - p.value;\n    B.value = _ === 0 || h === 0 || k < 0 || C < 0 || k > _ || C > h, (l || !B.value) && (u.value = k, f.value = C);\n  }, {\n    immediate: !0\n  }), Te(document, \"mouseleave\", () => {\n    B.value = !0;\n  })), {\n    x: o,\n    y: n,\n    sourceType: s,\n    elementX: u,\n    elementY: f,\n    elementPositionX: v,\n    elementPositionY: p,\n    elementHeight: c,\n    elementWidth: g,\n    isOutside: B,\n    stop: m\n  };\n}\nfunction Zo(e) {\n  const t = window.getComputedStyle(e);\n  if (t.overflowX === \"scroll\" || t.overflowY === \"scroll\" || t.overflowX === \"auto\" && e.clientWidth < e.scrollWidth || t.overflowY === \"auto\" && e.clientHeight < e.scrollHeight) return !0;\n  {\n    const l = e.parentNode;\n    return !l || l.tagName === \"BODY\" ? !1 : Zo(l);\n  }\n}\nfunction Gr(e) {\n  const t = e || window.event,\n    l = t.target;\n  return Zo(l) ? !1 : t.touches.length > 1 ? !0 : (t.preventDefault && t.preventDefault(), !1);\n}\nfunction Wr(e, t = !1) {\n  const l = M(t);\n  let a = null,\n    o;\n  se(Ja(e), r => {\n    if (r) {\n      const u = r;\n      o = u.style.overflow, l.value && (u.style.overflow = \"hidden\");\n    }\n  }, {\n    immediate: !0\n  });\n  const n = () => {\n      const r = ft(e);\n      !r || l.value || (Va && (a = Te(r, \"touchmove\", u => {\n        Gr(u);\n      }, {\n        passive: !1\n      })), r.style.overflow = \"hidden\", l.value = !0);\n    },\n    s = () => {\n      const r = ft(e);\n      !r || !l.value || (Va && (a == null || a()), r.style.overflow = o, l.value = !1);\n    };\n  return ct(s), i({\n    get() {\n      return l.value;\n    },\n    set(r) {\n      r ? n() : s();\n    }\n  });\n}\nfunction Ur(e, t = {}) {\n  const {\n      threshold: l = 50,\n      onSwipe: a,\n      onSwipeEnd: o,\n      onSwipeStart: n,\n      passive: s = !0,\n      window: r = tt\n    } = t,\n    u = Bt({\n      x: 0,\n      y: 0\n    }),\n    f = Bt({\n      x: 0,\n      y: 0\n    }),\n    v = i(() => u.x - f.x),\n    p = i(() => u.y - f.y),\n    {\n      max: c,\n      abs: g\n    } = Math,\n    B = i(() => c(g(v.value), g(p.value)) >= l),\n    m = M(!1),\n    V = i(() => B.value ? g(v.value) > g(p.value) ? v.value > 0 ? \"left\" : \"right\" : p.value > 0 ? \"up\" : \"down\" : \"none\"),\n    b = F => [F.touches[0].clientX, F.touches[0].clientY],\n    T = (F, S) => {\n      u.x = F, u.y = S;\n    },\n    _ = (F, S) => {\n      f.x = F, f.y = S;\n    };\n  let h;\n  const k = Kr(r == null ? void 0 : r.document);\n  s ? h = k ? {\n    passive: !0\n  } : {\n    capture: !1\n  } : h = k ? {\n    passive: !1,\n    capture: !0\n  } : {\n    capture: !0\n  };\n  const C = F => {\n      m.value && (o == null || o(F, V.value)), m.value = !1;\n    },\n    w = [Te(e, \"touchstart\", F => {\n      if (F.touches.length !== 1) return;\n      h.capture && !h.passive && F.preventDefault();\n      const [S, I] = b(F);\n      T(S, I), _(S, I), n == null || n(F);\n    }, h), Te(e, \"touchmove\", F => {\n      if (F.touches.length !== 1) return;\n      const [S, I] = b(F);\n      _(S, I), !m.value && B.value && (m.value = !0), m.value && (a == null || a(F));\n    }, h), Te(e, \"touchend\", C, h), Te(e, \"touchcancel\", C, h)];\n  return {\n    isPassiveEventSupported: k,\n    isSwiping: m,\n    direction: V,\n    coordsStart: u,\n    coordsEnd: f,\n    lengthX: v,\n    lengthY: p,\n    stop: () => w.forEach(F => F())\n  };\n}\nfunction Kr(e) {\n  if (!e) return !1;\n  let t = !1;\n  const l = {\n    get passive() {\n      return t = !0, !1;\n    }\n  };\n  return e.addEventListener(\"x\", zt, l), e.removeEventListener(\"x\", zt), t;\n}\nfunction ke(e, t, l, a = {}) {\n  var o, n, s;\n  const {\n      clone: r = !1,\n      passive: u = !1,\n      eventName: f,\n      deep: v = !1,\n      defaultValue: p,\n      shouldEmit: c\n    } = a,\n    g = ua(),\n    B = l || (g == null ? void 0 : g.emit) || ((o = g == null ? void 0 : g.$emit) == null ? void 0 : o.bind(g)) || ((s = (n = g == null ? void 0 : g.proxy) == null ? void 0 : n.$emit) == null ? void 0 : s.bind(g == null ? void 0 : g.proxy));\n  let m = f;\n  t || (t = \"modelValue\"), m = m || `update:${t.toString()}`;\n  const V = _ => r ? typeof r == \"function\" ? r(_) : Vr(_) : _,\n    b = () => ir(e[t]) ? V(e[t]) : p,\n    T = _ => {\n      c ? c(_) && B(m, _) : B(m, _);\n    };\n  if (u) {\n    const _ = b(),\n      h = M(_);\n    return se(() => e[t], k => h.value = V(k)), se(h, k => {\n      (k !== e[t] || v) && T(k);\n    }, {\n      deep: v\n    }), h;\n  } else return i({\n    get() {\n      return b();\n    },\n    set(_) {\n      T(_);\n    }\n  });\n}\nconst Qa = H({\n    name: \"ComponentOrEmpty\",\n    slots: Object,\n    props: {\n      tag: {\n        type: String,\n        default: \"div\"\n      },\n      to: {\n        type: [String, Object],\n        default: null\n      },\n      skip: {\n        type: Boolean,\n        default: !1\n      }\n    },\n    setup(e, {\n      slots: t,\n      attrs: l\n    }) {\n      return () => {\n        var a, o, n;\n        return e.skip ? (a = t.default) == null ? void 0 : a.call(t) : e.tag === \"Teleport\" ? ie(Ha, {\n          to: e.to\n        }, [(o = t.default) == null ? void 0 : o.call(t)]) : ie(e.tag, {\n          ...l\n        }, [(n = t.default) == null ? void 0 : n.call(t)]);\n      };\n    }\n  }),\n  jt = e => Wo(() => {\n    const t = at(e);\n    return t ? `justify-content-${t}` : \"\";\n  });\nfunction d(e) {\n  return Wo(() => {\n    const t = at(e);\n    return t == null ? t : Ma(t);\n  });\n}\nconst Qo = sr(() => {\n    const e = Bt([]);\n    return {\n      items: e,\n      reset: () => {\n        e.splice(0, e.length);\n      }\n    };\n  }),\n  Xr = (e = {}) => {\n    const t = e.persist ?? !1,\n      l = \"data-bs-theme\",\n      a = \"body\";\n    return Dr({\n      attribute: l,\n      selector: a,\n      storageKey: t === !0 ? `bv-color-${e.attribute ?? l}-${e.selector ?? a}` : null,\n      ...e\n    });\n  },\n  Yr = (e, t = M(1e3), l = {}) => {\n    const a = Be(Ae(e)),\n      o = Be(Ae(t)),\n      n = M(!1),\n      s = M(0),\n      r = i(() => Math.ceil(a.value / o.value)),\n      u = i(() => p.value || n.value ? Math.round(a.value - s.value * o.value) : 0),\n      {\n        pause: f,\n        resume: v,\n        isActive: p\n      } = Ko(() => {\n        s.value = s.value + 1;\n      }, t, l),\n      c = () => {\n        n.value = !1, s.value = 0, v();\n      },\n      g = () => {\n        n.value = !1, s.value = r.value;\n      };\n    Rt(() => {\n      s.value > r.value && (s.value = r.value), s.value === r.value && f();\n    }), se([o, a], () => {\n      g(), c();\n    });\n    const B = () => {\n        p.value !== !1 && (n.value = !0, f());\n      },\n      m = () => {\n        s.value !== r.value && (n.value = !1, v());\n      };\n    return {\n      isActive: Be(p),\n      isPaused: Be(n),\n      restart: c,\n      stop: g,\n      pause: B,\n      resume: m,\n      value: u\n    };\n  },\n  en = e => i(() => {\n    const t = at(e);\n    return {\n      \"form-check\": t.plain === !1 && t.button === !1,\n      \"form-check-inline\": t.inline === !0,\n      \"form-switch\": t.switch === !0,\n      [`form-control-${t.size}`]: t.size !== void 0 && t.size !== \"md\" && t.button === !1\n    };\n  }),\n  tn = e => i(() => {\n    const t = at(e);\n    return {\n      \"form-check-input\": t.plain === !1 && t.button === !1,\n      \"is-valid\": t.state === !0,\n      \"is-invalid\": t.state === !1,\n      \"btn-check\": t.button === !0\n    };\n  }),\n  an = e => i(() => {\n    const t = at(e);\n    return {\n      \"form-check-label\": t.plain === !1 && t.button === !1,\n      btn: t.button === !0,\n      [`btn-${t.buttonVariant}`]: t.button === !0 && t.buttonVariant !== void 0 && t.buttonVariant !== null,\n      [`btn-${t.size}`]: t.button && t.size && t.size !== \"md\"\n    };\n  }),\n  ln = e => i(() => {\n    const t = at(e);\n    return {\n      \"aria-invalid\": fa(t.ariaInvalid, t.state),\n      \"aria-required\": t.required === !0 ? !0 : void 0\n    };\n  }),\n  on = e => i(() => {\n    const t = at(e);\n    return {\n      \"was-validated\": t.validated === !0,\n      \"btn-group\": t.buttons === !0 && t.stacked === !1,\n      \"btn-group-vertical\": t.stacked === !0 && t.buttons === !0,\n      [`btn-group-${t.size}`]: t.size !== void 0\n    };\n  }),\n  nn = (e, t) => {\n    const l = M(null);\n    let a = null,\n      o = !0;\n    const n = Ve(() => e.id, \"input\"),\n      s = d(() => e.autofocus),\n      r = d(() => e.disabled),\n      u = d(() => e.lazy),\n      f = d(() => e.lazyFormatter),\n      v = d(() => e.number);\n    d(() => e.plaintext), d(() => e.readonly), d(() => e.required);\n    const p = d(() => e.state),\n      c = d(() => e.trim),\n      {\n        focused: g\n      } = ze(l, {\n        initialValue: s.value\n      }),\n      B = (w, P, F = !1) => (w = String(w), typeof e.formatter == \"function\" && (!f.value || F) ? (o = !1, e.formatter(w, P)) : w),\n      m = w => c.value ? w.trim() : v.value ? Number.parseFloat(w) : w,\n      V = () => {\n        s.value && (g.value = !0);\n      };\n    qe(() => {\n      l.value && (l.value.value = e.modelValue);\n    }), qn(() => {\n      Oe(() => {\n        V();\n      });\n    });\n    const b = i(() => fa(e.ariaInvalid, p.value)),\n      T = w => {\n        const {\n            value: P\n          } = w.target,\n          F = B(P, w);\n        if (F === !1 || w.defaultPrevented) {\n          w.preventDefault();\n          return;\n        }\n        if (u.value) return;\n        const S = m(F);\n        e.modelValue !== S && (a = P, t(\"update:modelValue\", S)), t(\"input\", F);\n      },\n      _ = w => {\n        const {\n            value: P\n          } = w.target,\n          F = B(P, w);\n        if (F === !1 || w.defaultPrevented) {\n          w.preventDefault();\n          return;\n        }\n        if (!u.value) return;\n        a = P, t(\"update:modelValue\", F);\n        const S = m(F);\n        e.modelValue !== S && t(\"change\", F);\n      },\n      h = w => {\n        if (t(\"blur\", w), !u.value && !f.value) return;\n        const {\n            value: P\n          } = w.target,\n          F = B(P, w, !0);\n        a = P, t(\"update:modelValue\", F);\n      },\n      k = () => {\n        r.value || (g.value = !0);\n      },\n      C = () => {\n        var w;\n        r.value || (w = l.value) == null || w.blur();\n      };\n    return se(() => e.modelValue, w => {\n      l.value && (l.value.value = a && o ? a : w, a = null, o = !0);\n    }), {\n      input: l,\n      computedId: n,\n      computedAriaInvalid: b,\n      onInput: T,\n      onChange: _,\n      onBlur: h,\n      focus: k,\n      blur: C\n    };\n  },\n  mt = (e, t) => {\n    if (!e) return e;\n    if (t in e) return e[t];\n    const l = t.split(\".\");\n    return mt(e[l[0]], l.splice(1).join(\".\"));\n  },\n  ha = (e, t = null, l, a) => {\n    if (Object.prototype.toString.call(e) === \"[object Object]\") {\n      const o = mt(e, a.valueField),\n        n = mt(e, a.textField),\n        s = mt(e, a.htmlField),\n        r = mt(e, a.disabledField),\n        u = e[a.optionsField] || null;\n      return u !== null ? {\n        label: String(mt(e, a.labelField) || n),\n        options: el(u, l, a)\n      } : {\n        value: typeof o > \"u\" ? t || n : o,\n        text: String(typeof n > \"u\" ? t : n),\n        html: s,\n        disabled: !!r\n      };\n    }\n    return {\n      value: t || e,\n      text: String(e),\n      disabled: !1\n    };\n  },\n  el = (e, t, l) => Array.isArray(e) ? e.map(a => ha(a, null, t, l)) : Object.prototype.toString.call(e) === \"[object Object]\" ? (console.warn(`[BootstrapVue warn]: ${t} - Setting prop \"options\" to an object is deprecated. Use the array format instead.`), Object.keys(e).map(a => {\n    const o = e[a];\n    switch (typeof o) {\n      case \"object\":\n        return ha(o.text, String(o.value), t, l);\n      default:\n        return ha(o, String(a), t, l);\n    }\n  })) : [],\n  Ve = (e, t) => i(() => at(e) || lt(t)),\n  Ba = \"modal-open\",\n  Jr = rr(() => {\n    const {\n        count: e,\n        inc: t,\n        dec: l\n      } = vr(),\n      a = Za(\"updateHTMLAttrs\", (o, n, s) => {\n        const r = typeof o == \"string\" ? window == null ? void 0 : window.document.querySelector(o) : et(o);\n        r && (n === \"class\" ? r.classList.toggle(Ba, s === Ba) : r.setAttribute(n, s));\n      });\n    return ct(() => {\n      a(\"body\", \"class\", \"\");\n    }), se(e, o => {\n      a(\"body\", \"class\", o > 0 ? Ba : \"\");\n    }), {\n      inc: t,\n      dec: l\n    };\n  }),\n  Zr = e => {\n    const {\n      inc: t,\n      dec: l\n    } = Jr();\n    se(e, (a, o) => {\n      a ? t() : o && !a && l();\n    }, {\n      immediate: !0\n    });\n  },\n  sn = (e, t) => {\n    const l = Be(Ae(e)),\n      a = Be(Ae(t)),\n      o = i(() => !a.value),\n      n = M(null);\n    qe(() => {\n      n.value = document.body;\n    });\n    const s = Wr(n, l.value && o.value);\n    se([l, o], ([r, u]) => {\n      s.value = r && u;\n    });\n  },\n  Tt = e => i(() => {\n    const t = at(e);\n    return t === !0 ? \"is-valid\" : t === !1 ? \"is-invalid\" : null;\n  }),\n  Qr = [\"id\"],\n  ei = [\"innerHTML\"],\n  ti = [\"innerHTML\"],\n  tl = /* @__PURE__ */H({\n    inheritAttrs: !1,\n    __name: \"BPopover\",\n    props: {\n      modelValue: {\n        type: [String, Boolean],\n        default: !1\n      },\n      container: {\n        default: void 0\n      },\n      target: {\n        type: [Function, String, null],\n        default: null\n      },\n      reference: {\n        type: [Function, String, null],\n        default: null\n      },\n      content: {\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      title: {\n        default: void 0\n      },\n      delay: {\n        default: () => ({\n          show: 100,\n          hide: 300\n        })\n      },\n      click: {\n        type: [String, Boolean],\n        default: !1\n      },\n      manual: {\n        type: [String, Boolean],\n        default: !1\n      },\n      variant: {\n        default: null\n      },\n      offset: {\n        default: null\n      },\n      customClass: {\n        default: \"\"\n      },\n      placement: {\n        default: \"top\"\n      },\n      strategy: {\n        default: \"absolute\"\n      },\n      floatingMiddleware: {\n        default: void 0\n      },\n      noFlip: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noShift: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noFade: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noAutoClose: {\n        type: [String, Boolean],\n        default: !1\n      },\n      hide: {\n        type: [String, Boolean],\n        default: !0\n      },\n      realtime: {\n        type: [String, Boolean],\n        default: !1\n      },\n      inline: {\n        type: [String, Boolean],\n        default: !1\n      },\n      tooltip: {\n        type: [String, Boolean],\n        default: !1\n      },\n      html: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    emits: [\"show\", \"shown\", \"hide\", \"hidden\", \"hide-prevented\", \"show-prevented\", \"update:modelValue\"],\n    setup(e, {\n      expose: t,\n      emit: l\n    }) {\n      const a = e,\n        o = d(() => a.modelValue),\n        n = M(o.value),\n        s = M(o.value);\n      Rt(() => {\n        l(\"update:modelValue\", n.value);\n      }), se(o, () => {\n        o.value !== n.value && (o.value ? le() : de(new Event(\"update:modelValue\")));\n      });\n      const r = Ve(() => a.id, \"popover\"),\n        u = d(() => a.click),\n        f = d(() => a.manual),\n        v = d(() => a.noShift),\n        p = d(() => a.noFlip),\n        c = d(() => a.noFade),\n        g = d(() => a.noAutoClose),\n        B = d(() => a.hide),\n        m = d(() => a.realtime),\n        V = d(() => a.inline),\n        b = d(() => a.tooltip),\n        T = d(() => a.html),\n        _ = M(!1),\n        h = M(null),\n        k = M(null),\n        C = M(null),\n        w = M(null),\n        P = M(null),\n        F = K => {\n          if (typeof K == \"string\" || K instanceof HTMLElement) return K;\n          if (typeof K == \"function\") return K().$el ? K().$el : K();\n          if (typeof K < \"u\") return K.$el;\n        },\n        S = K => {\n          if (K) {\n            if (typeof K == \"string\") {\n              const ce = document.getElementById(K);\n              return ce || void 0;\n            }\n            return K;\n          }\n        },\n        I = i(() => a.title ? yt(a.title, gt) : \"\"),\n        x = i(() => a.content ? yt(a.content, gt) : \"\"),\n        z = i(() => a.placement.startsWith(\"auto\")),\n        te = i(() => {\n          if (a.floatingMiddleware !== void 0) return a.floatingMiddleware;\n          const K = typeof a.offset == \"number\" ? a.offset : b.value ? 0 : 10,\n            ce = [Io(K)];\n          return p.value === !1 && !z.value && ce.push(Fo()), z.value && ce.push(zs({\n            alignment: a.placement.split(\"-\")[1] || void 0\n          })), v.value === !1 && ce.push(xo()), B.value === !0 && ce.push(Hs({\n            padding: 10\n          })), V.value === !0 && ce.push(Rs()), ce.push(Us({\n            element: C,\n            padding: 10\n          })), ce;\n        }),\n        Q = i(() => z.value ? void 0 : a.placement),\n        {\n          x: G,\n          y: X,\n          strategy: U,\n          middlewareData: pe,\n          placement: be,\n          update: he\n        } = Go(k, h, {\n          placement: Q,\n          middleware: te,\n          strategy: a.strategy,\n          whileElementsMounted: (...K) => Gs(...K, {\n            animationFrame: m.value\n          })\n        }),\n        ye = M({\n          position: \"absolute\"\n        });\n      se(pe, () => {\n        var K;\n        if (B.value === !0 && ((K = pe.value.hide) != null && K.referenceHidden ? _.value = !0 : _.value = !1), pe.value.arrow) {\n          const {\n            x: ce,\n            y: Le\n          } = pe.value.arrow;\n          ye.value = {\n            position: \"absolute\",\n            top: Le ? `${Le}px` : \"\",\n            left: ce ? `${ce}px` : \"\"\n          };\n        }\n      });\n      const q = i(() => {\n          const K = b.value ? \"tooltip\" : \"popover\";\n          return [K, `b-${K}`, {\n            [`b-${K}-${a.variant}`]: a.variant !== null,\n            show: n.value && !_.value,\n            [\"pe-none\"]: !n.value,\n            fade: !c.value,\n            [\"d-none\"]: !n.value && c.value,\n            [`${a.customClass}`]: a.customClass !== void 0,\n            [`bs-${K}-${li(be.value)}`]: be.value !== void 0\n          }];\n        }),\n        {\n          isOutside: ee\n        } = Nl(h),\n        {\n          isOutside: ne\n        } = Nl(w),\n        ue = K => {\n          const ce = K ?? new Event(\"click\");\n          n.value ? de(ce) : le();\n        },\n        N = (K, ce = {}) => new Mt(K, {\n          cancelable: !1,\n          target: h.value || null,\n          relatedTarget: null,\n          trigger: null,\n          ...ce,\n          componentId: r.value\n        }),\n        le = () => {\n          const K = N(\"show\", {\n            cancelable: !0\n          });\n          if (l(\"show\", K), K.defaultPrevented) {\n            l(\"show-prevented\");\n            return;\n          }\n          s.value = !0, Oe(() => {\n            var ce;\n            he(), setTimeout(() => {\n              he(), n.value = !0, Oe(() => {\n                l(\"shown\", N(\"shown\"));\n              });\n            }, typeof a.delay == \"number\" ? a.delay : ((ce = a.delay) == null ? void 0 : ce.show) || 0);\n          });\n        },\n        de = K => {\n          var E;\n          const ce = N(\"hide\", {\n            cancelable: !0\n          });\n          if (l(\"hide\", ce), ce.defaultPrevented) {\n            l(\"hide-prevented\");\n            return;\n          }\n          const Le = typeof a.delay == \"number\" ? a.delay : ((E = a.delay) == null ? void 0 : E.hide) || 100;\n          setTimeout(() => {\n            var W;\n            (K == null ? void 0 : K.type) === \"click\" || (K == null ? void 0 : K.type) === \"update:modelValue\" && f.value || ee.value && ne.value && !((W = h.value) != null && W.contains(document == null ? void 0 : document.activeElement)) ? (n.value = !1, Oe(() => {\n              setTimeout(() => {\n                s.value = !1;\n              }, h.value ? _a(h.value) : 150), l(\"hidden\", N(\"hidden\"));\n            })) : setTimeout(() => {\n              de(K);\n            }, Le);\n          }, Le);\n        };\n      t({\n        hideFn: de,\n        show: le,\n        toggle: ue\n      });\n      const Se = () => {\n          var K;\n          if (a.target) {\n            const ce = S(F(a.target));\n            ce ? w.value = ce : console.warn(\"Target element not found\", a.target);\n          } else w.value = (K = P.value) == null ? void 0 : K.nextElementSibling;\n          if (a.reference) {\n            const ce = S(F(a.reference));\n            ce ? k.value = ce : console.warn(\"Reference element not found\", a.reference);\n          } else k.value = w.value;\n          !w.value || f.value || qa && (u.value && w.value.addEventListener(\"click\", ue), !u.value && w.value.addEventListener(\"pointerenter\", le), !u.value && w.value.addEventListener(\"pointerleave\", de), !u.value && w.value.addEventListener(\"focus\", le), !u.value && w.value.addEventListener(\"blur\", de));\n        },\n        Ce = () => {\n          w.value && (w.value.removeEventListener(\"click\", ue), w.value.removeEventListener(\"pointerenter\", le), w.value.removeEventListener(\"pointerleave\", de), w.value.removeEventListener(\"focus\", le), w.value.removeEventListener(\"blur\", de));\n        };\n      return Jo(h, () => {\n        n.value && u.value && !g.value && !f.value && de(new Event(\"clickOutside\"));\n      }, {\n        ignore: [w]\n      }), se([() => a.click, () => a.target, () => a.reference], () => {\n        Ce(), Se();\n      }), qe(Se), co(Ce), (K, ce) => (y(), A(fe, null, [Y(\"span\", {\n        ref_key: \"placeholder\",\n        ref: P\n      }, null, 512), O(K.$slots, \"target\", $e(Ee({\n        show: le,\n        hide: de,\n        toggle: ue,\n        showState: n.value\n      }))), _e(Qa, {\n        tag: \"Teleport\",\n        to: K.container,\n        skip: !K.container\n      }, {\n        default: j(() => [s.value ? (y(), A(\"div\", ae({\n          key: 0,\n          id: K.id\n        }, K.$attrs, {\n          ref_key: \"element\",\n          ref: h,\n          class: q.value,\n          role: \"tooltip\",\n          tabindex: \"-1\",\n          style: {\n            position: $(U),\n            top: `${$(X)}px`,\n            left: `${$(G)}px`,\n            width: \"max-content\"\n          }\n        }), [Y(\"div\", {\n          ref_key: \"arrow\",\n          ref: C,\n          class: R(`${$(b) ? \"tooltip\" : \"popover\"}-arrow`),\n          style: De(ye.value),\n          \"data-popper-arrow\": \"\"\n        }, null, 6), K.title || K.$slots.title ? (y(), A(fe, {\n          key: 0\n        }, [$(T) ? (y(), A(\"div\", {\n          key: 1,\n          class: R($(b) ? \"tooltip-inner\" : \"popover-header\"),\n          innerHTML: I.value\n        }, null, 10, ei)) : (y(), A(\"div\", {\n          key: 0,\n          class: R($(b) ? \"tooltip-inner\" : \"popover-header\")\n        }, [O(K.$slots, \"title\", {}, () => [re(Z(K.title), 1)])], 2))], 64)) : J(\"\", !0), $(b) && !K.$slots.title && !K.title || !$(b) ? (y(), A(fe, {\n          key: 1\n        }, [$(T) ? (y(), A(\"div\", {\n          key: 1,\n          class: R($(b) ? \"tooltip-inner\" : \"popover-body\"),\n          innerHTML: x.value\n        }, null, 10, ti)) : (y(), A(\"div\", {\n          key: 0,\n          class: R($(b) ? \"tooltip-inner\" : \"popover-body\")\n        }, [O(K.$slots, \"default\", {}, () => [re(Z(K.content), 1)])], 2))], 64)) : J(\"\", !0)], 16, Qr)) : J(\"\", !0)]),\n        _: 3\n      }, 8, [\"to\", \"skip\"])], 64));\n    }\n  }),\n  ai = ({\n    top: e,\n    end: t,\n    start: l,\n    alignCenter: a,\n    alignEnd: o\n  }) => {\n    const n = e ? \"top\" : l ? \"left\" : t ? \"right\" : \"bottom\",\n      s = o ? \"end\" : a ? null : \"start\";\n    return `${n}${s ? `-${s}` : \"\"}`;\n  },\n  li = e => {\n    const [t] = e.split(\"-\");\n    switch (t) {\n      case \"left\":\n        return \"start\";\n      case \"right\":\n        return \"end\";\n      default:\n        return t;\n    }\n  },\n  Ht = e => typeof e != \"object\" || e.active !== !1,\n  sa = (e, t) => {\n    if (!Ht(e)) return {};\n    const a = typeof e > \"u\" || typeof e == \"object\" && !e.title && !e.content,\n      o = t.getAttribute(\"title\") || t.getAttribute(\"data-original-title\");\n    return a ? o ? (t.removeAttribute(\"title\"), t.setAttribute(\"data-original-title\", o), {\n      content: yt(o, gt)\n    }) : (console.warn(\"Review tooltip directive usage. Some uses are not defining a title in root component or a value like `v-b-tooltip='{title: \\\"my title\\\"}'` nor `v-b-tooltip=\\\"'my title'\\\"` to define a title\"), {}) : typeof e == \"string\" ? {\n      content: yt(e, gt)\n    } : {\n      title: e != null && e.title ? yt(e == null ? void 0 : e.title, gt) : void 0,\n      content: e != null && e.content ? yt(e == null ? void 0 : e.content, gt) : void 0\n    };\n  },\n  ra = (e, t) => ({\n    target: () => t,\n    modelValue: e.modifiers.show,\n    inline: e.modifiers.inline,\n    click: e.modifiers.click,\n    realtime: e.modifiers.realtime,\n    placement: e.modifiers.left ? \"left\" : e.modifiers.right ? \"right\" : e.modifiers.bottom ? \"bottom\" : e.modifiers.top ? \"top\" : void 0,\n    html: !0,\n    ...(typeof e.value == \"object\" ? e.value : {}),\n    title: null,\n    content: null\n  }),\n  rn = (e, t) => {\n    var a;\n    const l = document.createElement(\"span\");\n    t.modifiers.body ? document.body.appendChild(l) : t.modifiers.child ? e.appendChild(l) : (a = e.parentNode) == null || a.insertBefore(l, e.nextSibling), e.$__app = Gn({\n      render: () => {\n        var o;\n        return ie(tl, {\n          ...((o = e.$__state) == null ? void 0 : o.value)\n        });\n      }\n    }), e.$__app.mount(l), e.$__element = l;\n  },\n  un = e => {\n    var l;\n    const t = e.$__element;\n    (l = e.$__app) == null || l.unmount(), delete e.$__app, delete e.$__state, setTimeout(() => {\n      t == null || t.remove();\n    }, 0), delete e.$__element;\n  },\n  zl = (e, t) => {\n    const {\n        all: l,\n        ...a\n      } = e,\n      o = {};\n    l && t.forEach(s => {\n      o[s] = l;\n    });\n    const n = {\n      ...o,\n      ...a\n    };\n    return Object.entries(n).filter(([s, r]) => !!r && t.includes(s)).map(([s]) => s);\n  },\n  oi = [\"id\"],\n  ni = /* @__PURE__ */H({\n    __name: \"BAccordion\",\n    props: {\n      flush: {\n        type: [String, Boolean],\n        default: !1\n      },\n      free: {\n        type: [String, Boolean],\n        default: !1\n      },\n      id: {\n        default: void 0\n      },\n      modelValue: {\n        default: void 0\n      }\n    },\n    emits: [\"update:modelValue\"],\n    setup(e, {\n      emit: t\n    }) {\n      const l = e,\n        a = ke(l, \"modelValue\", t, {\n          passive: !0\n        }),\n        o = Ve(() => l.id, \"accordion\"),\n        n = d(() => l.flush),\n        s = d(() => l.free),\n        r = i(() => ({\n          \"accordion-flush\": n.value\n        }));\n      return Ke(To, {\n        openItem: Be(a),\n        free: s,\n        setOpenItem: u => {\n          a.value = u;\n        }\n      }), (u, f) => (y(), A(\"div\", {\n        id: $(o),\n        class: R([\"accordion\", r.value])\n      }, [O(u.$slots, \"default\")], 10, oi));\n    }\n  }),\n  dn = /* @__PURE__ */H({\n    inheritAttrs: !1,\n    __name: \"BCollapse\",\n    props: {\n      id: {\n        default: void 0\n      },\n      modelValue: {\n        type: [String, Boolean],\n        default: !1\n      },\n      tag: {\n        default: \"div\"\n      },\n      toggle: {\n        type: [String, Boolean],\n        default: !1\n      },\n      horizontal: {\n        type: [String, Boolean],\n        default: !1\n      },\n      visible: {\n        type: [String, Boolean],\n        default: !1\n      },\n      isNav: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    emits: [\"show\", \"shown\", \"hide\", \"hidden\", \"hide-prevented\", \"show-prevented\", \"update:modelValue\"],\n    setup(e, {\n      expose: t,\n      emit: l\n    }) {\n      const a = e,\n        o = (k, C = {}) => new Mt(k, {\n          cancelable: !1,\n          target: c.value || null,\n          relatedTarget: null,\n          trigger: null,\n          ...C,\n          componentId: p.value\n        }),\n        n = ke(a, \"modelValue\", l, {\n          passive: !0\n        }),\n        s = d(n),\n        r = d(() => a.toggle),\n        u = d(() => a.horizontal),\n        f = d(() => a.isNav),\n        v = d(() => a.visible),\n        p = Ve(() => a.id, \"collapse\"),\n        c = M(null),\n        g = M(!1),\n        B = M(s.value),\n        m = i(() => ({\n          show: B.value,\n          \"navbar-collapse\": f.value,\n          collapsing: g.value,\n          closing: B.value && !s.value,\n          \"collapse-horizontal\": u.value\n        })),\n        V = () => {\n          n.value = !1;\n        },\n        b = () => {\n          n.value = !0;\n        },\n        T = () => {\n          n.value = !s.value;\n        },\n        _ = () => {\n          B.value = !0, g.value = !0;\n          const k = o(\"show\", {\n            cancelable: !0\n          });\n          if (l(\"show\", k), k.defaultPrevented) {\n            l(\"show-prevented\");\n            return;\n          }\n          Oe(() => {\n            c.value !== null && (u.value ? c.value.style.width = `${c.value.scrollWidth}px` : c.value.style.height = `${c.value.scrollHeight}px`, setTimeout(() => {\n              g.value = !1, l(\"shown\", o(\"shown\")), c.value !== null && (c.value.style.height = \"\", c.value.style.width = \"\");\n            }, _a(c.value)));\n          });\n        },\n        h = () => {\n          const k = o(\"hide\", {\n            cancelable: !0\n          });\n          if (l(\"hide\", k), k.defaultPrevented) {\n            l(\"hide-prevented\");\n            return;\n          }\n          c.value !== null && (u.value ? c.value.style.width = `${c.value.scrollWidth}px` : c.value.style.height = `${c.value.scrollHeight}px`, c.value.offsetHeight, g.value = !0, Oe(() => {\n            c.value !== null && (c.value.style.height = \"\", c.value.style.width = \"\", setTimeout(() => {\n              B.value = !1, g.value = !1, l(\"hidden\", o(\"hidden\"));\n            }, _a(c.value)));\n          }));\n        };\n      return se([n, B], () => {\n        if (s.value === !0) {\n          if (B.value) return;\n          _();\n          return;\n        }\n        h();\n      }), qe(() => {\n        c.value !== null && !s.value && r.value && Oe(() => {\n          n.value = !0;\n        });\n      }), v.value && (n.value = !0, B.value = !0), se(v, k => {\n        k ? b() : V();\n      }), Te(c, \"bv-toggle\", () => {\n        n.value = !s.value;\n      }), t({\n        close: V,\n        open: b,\n        toggle: T,\n        visible: Be(B),\n        isNav: f\n      }), Ke(Wa, {\n        id: p,\n        close: V,\n        open: b,\n        toggle: T,\n        visible: Be(B),\n        isNav: f\n      }), (k, C) => (y(), A(fe, null, [O(k.$slots, \"header\", $e(Ee({\n        visible: $(s),\n        toggle: T,\n        open: b,\n        close: V,\n        id: $(p)\n      }))), (y(), D(oe(k.tag), ae({\n        id: $(p),\n        ref_key: \"element\",\n        ref: c,\n        class: [\"collapse\", m.value],\n        \"is-nav\": $(f)\n      }, k.$attrs), {\n        default: j(() => [O(k.$slots, \"default\", $e(Ee({\n          visible: $(s),\n          toggle: k.toggle,\n          open: b,\n          close: V\n        })))]),\n        _: 3\n      }, 16, [\"id\", \"class\", \"is-nav\"])), O(k.$slots, \"footer\", $e(Ee({\n        visible: $(s),\n        toggle: T,\n        open: b,\n        close: V,\n        id: $(p)\n      })))], 64));\n    }\n  }),\n  si = {\n    class: \"accordion-item\"\n  },\n  ri = [\"aria-expanded\", \"aria-controls\", \"onClick\"],\n  ii = {\n    class: \"accordion-body\"\n  },\n  ui = /* @__PURE__ */H({\n    inheritAttrs: !1,\n    __name: \"BAccordionItem\",\n    props: {\n      id: {\n        default: void 0\n      },\n      title: {\n        default: void 0\n      },\n      modelValue: {\n        type: [String, Boolean],\n        default: !1\n      },\n      headerTag: {\n        default: \"h2\"\n      },\n      tag: {\n        default: void 0\n      },\n      toggle: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      horizontal: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      visible: {\n        type: [String, Boolean],\n        default: !1\n      },\n      isNav: {\n        type: [String, Boolean],\n        default: void 0\n      }\n    },\n    emits: [\"show\", \"shown\", \"hide\", \"hidden\", \"hide-prevented\", \"show-prevented\", \"update:modelValue\"],\n    setup(e, {\n      emit: t\n    }) {\n      const l = e,\n        a = {\n          show: r => t(\"show\", r),\n          shown: r => t(\"shown\", r),\n          hide: r => t(\"hide\", r),\n          hidden: r => t(\"hidden\", r),\n          \"hide-prevented\": () => t(\"hide-prevented\"),\n          \"show-prevented\": () => t(\"show-prevented\")\n        },\n        o = ke(l, \"modelValue\", t, {\n          passive: !0\n        }),\n        n = Ie(To, null),\n        s = Ve(() => l.id, \"accordion_item\");\n      return qe(() => {\n        o.value && !(n != null && n.free.value) && (n == null || n.setOpenItem(s.value)), !o.value && (n == null ? void 0 : n.openItem.value) === s.value && (o.value = !0);\n      }), se(() => n == null ? void 0 : n.openItem.value, () => o.value = (n == null ? void 0 : n.openItem.value) === s.value && !(n != null && n.free.value)), se(o, () => {\n        o.value && !(n != null && n.free.value) && (n == null || n.setOpenItem(s.value));\n      }), (r, u) => (y(), A(\"div\", si, [_e(dn, ae({\n        id: $(s),\n        modelValue: $(o),\n        \"onUpdate:modelValue\": u[0] || (u[0] = f => uo(o) ? o.value = f : null),\n        class: \"accordion-collapse\"\n      }, r.$attrs, {\n        \"aria-labelledby\": `${$(s)}-heading`,\n        tag: r.tag,\n        toggle: r.toggle,\n        horizontal: r.horizontal,\n        visible: r.visible,\n        \"is-nav\": r.isNav\n      }, Wn(a)), {\n        header: j(({\n          visible: f,\n          toggle: v\n        }) => [(y(), D(oe(r.headerTag), {\n          id: `${$(s)}-heading`,\n          class: \"accordion-header\"\n        }, {\n          default: j(() => [Y(\"button\", {\n            class: R([\"accordion-button\", {\n              collapsed: !f\n            }]),\n            type: \"button\",\n            \"aria-expanded\": f ? \"true\" : \"false\",\n            \"aria-controls\": $(s),\n            onClick: v\n          }, [O(r.$slots, \"title\", {}, () => [re(Z(r.title), 1)])], 10, ri)]),\n          _: 2\n        }, 1032, [\"id\"]))]),\n        default: j(() => [Y(\"div\", ii, [O(r.$slots, \"default\")])]),\n        _: 3\n      }, 16, [\"id\", \"modelValue\", \"aria-labelledby\", \"tag\", \"toggle\", \"horizontal\", \"visible\", \"is-nav\"])]));\n    }\n  }),\n  Vt = /* @__PURE__ */H({\n    __name: \"BTransition\",\n    props: {\n      appear: {\n        type: [String, Boolean],\n        default: !1\n      },\n      mode: {\n        default: void 0\n      },\n      noFade: {\n        type: [String, Boolean],\n        default: !1\n      },\n      transProps: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = d(() => t.appear),\n        a = d(() => t.noFade),\n        o = i(() => {\n          const r = {\n              name: \"\",\n              enterActiveClass: \"\",\n              enterToClass: \"\",\n              leaveActiveClass: \"\",\n              leaveToClass: \"showing\",\n              enterFromClass: \"showing\",\n              leaveFromClass: \"\"\n            },\n            u = {\n              ...r,\n              enterActiveClass: \"fade showing\",\n              leaveActiveClass: \"fade showing\"\n            };\n          return a.value ? r : u;\n        }),\n        n = i(() => ({\n          mode: t.mode,\n          css: !0,\n          ...o.value\n        })),\n        s = i(() => t.transProps !== void 0 ? {\n          // Order matters here since the props.transProps would get overwritten if it came first\n          // But the goal of props.transProps is to overwrite base properties\n          ...n.value,\n          ...t.transProps\n        } : l.value ? {\n          ...n.value,\n          appear: !0,\n          appearActiveClass: o.value.enterActiveClass,\n          appearToClass: o.value.enterToClass\n        } : n.value);\n      return (r, u) => (y(), D(Un, $e(Ee(s.value)), {\n        default: j(() => [O(r.$slots, \"default\")]),\n        _: 3\n      }, 16));\n    }\n  });\nconst di = [\"type\", \"disabled\", \"aria-label\"],\n  Ot = /* @__PURE__ */H({\n    __name: \"BCloseButton\",\n    props: {\n      ariaLabel: {\n        default: \"Close\"\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      white: {\n        type: [String, Boolean],\n        default: !1\n      },\n      type: {\n        default: \"button\"\n      }\n    },\n    emits: [\"click\"],\n    setup(e, {\n      emit: t\n    }) {\n      const l = e,\n        a = d(() => l.disabled),\n        o = d(() => l.white),\n        n = i(() => ({\n          \"btn-close-white\": o.value\n        }));\n      return (s, r) => (y(), A(\"button\", {\n        type: s.type,\n        class: R([\"btn-close\", n.value]),\n        disabled: $(a),\n        \"aria-label\": s.ariaLabel,\n        onClick: r[0] || (r[0] = u => t(\"click\", u))\n      }, null, 10, di));\n    }\n  }),\n  ci = {\n    key: 0,\n    class: \"visually-hidden\"\n  },\n  ma = /* @__PURE__ */H({\n    __name: \"BSpinner\",\n    props: {\n      label: {\n        default: void 0\n      },\n      role: {\n        default: \"status\"\n      },\n      small: {\n        type: [String, Boolean],\n        default: !1\n      },\n      tag: {\n        default: \"span\"\n      },\n      type: {\n        default: \"border\"\n      },\n      variant: {\n        default: null\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = xe(),\n        a = d(() => t.small),\n        o = i(() => ({\n          \"spinner-border\": t.type === \"border\",\n          \"spinner-border-sm\": t.type === \"border\" && a.value,\n          \"spinner-grow\": t.type === \"grow\",\n          \"spinner-grow-sm\": t.type === \"grow\" && a.value,\n          [`text-${t.variant}`]: t.variant !== null\n        })),\n        n = i(() => !Fe(l.label));\n      return (s, r) => (y(), D(oe(s.tag), {\n        class: R(o.value),\n        role: s.label || n.value ? s.role : null,\n        \"aria-hidden\": s.label || n.value ? null : !0\n      }, {\n        default: j(() => [s.label || n.value ? (y(), A(\"span\", ci, [O(s.$slots, \"label\", {}, () => [re(Z(s.label), 1)])])) : J(\"\", !0)]),\n        _: 3\n      }, 8, [\"class\", \"role\", \"aria-hidden\"]));\n    }\n  }),\n  fi = {\n    active: {\n      type: [Boolean, String, void 0],\n      default: void 0\n    },\n    activeClass: {\n      type: String,\n      default: \"router-link-active\"\n    },\n    append: {\n      type: [Boolean, String],\n      default: !1\n    },\n    disabled: {\n      type: [Boolean, String],\n      default: !1\n    },\n    event: {\n      type: [String, Array],\n      default: \"click\"\n    },\n    href: {\n      type: String\n    },\n    // noPrefetch: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    // prefetch: {type: [Boolean, String] as PropType<Booleanish>, default: null},\n    rel: {\n      type: String,\n      default: null\n    },\n    replace: {\n      type: [Boolean, String],\n      default: !1\n    },\n    routerComponentName: {\n      type: String,\n      default: \"router-link\"\n    },\n    routerTag: {\n      type: String,\n      default: \"a\"\n    },\n    target: {\n      type: String,\n      default: \"_self\"\n    },\n    to: {\n      type: [String, Object],\n      default: null\n    },\n    variant: {\n      type: String,\n      default: null\n    }\n  },\n  Qe = /* @__PURE__ */H({\n    __name: \"BLink\",\n    props: {\n      active: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      activeClass: {\n        default: \"router-link-active\"\n      },\n      append: {\n        type: [String, Boolean],\n        default: !1\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      event: {\n        default: \"click\"\n      },\n      href: {\n        default: void 0\n      },\n      rel: {\n        default: void 0\n      },\n      replace: {\n        type: [String, Boolean],\n        default: !1\n      },\n      routerComponentName: {\n        default: \"router-link\"\n      },\n      routerTag: {\n        default: \"a\"\n      },\n      target: {\n        default: \"_self\"\n      },\n      to: {\n        default: void 0\n      },\n      variant: {\n        default: null\n      },\n      opacity: {\n        default: void 0\n      },\n      opacityHover: {\n        default: void 0\n      },\n      underlineVariant: {\n        default: null\n      },\n      underlineOffset: {\n        default: void 0\n      },\n      underlineOffsetHover: {\n        default: void 0\n      },\n      underlineOpacity: {\n        default: void 0\n      },\n      underlineOpacityHover: {\n        default: void 0\n      },\n      icon: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    emits: [\"click\"],\n    setup(e, {\n      emit: t\n    }) {\n      const l = e,\n        a = Ra(),\n        o = d(() => l.active),\n        n = d(() => l.icon);\n      d(() => l.append);\n      const s = d(() => l.disabled);\n      d(() => l.replace);\n      const r = Ie(Wa, null),\n        u = Ie(Ua, null),\n        f = () => {\n          var b;\n          u !== null && ((b = r == null ? void 0 : r.close) == null || b.call(r));\n        },\n        v = ua(),\n        p = i(() => {\n          const b = l.routerComponentName.split(\"-\").map(_ => _.charAt(0).toUpperCase() + _.slice(1)).join(\"\");\n          return !((v == null ? void 0 : v.appContext.app.component(b)) !== void 0) || s.value || !l.to ? \"a\" : l.routerComponentName;\n        }),\n        c = i(() => {\n          const b = \"#\";\n          if (l.href) return l.href;\n          if (typeof l.to == \"string\") return l.to || b;\n          const T = l.to;\n          if (Object.prototype.toString.call(T) === \"[object Object]\" && (T.path || T.query || T.hash)) {\n            const _ = T.path || \"\",\n              h = T.query ? `?${Object.keys(T.query).map(C => `${C}=${T.query[C]}`).join(\"=\")}` : \"\",\n              k = !T.hash || T.hash.charAt(0) === \"#\" ? T.hash || \"\" : `#${T.hash}`;\n            return `${_}${h}${k}` || b;\n          }\n          return b;\n        }),\n        g = i(() => ({\n          [`link-${l.variant}`]: l.variant !== null,\n          [`link-opacity-${l.opacity}`]: l.opacity !== void 0,\n          [`link-opacity-${l.opacityHover}-hover`]: l.opacityHover !== void 0,\n          [`link-underline-${l.underlineVariant}`]: l.underlineVariant !== null,\n          [`link-offset-${l.underlineOffset}`]: l.underlineOffset !== void 0,\n          [`link-offset-${l.underlineOffsetHover}-hover`]: l.underlineOffsetHover !== void 0,\n          [`link-underline-opacity-${l.underlineOpacity}`]: l.underlineOpacity !== void 0,\n          [`link-underline-opacity-${l.underlineOpacityHover}-hover`]: l.underlineOpacityHover !== void 0,\n          \"icon-link\": n.value === !0\n        })),\n        B = i(() => ({\n          class: g.value,\n          to: l.to,\n          href: c.value,\n          target: l.target,\n          rel: l.target === \"_blank\" && l.rel === void 0 ? \"noopener\" : l.rel || void 0,\n          tabindex: s.value ? \"-1\" : typeof a.tabindex > \"u\" ? null : a.tabindex,\n          \"aria-disabled\": s.value ? !0 : null\n        })),\n        m = i(() => ({\n          active: o.value,\n          disabled: s.value\n        })),\n        V = b => {\n          var T;\n          if (s.value) {\n            b.preventDefault(), b.stopImmediatePropagation();\n            return;\n          }\n          (T = r == null ? void 0 : r.close) == null || T.call(r), t(\"click\", b);\n        };\n      return (b, T) => p.value === \"router-link\" ? (y(), D(oe(p.value), ae({\n        key: 0\n      }, B.value, {\n        custom: \"\"\n      }), {\n        default: j(({\n          href: _,\n          navigate: h,\n          isActive: k\n        }) => [(y(), D(oe(b.routerTag), ae({\n          href: _,\n          class: [($(o) ?? k) && b.activeClass]\n        }, b.$attrs, {\n          onClick: C => {\n            h(C), f(), V(C);\n          }\n        }), {\n          default: j(() => [O(b.$slots, \"default\")]),\n          _: 2\n        }, 1040, [\"href\", \"class\", \"onClick\"]))]),\n        _: 3\n      }, 16)) : (y(), D(oe(p.value), ae({\n        key: 1,\n        class: m.value\n      }, B.value, {\n        onClick: V\n      }), {\n        default: j(() => [O(b.$slots, \"default\")]),\n        _: 3\n      }, 16, [\"class\"]));\n    }\n  }),\n  kt = /* @__PURE__ */H({\n    __name: \"BButton\",\n    props: {\n      pill: {\n        type: [String, Boolean],\n        default: !1\n      },\n      pressed: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      size: {\n        default: \"md\"\n      },\n      squared: {\n        type: [String, Boolean],\n        default: !1\n      },\n      tag: {\n        default: \"button\"\n      },\n      type: {\n        default: \"button\"\n      },\n      variant: {\n        default: \"secondary\"\n      },\n      loading: {\n        type: [String, Boolean],\n        default: !1\n      },\n      loadingMode: {\n        default: \"inline\"\n      },\n      block: {\n        type: [String, Boolean],\n        default: !1\n      },\n      active: {\n        type: [String, Boolean],\n        default: !1\n      },\n      activeClass: {\n        default: \"router-link-active\"\n      },\n      append: {\n        type: [String, Boolean],\n        default: !1\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      event: {\n        default: \"click\"\n      },\n      href: {\n        default: void 0\n      },\n      rel: {\n        default: void 0\n      },\n      replace: {\n        type: [String, Boolean],\n        default: !1\n      },\n      routerComponentName: {\n        default: \"router-link\"\n      },\n      routerTag: {\n        default: \"a\"\n      },\n      target: {\n        default: \"_self\"\n      },\n      to: {\n        default: void 0\n      },\n      opacity: {\n        default: void 0\n      },\n      opacityHover: {\n        default: void 0\n      },\n      underlineVariant: {\n        default: null\n      },\n      underlineOffset: {\n        default: void 0\n      },\n      underlineOffsetHover: {\n        default: void 0\n      },\n      underlineOpacity: {\n        default: void 0\n      },\n      underlineOpacityHover: {\n        default: void 0\n      },\n      icon: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    emits: [\"click\", \"update:pressed\"],\n    setup(e, {\n      emit: t\n    }) {\n      const l = e,\n        a = ke(l, \"pressed\", t),\n        o = d(() => l.active),\n        n = d(() => l.block),\n        s = d(() => l.disabled),\n        r = d(() => l.pill),\n        u = d(() => l.pressed),\n        f = d(() => l.squared),\n        v = d(() => l.loading),\n        p = i(() => typeof u.value == \"boolean\"),\n        c = i(() => l.tag === \"button\" && l.href === void 0 && l.to === void 0),\n        g = i(() => St(l)),\n        B = i(() => l.to !== void 0),\n        m = i(() => l.href !== void 0 ? !1 : !c.value),\n        V = i(() => [[`btn-${l.size}`], {\n          [`btn-${l.variant}`]: l.variant !== null,\n          \"btn-block\": n.value,\n          active: o.value || u.value,\n          \"rounded-pill\": r.value,\n          \"rounded-0\": f.value,\n          disabled: s.value\n        }]),\n        b = i(() => ({\n          \"aria-disabled\": m.value ? s.value : null,\n          \"aria-pressed\": p.value ? u.value : null,\n          autocomplete: p.value ? \"off\" : null,\n          disabled: c.value ? s.value : null,\n          href: l.href,\n          rel: g.value ? l.rel : null,\n          role: m.value || g.value ? \"button\" : null,\n          target: g.value ? l.target : null,\n          type: c.value ? l.type : null,\n          to: c.value ? null : l.to,\n          append: g.value ? l.append : null,\n          activeClass: B.value ? l.activeClass : null,\n          event: B.value ? l.event : null,\n          replace: B.value ? l.replace : null,\n          routerComponentName: B.value ? l.routerComponentName : null,\n          routerTag: B.value ? l.routerTag : null\n        })),\n        T = i(() => B.value ? Qe : l.href ? \"a\" : l.tag),\n        _ = h => {\n          if (s.value) {\n            h.preventDefault(), h.stopPropagation();\n            return;\n          }\n          t(\"click\", h), p.value && (a.value = !u.value);\n        };\n      return (h, k) => (y(), D(oe(T.value), ae({\n        class: [\"btn\", V.value]\n      }, b.value, {\n        onClick: _\n      }), {\n        default: j(() => [$(v) ? (y(), A(\"div\", {\n          key: 0,\n          class: R([\"btn-loading\", {\n            \"mode-fill\": h.loadingMode === \"fill\",\n            \"mode-inline\": h.loadingMode === \"inline\"\n          }])\n        }, [O(h.$slots, \"loading\", {}, () => [_e(ma, {\n          class: \"btn-spinner\",\n          small: h.size !== \"lg\"\n        }, null, 8, [\"small\"])])], 2)) : J(\"\", !0), Y(\"div\", {\n          class: R([\"btn-content\", {\n            \"btn-loading-fill\": $(v) && h.loadingMode === \"fill\"\n          }])\n        }, [O(h.$slots, \"default\")], 2)]),\n        _: 3\n      }, 16, [\"class\"]));\n    }\n  }),\n  vi = [\"onMouseenter\"],\n  pi = /* @__PURE__ */H({\n    __name: \"BAlert\",\n    props: {\n      noHoverPause: {\n        type: [String, Boolean],\n        default: !1\n      },\n      dismissLabel: {\n        default: \"Close\"\n      },\n      dismissible: {\n        type: [String, Boolean],\n        default: !1\n      },\n      fade: {\n        type: [String, Boolean],\n        default: !1\n      },\n      closeVariant: {\n        default: \"secondary\"\n      },\n      modelValue: {\n        type: [Boolean, Number],\n        default: !1\n      },\n      variant: {\n        default: \"info\"\n      },\n      closeContent: {\n        default: void 0\n      },\n      immediate: {\n        type: [String, Boolean],\n        default: !0\n      },\n      interval: {\n        default: 1e3\n      },\n      showOnPause: {\n        type: [String, Boolean],\n        default: !0\n      }\n    },\n    emits: [\"closed\", \"close-countdown\", \"update:modelValue\"],\n    setup(e, {\n      expose: t,\n      emit: l\n    }) {\n      const a = e,\n        o = xe(),\n        n = ke(a, \"modelValue\", l),\n        s = d(() => a.dismissible),\n        r = d(() => a.fade),\n        u = d(() => a.immediate),\n        f = d(() => a.showOnPause),\n        v = d(() => a.noHoverPause),\n        p = i(() => !Fe(o.close)),\n        c = i(() => typeof n.value == \"boolean\" ? 0 : n.value),\n        g = i(() => ({\n          [`alert-${a.variant}`]: a.variant !== null,\n          \"alert-dismissible\": s.value\n        })),\n        {\n          isActive: B,\n          pause: m,\n          restart: V,\n          resume: b,\n          stop: T,\n          isPaused: _,\n          value: h\n        } = Yr(c, () => a.interval, {\n          immediate: typeof n.value == \"number\" && u.value\n        }),\n        k = i(() => typeof n.value == \"boolean\" ? n.value : B.value || f.value && _.value),\n        C = i(() => ({\n          variant: a.closeVariant,\n          type: \"button\"\n        }));\n      Rt(() => l(\"close-countdown\", h.value));\n      const w = () => {\n          typeof n.value == \"boolean\" ? n.value = !1 : (n.value = 0, T()), l(\"closed\");\n        },\n        P = () => {\n          v.value || m();\n        };\n      return co(T), t({\n        pause: m,\n        resume: b,\n        restart: V,\n        stop: T\n      }), (F, S) => (y(), D(Vt, {\n        \"no-fade\": !$(r),\n        \"trans-props\": {\n          enterToClass: \"show\"\n        }\n      }, {\n        default: j(() => [k.value ? (y(), A(\"div\", {\n          key: 0,\n          class: R([\"alert\", g.value]),\n          role: \"alert\",\n          \"aria-live\": \"polite\",\n          \"aria-atomic\": \"true\",\n          onMouseenter: ut(P, [\"stop\"]),\n          onMouseleave: S[0] || (S[0] = ut(\n          //@ts-ignore\n          (...I) => $(b) && $(b)(...I), [\"stop\"]))\n        }, [O(F.$slots, \"default\"), $(s) ? (y(), A(fe, {\n          key: 0\n        }, [p.value || F.closeContent ? (y(), D(kt, ae({\n          key: 0\n        }, C.value, {\n          onClick: w\n        }), {\n          default: j(() => [O(F.$slots, \"close\", {}, () => [re(Z(F.closeContent), 1)])]),\n          _: 3\n        }, 16)) : (y(), D(Ot, ae({\n          key: 1,\n          \"aria-label\": F.dismissLabel\n        }, C.value, {\n          onClick: w\n        }), null, 16, [\"aria-label\"]))], 64)) : J(\"\", !0)], 42, vi)) : J(\"\", !0)]),\n        _: 3\n      }, 8, [\"no-fade\"]));\n    }\n  }),\n  mi = {\n    key: 0,\n    class: \"b-avatar-custom\"\n  },\n  gi = {\n    key: 1,\n    class: \"b-avatar-img\"\n  },\n  yi = [\"src\", \"alt\"],\n  Oa = e => {\n    const t = typeof e == \"string\" && po(e) ? Et(e, 0) : e;\n    return typeof t == \"number\" ? `${t}px` : t || null;\n  },\n  bi = /* @__PURE__ */H({\n    __name: \"BAvatar\",\n    props: {\n      alt: {\n        default: \"avatar\"\n      },\n      ariaLabel: {\n        default: void 0\n      },\n      badge: {\n        type: [Boolean, String],\n        default: !1\n      },\n      badgeLeft: {\n        type: [String, Boolean],\n        default: !1\n      },\n      badgeOffset: {\n        default: void 0\n      },\n      badgeTop: {\n        type: [String, Boolean],\n        default: !1\n      },\n      badgeVariant: {\n        default: \"primary\"\n      },\n      button: {\n        type: [String, Boolean],\n        default: !1\n      },\n      buttonType: {\n        default: \"button\"\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      icon: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      rounded: {\n        type: [Boolean, String],\n        default: \"circle\"\n      },\n      size: {\n        default: void 0\n      },\n      square: {\n        type: [String, Boolean],\n        default: !1\n      },\n      src: {\n        default: void 0\n      },\n      text: {\n        default: void 0\n      },\n      textVariant: {\n        default: null\n      },\n      variant: {\n        default: \"secondary\"\n      },\n      active: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      activeClass: {\n        default: \"router-link-active\"\n      },\n      append: {\n        type: [String, Boolean],\n        default: !1\n      },\n      href: {\n        default: void 0\n      },\n      rel: {\n        default: void 0\n      },\n      replace: {\n        type: [String, Boolean],\n        default: !1\n      },\n      routerComponentName: {\n        default: \"router-link\"\n      },\n      target: {\n        default: \"_self\"\n      },\n      to: {\n        default: void 0\n      },\n      opacity: {\n        default: void 0\n      },\n      opacityHover: {\n        default: void 0\n      },\n      underlineVariant: {\n        default: null\n      },\n      underlineOffset: {\n        default: void 0\n      },\n      underlineOffsetHover: {\n        default: void 0\n      },\n      underlineOpacity: {\n        default: void 0\n      },\n      underlineOpacityHover: {\n        default: void 0\n      }\n    },\n    emits: [\"click\", \"img-error\"],\n    setup(e, {\n      emit: t\n    }) {\n      const l = e,\n        a = xe(),\n        o = Ie(Co, null),\n        n = [\"sm\", null, \"lg\"],\n        s = 0.4,\n        r = s * 0.7,\n        u = d(() => l.badgeLeft),\n        f = d(() => l.badgeTop),\n        v = d(() => l.button),\n        p = d(() => l.disabled),\n        c = d(() => l.square),\n        g = i(() => !Fe(a.default)),\n        B = i(() => !Fe(a.badge)),\n        m = i(() => !!l.badge || l.badge === \"\" || B.value),\n        V = i(() => St(l)),\n        b = i(() => (o == null ? void 0 : o.size.value) ?? Oa(l.size)),\n        T = i(() => (o == null ? void 0 : o.variant.value) ?? l.variant),\n        _ = i(() => (o == null ? void 0 : o.rounded.value) ?? l.rounded),\n        h = i(() => ({\n          type: v.value && !V.value ? l.buttonType : void 0,\n          \"aria-label\": l.ariaLabel || null,\n          disabled: p.value || null,\n          // Link props\n          ...(V.value ? Dt(l, {\n            active: !0,\n            activeClass: !0,\n            append: !0,\n            href: !0,\n            rel: !0,\n            replace: !0,\n            routerComponentName: !0,\n            target: !0,\n            to: !0,\n            variant: !0,\n            opacity: !0,\n            opacityHover: !0,\n            underlineVariant: !0,\n            underlineOffset: !0,\n            underlineOffsetHover: !0,\n            underlineOpacity: !0,\n            underlineOpacityHover: !0\n          }) : {})\n        })),\n        k = i(() => ({\n          [`bg-${l.badgeVariant}`]: l.badgeVariant !== null\n        })),\n        C = i(() => l.badge === !0 ? \"\" : l.badge),\n        w = i(() => ({\n          [`text-${l.badgeVariant !== null && Q(l.badgeVariant)}`]: l.badgeVariant !== null\n        })),\n        P = i(() => ({\n          [`b-avatar-${l.size}`]: !!l.size && n.indexOf(Oa(l.size)) !== -1,\n          [`bg-${T.value}`]: T.value !== null,\n          badge: !v.value && T.value !== null && g.value,\n          rounded: _.value === \"\" || _.value === !0,\n          [\"rounded-circle\"]: !c.value && _.value === \"circle\",\n          [\"rounded-0\"]: c.value || _.value === \"0\",\n          [\"rounded-1\"]: !c.value && _.value === \"sm\",\n          [\"rounded-3\"]: !c.value && _.value === \"lg\",\n          [\"rounded-top\"]: !c.value && _.value === \"top\",\n          [\"rounded-bottom\"]: !c.value && _.value === \"bottom\",\n          [\"rounded-start\"]: !c.value && _.value === \"left\",\n          [\"rounded-end\"]: !c.value && _.value === \"right\",\n          btn: v.value,\n          [`btn-${T.value}`]: v.value ? T.value !== null : !1\n        })),\n        F = i(() => ({\n          [`text-${l.textVariant || T.value !== null && Q(T.value)}`]: l.textVariant || T.value !== null\n        })),\n        S = i(() => {\n          const U = l.badgeOffset || \"0px\";\n          return {\n            fontSize: (n.indexOf(b.value || null) === -1 ? `calc(${b.value} * ${r})` : \"\") || \"\",\n            top: f.value ? U : \"\",\n            bottom: f.value ? \"\" : U,\n            left: u.value ? U : \"\",\n            right: u.value ? \"\" : U\n          };\n        }),\n        I = i(() => {\n          const U = n.indexOf(b.value || null) === -1 ? `calc(${b.value} * ${s})` : null;\n          return U ? {\n            fontSize: U\n          } : {};\n        }),\n        x = i(() => {\n          var be;\n          const U = ((be = o == null ? void 0 : o.overlapScale) == null ? void 0 : be.value) || 0,\n            pe = b.value && U ? `calc(${b.value} * -${U})` : null;\n          return pe ? {\n            marginLeft: pe,\n            marginRight: pe\n          } : {};\n        }),\n        z = i(() => V.value ? Qe : v.value ? \"button\" : \"span\"),\n        te = i(() => ({\n          ...x.value,\n          width: b.value ?? void 0,\n          height: b.value ?? void 0\n        })),\n        Q = U => U === \"light\" || U === \"warning\" ? \"dark\" : \"light\",\n        G = U => {\n          !p.value && (V.value || v.value) && t(\"click\", U);\n        },\n        X = U => t(\"img-error\", U);\n      return (U, pe) => (y(), D(oe(z.value), ae({\n        class: [\"b-avatar\", P.value],\n        style: te.value\n      }, h.value, {\n        onClick: G\n      }), {\n        default: j(() => [g.value ? (y(), A(\"span\", mi, [O(U.$slots, \"default\")])) : U.src ? (y(), A(\"span\", gi, [Y(\"img\", {\n          src: U.src,\n          alt: U.alt,\n          onError: X\n        }, null, 40, yi)])) : U.text ? (y(), A(\"span\", {\n          key: 2,\n          class: R([\"b-avatar-text\", F.value]),\n          style: De(I.value)\n        }, Z(U.text), 7)) : J(\"\", !0), m.value ? (y(), A(\"span\", {\n          key: 3,\n          class: R([\"b-avatar-badge\", k.value]),\n          style: De(S.value)\n        }, [B.value ? O(U.$slots, \"badge\", {\n          key: 0\n        }) : (y(), A(\"span\", {\n          key: 1,\n          class: R(w.value)\n        }, Z(C.value), 3))], 6)) : J(\"\", !0)]),\n        _: 3\n      }, 16, [\"class\", \"style\"]));\n    }\n  }),\n  hi = /* @__PURE__ */H({\n    __name: \"BAvatarGroup\",\n    props: {\n      overlap: {\n        default: 0.3\n      },\n      rounded: {\n        type: [Boolean, String],\n        default: !1\n      },\n      size: {\n        default: void 0\n      },\n      square: {\n        type: [String, Boolean],\n        default: !1\n      },\n      tag: {\n        default: \"div\"\n      },\n      variant: {\n        default: null\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = d(() => t.square),\n        a = i(() => Oa(t.size)),\n        o = i(() => Math.min(Math.max(s(t.overlap), 0), 1) / 2),\n        n = i(() => {\n          const r = a.value ? `calc(${a.value} * ${o.value})` : null;\n          return r ? {\n            paddingLeft: r,\n            paddingRight: r\n          } : {};\n        }),\n        s = r => typeof r == \"string\" && po(r) ? Et(r, 0) : r || 0;\n      return Ke(Co, {\n        overlapScale: o,\n        size: Be(Ae(t, \"size\")),\n        square: l,\n        rounded: Be(Ae(t, \"rounded\")),\n        variant: Be(Ae(t, \"variant\"))\n      }), (r, u) => (y(), D(oe(r.tag), {\n        class: \"b-avatar-group\",\n        role: \"group\"\n      }, {\n        default: j(() => [Y(\"div\", {\n          class: \"b-avatar-group-inner\",\n          style: De(n.value)\n        }, [O(r.$slots, \"default\")], 4)]),\n        _: 3\n      }));\n    }\n  }),\n  Bi = /* @__PURE__ */H({\n    __name: \"BBadge\",\n    props: {\n      pill: {\n        type: [String, Boolean],\n        default: !1\n      },\n      tag: {\n        default: \"span\"\n      },\n      textIndicator: {\n        type: [String, Boolean],\n        default: !1\n      },\n      dotIndicator: {\n        type: [String, Boolean],\n        default: !1\n      },\n      active: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      activeClass: {\n        default: \"router-link-active\"\n      },\n      append: {\n        type: [String, Boolean],\n        default: !1\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      href: {\n        default: void 0\n      },\n      rel: {\n        default: void 0\n      },\n      replace: {\n        type: [String, Boolean],\n        default: !1\n      },\n      routerComponentName: {\n        default: \"router-link\"\n      },\n      target: {\n        default: \"_self\"\n      },\n      to: {\n        default: void 0\n      },\n      variant: {\n        default: \"secondary\"\n      },\n      opacity: {\n        default: void 0\n      },\n      opacityHover: {\n        default: void 0\n      },\n      underlineVariant: {\n        default: null\n      },\n      underlineOffset: {\n        default: void 0\n      },\n      underlineOffsetHover: {\n        default: void 0\n      },\n      underlineOpacity: {\n        default: void 0\n      },\n      underlineOpacityHover: {\n        default: void 0\n      },\n      icon: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = d(() => t.pill),\n        a = d(() => t.textIndicator),\n        o = d(() => t.dotIndicator),\n        n = d(() => t.active),\n        s = d(() => t.disabled),\n        r = i(() => St(t)),\n        u = i(() => r.value ? Qe : t.tag),\n        f = i(() => ({\n          [`bg-${t.variant}`]: t.variant !== null,\n          active: n.value,\n          disabled: s.value,\n          \"text-dark\": t.variant !== null && [\"warning\", \"info\", \"light\"].includes(t.variant),\n          \"rounded-pill\": l.value,\n          \"position-absolute top-0 start-100 translate-middle\": a.value || o.value,\n          \"p-2 border border-light rounded-circle\": o.value,\n          \"text-decoration-none\": r.value\n        })),\n        v = i(() => r.value ? Dt(t, {\n          active: !0,\n          activeClass: !0,\n          append: !0,\n          disabled: !0,\n          href: !0,\n          rel: !0,\n          replace: !0,\n          routerComponentName: !0,\n          target: !0,\n          to: !0,\n          variant: !0,\n          opacity: !0,\n          opacityHover: !0,\n          underlineVariant: !0,\n          underlineOffset: !0,\n          underlineOffsetHover: !0,\n          underlineOpacity: !0,\n          underlineOpacityHover: !0,\n          icon: !0\n        }) : {});\n      return (p, c) => (y(), D(oe(u.value), ae({\n        class: [\"badge\", f.value]\n      }, v.value), {\n        default: j(() => [O(p.$slots, \"default\")]),\n        _: 3\n      }, 16, [\"class\"]));\n    }\n  }),\n  cn = /* @__PURE__ */H({\n    __name: \"BBreadcrumbItem\",\n    props: {\n      ariaCurrent: {\n        default: \"location\"\n      },\n      text: {\n        default: void 0\n      },\n      active: {\n        type: [String, Boolean],\n        default: !1\n      },\n      activeClass: {\n        default: \"router-link-active\"\n      },\n      append: {\n        type: [String, Boolean],\n        default: !1\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      href: {\n        default: void 0\n      },\n      rel: {\n        default: void 0\n      },\n      replace: {\n        type: [String, Boolean],\n        default: !1\n      },\n      routerComponentName: {\n        default: \"router-link\"\n      },\n      target: {\n        default: \"_self\"\n      },\n      to: {\n        default: void 0\n      },\n      variant: {\n        default: void 0\n      },\n      opacity: {\n        default: void 0\n      },\n      opacityHover: {\n        default: void 0\n      },\n      underlineVariant: {\n        default: null\n      },\n      underlineOffset: {\n        default: void 0\n      },\n      underlineOffsetHover: {\n        default: void 0\n      },\n      underlineOpacity: {\n        default: void 0\n      },\n      underlineOpacityHover: {\n        default: void 0\n      },\n      icon: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    emits: [\"click\"],\n    setup(e, {\n      emit: t\n    }) {\n      const l = e,\n        a = d(() => l.active),\n        o = d(() => l.disabled),\n        n = i(() => ({\n          active: a.value\n        })),\n        s = i(() => a.value ? \"span\" : Qe),\n        r = i(() => a.value ? l.ariaCurrent : void 0),\n        u = i(() => s.value !== \"span\" ? Dt(l, {\n          active: !0,\n          activeClass: !0,\n          append: !0,\n          disabled: !0,\n          href: !0,\n          rel: !0,\n          replace: !0,\n          routerComponentName: !0,\n          target: !0,\n          to: !0,\n          variant: !0,\n          opacity: !0,\n          opacityHover: !0,\n          underlineVariant: !0,\n          underlineOffset: !0,\n          underlineOffsetHover: !0,\n          underlineOpacity: !0,\n          underlineOpacityHover: !0,\n          icon: !0\n        }) : {}),\n        f = v => {\n          if (o.value || a.value) {\n            v.preventDefault(), v.stopImmediatePropagation();\n            return;\n          }\n          o.value || t(\"click\", v);\n        };\n      return (v, p) => (y(), A(\"li\", {\n        class: R([\"breadcrumb-item\", n.value])\n      }, [(y(), D(oe(s.value), ae({\n        \"aria-current\": r.value\n      }, u.value, {\n        onClick: f\n      }), {\n        default: j(() => [O(v.$slots, \"default\", {}, () => [re(Z(v.text), 1)])]),\n        _: 3\n      }, 16, [\"aria-current\"]))], 2));\n    }\n  }),\n  Si = {\n    \"aria-label\": \"breadcrumb\"\n  },\n  _i = {\n    class: \"breadcrumb\"\n  },\n  wi = /* @__PURE__ */H({\n    __name: \"BBreadcrumb\",\n    props: {\n      items: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = Qo(),\n        a = i(() => {\n          const o = t.items || (l == null ? void 0 : l.items) || [];\n          let n = !1;\n          return o.map((r, u) => (typeof r == \"string\" && (r = {\n            text: r\n          }, u < o.length - 1 && (r.href = \"#\")), r.active && (n = !0), !r.active && !n && (r.active = u + 1 === o.length), r));\n        });\n      return (o, n) => (y(), A(\"nav\", Si, [Y(\"ol\", _i, [O(o.$slots, \"prepend\"), (y(!0), A(fe, null, we(a.value, (s, r) => (y(), D(cn, ae({\n        key: r\n      }, s), {\n        default: j(() => [re(Z(s.text), 1)]),\n        _: 2\n      }, 1040))), 128)), O(o.$slots, \"default\"), O(o.$slots, \"append\")])]));\n    }\n  }),\n  $i = /* @__PURE__ */H({\n    __name: \"BButtonGroup\",\n    props: {\n      ariaLabel: {\n        default: \"Group\"\n      },\n      size: {\n        default: \"md\"\n      },\n      tag: {\n        default: \"div\"\n      },\n      vertical: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = d(() => t.vertical),\n        a = i(() => ({\n          \"btn-group\": !l.value,\n          [`btn-group-${t.size}`]: t.size !== \"md\",\n          \"btn-group-vertical\": l.value\n        }));\n      return (o, n) => (y(), D(oe(o.tag), {\n        class: R(a.value),\n        role: \"group\",\n        \"aria-label\": o.ariaLabel\n      }, {\n        default: j(() => [O(o.$slots, \"default\")]),\n        _: 3\n      }, 8, [\"class\", \"aria-label\"]));\n    }\n  }),\n  ki = [\"role\", \"aria-label\"],\n  Ci = /* @__PURE__ */H({\n    __name: \"BButtonToolbar\",\n    props: {\n      ariaLabel: {\n        default: \"Group\"\n      },\n      justify: {\n        type: [String, Boolean],\n        default: !1\n      },\n      role: {\n        default: \"toolbar\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = d(() => t.justify),\n        a = i(() => ({\n          \"justify-content-between\": l.value\n        }));\n      return (o, n) => (y(), A(\"div\", {\n        class: R([a.value, \"btn-toolbar\"]),\n        role: o.role,\n        \"aria-label\": o.ariaLabel\n      }, [O(o.$slots, \"default\")], 10, ki));\n    }\n  }),\n  Ti = '<svg width=\"%{w}\" height=\"%{h}\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 %{w} %{h}\" preserveAspectRatio=\"none\"><rect width=\"100%\" height=\"100%\" style=\"fill:%{f};\"></rect></svg>',\n  al = /* @__PURE__ */H({\n    __name: \"BImg\",\n    props: {\n      alt: {\n        default: void 0\n      },\n      blank: {\n        type: [String, Boolean],\n        default: !1\n      },\n      blankColor: {\n        default: \"transparent\"\n      },\n      block: {\n        type: [String, Boolean],\n        default: !1\n      },\n      center: {\n        type: [String, Boolean],\n        default: !1\n      },\n      fluid: {\n        type: [String, Boolean],\n        default: !1\n      },\n      lazy: {\n        type: [String, Boolean],\n        default: !1\n      },\n      fluidGrow: {\n        type: [String, Boolean],\n        default: !1\n      },\n      height: {\n        default: void 0\n      },\n      start: {\n        type: [String, Boolean],\n        default: !1\n      },\n      end: {\n        type: [String, Boolean],\n        default: !1\n      },\n      rounded: {\n        type: [Boolean, String],\n        default: !1\n      },\n      sizes: {\n        default: void 0\n      },\n      src: {\n        default: void 0\n      },\n      srcset: {\n        default: void 0\n      },\n      thumbnail: {\n        type: [String, Boolean],\n        default: !1\n      },\n      width: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = d(() => t.lazy),\n        a = d(() => t.blank),\n        o = d(() => t.block),\n        n = d(() => t.center),\n        s = d(() => t.fluid),\n        r = d(() => t.fluidGrow),\n        u = d(() => t.start),\n        f = d(() => t.end),\n        v = d(() => t.thumbnail),\n        p = i(() => typeof t.srcset == \"string\" ? t.srcset.split(\",\").filter(_ => _).join(\",\") : Array.isArray(t.srcset) ? t.srcset.filter(_ => _).join(\",\") : void 0),\n        c = i(() => typeof t.sizes == \"string\" ? t.sizes.split(\",\").filter(_ => _).join(\",\") : Array.isArray(t.sizes) ? t.sizes.filter(_ => _).join(\",\") : void 0),\n        g = i(() => {\n          const _ = C => C === void 0 ? void 0 : typeof C == \"number\" ? C : Number.parseInt(C, 10) || void 0,\n            h = _(t.width),\n            k = _(t.height);\n          if (a.value) {\n            if (h !== void 0 && k === void 0) return {\n              height: h,\n              width: h\n            };\n            if (h === void 0 && k !== void 0) return {\n              height: k,\n              width: k\n            };\n            if (h === void 0 && k === void 0) return {\n              height: 1,\n              width: 1\n            };\n          }\n          return {\n            width: h,\n            height: k\n          };\n        }),\n        B = i(() => T(g.value.width, g.value.height, t.blankColor)),\n        m = i(() => ({\n          src: a.value ? B.value : t.src,\n          alt: t.alt,\n          width: g.value.width || void 0,\n          height: g.value.height || void 0,\n          srcset: a.value ? void 0 : p.value,\n          sizes: a.value ? void 0 : c.value,\n          loading: l.value ? \"lazy\" : \"eager\"\n        })),\n        V = i(() => u.value ? \"float-start\" : f.value ? \"float-end\" : n.value ? \"mx-auto\" : void 0),\n        b = i(() => ({\n          \"img-thumbnail\": v.value,\n          \"img-fluid\": s.value || r.value,\n          \"w-100\": r.value,\n          rounded: t.rounded === \"\" || t.rounded === !0,\n          [`rounded-${t.rounded}`]: typeof t.rounded == \"string\" && t.rounded !== \"\",\n          [`${V.value}`]: V.value !== void 0,\n          \"d-block\": o.value || n.value\n        })),\n        T = (_, h, k) => `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(Ti.replace(\"%{w}\", String(_)).replace(\"%{h}\", String(h)).replace(\"%{f}\", k))}`;\n      return (_, h) => (y(), A(\"img\", ae({\n        class: b.value\n      }, m.value), null, 16));\n    }\n  }),\n  ia = /* @__PURE__ */H({\n    __name: \"BCardImg\",\n    props: {\n      alt: {\n        default: void 0\n      },\n      blank: {\n        type: [String, Boolean],\n        default: !1\n      },\n      blankColor: {\n        default: void 0\n      },\n      bottom: {\n        type: [String, Boolean],\n        default: !1\n      },\n      lazy: {\n        type: [String, Boolean],\n        default: !1\n      },\n      height: {\n        default: void 0\n      },\n      start: {\n        type: [String, Boolean],\n        default: !1\n      },\n      end: {\n        type: [String, Boolean],\n        default: !1\n      },\n      sizes: {\n        default: void 0\n      },\n      src: {\n        default: void 0\n      },\n      srcset: {\n        default: void 0\n      },\n      top: {\n        type: [String, Boolean],\n        default: !1\n      },\n      width: {\n        default: void 0\n      }\n    },\n    emits: [\"load\"],\n    setup(e, {\n      emit: t\n    }) {\n      const l = e,\n        a = d(() => l.bottom),\n        o = d(() => l.end),\n        n = d(() => l.start),\n        s = d(() => l.top),\n        r = i(() => s.value ? \"card-img-top\" : o.value ? \"card-img-right\" : a.value ? \"card-img-bottom\" : n.value ? \"card-img-left\" : \"card-img\"),\n        u = i(() => ({\n          alt: l.alt,\n          height: l.height,\n          src: l.src,\n          lazy: l.lazy,\n          width: l.width,\n          blank: l.blank,\n          blankColor: l.blankColor,\n          sizes: l.sizes,\n          srcset: l.srcset\n        }));\n      return (f, v) => (y(), D(al, ae({\n        class: r.value\n      }, u.value, {\n        onLoad: v[0] || (v[0] = p => t(\"load\", p))\n      }), null, 16, [\"class\"]));\n    }\n  }),\n  Vi = [\"innerHTML\"],\n  fn = /* @__PURE__ */H({\n    __name: \"BCardHeadFoot\",\n    props: {\n      text: {\n        default: void 0\n      },\n      bgVariant: {\n        default: null\n      },\n      borderVariant: {\n        default: null\n      },\n      html: {\n        default: void 0\n      },\n      tag: {\n        default: \"div\"\n      },\n      textVariant: {\n        default: null\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = i(() => ({\n          [`text-${t.textVariant}`]: t.textVariant !== null,\n          [`bg-${t.bgVariant}`]: t.bgVariant !== null,\n          [`border-${t.borderVariant}`]: t.borderVariant !== null\n        }));\n      return (a, o) => (y(), D(oe(a.tag), {\n        class: R(l.value)\n      }, {\n        default: j(() => [a.html ? (y(), A(\"div\", {\n          key: 0,\n          innerHTML: a.html\n        }, null, 8, Vi)) : O(a.$slots, \"default\", {\n          key: 1\n        }, () => [re(Z(a.text), 1)])]),\n        _: 3\n      }, 8, [\"class\"]));\n    }\n  }),\n  vn = /* @__PURE__ */H({\n    __name: \"BCardHeader\",\n    props: {\n      text: {\n        default: void 0\n      },\n      bgVariant: {\n        default: void 0\n      },\n      borderVariant: {\n        default: void 0\n      },\n      html: {\n        default: void 0\n      },\n      tag: {\n        default: \"div\"\n      },\n      textVariant: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = e;\n      return (l, a) => (y(), D(fn, ae({\n        class: \"card-header\"\n      }, t), {\n        default: j(() => [O(l.$slots, \"default\")]),\n        _: 3\n      }, 16));\n    }\n  }),\n  pn = /* @__PURE__ */H({\n    __name: \"BCardTitle\",\n    props: {\n      text: {\n        default: void 0\n      },\n      tag: {\n        default: \"h4\"\n      }\n    },\n    setup(e) {\n      return (t, l) => (y(), D(oe(t.tag), {\n        class: \"card-title\"\n      }, {\n        default: j(() => [O(t.$slots, \"default\", {}, () => [re(Z(t.text), 1)])]),\n        _: 3\n      }));\n    }\n  }),\n  mn = /* @__PURE__ */H({\n    __name: \"BCardSubtitle\",\n    props: {\n      text: {\n        default: void 0\n      },\n      tag: {\n        default: \"h6\"\n      },\n      textVariant: {\n        default: \"muted\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = i(() => ({\n          [`text-${t.textVariant}`]: t.textVariant !== null\n        }));\n      return (a, o) => (y(), D(oe(a.tag), {\n        class: R([\"card-subtitle mb-2\", l.value])\n      }, {\n        default: j(() => [O(a.$slots, \"default\", {}, () => [re(Z(a.text), 1)])]),\n        _: 3\n      }, 8, [\"class\"]));\n    }\n  }),\n  gn = /* @__PURE__ */H({\n    __name: \"BCardBody\",\n    props: {\n      bodyBgVariant: {\n        default: null\n      },\n      bodyTag: {\n        default: \"div\"\n      },\n      bodyTextVariant: {\n        default: null\n      },\n      overlay: {\n        type: [String, Boolean],\n        default: !1\n      },\n      subtitle: {\n        default: void 0\n      },\n      subtitleTag: {\n        default: \"h4\"\n      },\n      subtitleTextVariant: {\n        default: void 0\n      },\n      title: {\n        default: void 0\n      },\n      titleTag: {\n        default: \"h4\"\n      },\n      text: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = xe(),\n        a = d(() => t.overlay),\n        o = i(() => !Fe(l.title)),\n        n = i(() => !Fe(l.subtitle)),\n        s = i(() => ({\n          \"card-img-overlay\": a.value,\n          [`text-${t.bodyTextVariant}`]: t.bodyTextVariant !== null,\n          [`bg-${t.bodyBgVariant}`]: t.bodyBgVariant !== null\n        }));\n      return (r, u) => (y(), D(oe(r.bodyTag), {\n        class: R([\"card-body\", s.value])\n      }, {\n        default: j(() => [r.title || o.value ? (y(), D(pn, {\n          key: 0,\n          tag: r.titleTag\n        }, {\n          default: j(() => [O(r.$slots, \"title\", {}, () => [re(Z(r.title), 1)])]),\n          _: 3\n        }, 8, [\"tag\"])) : J(\"\", !0), r.subtitle || n.value ? (y(), D(mn, {\n          key: 1,\n          tag: r.subtitleTag,\n          \"text-variant\": r.subtitleTextVariant\n        }, {\n          default: j(() => [O(r.$slots, \"subtitle\", {}, () => [re(Z(r.subtitle), 1)])]),\n          _: 3\n        }, 8, [\"tag\", \"text-variant\"])) : J(\"\", !0), O(r.$slots, \"default\", {}, () => [re(Z(r.text), 1)])]),\n        _: 3\n      }, 8, [\"class\"]));\n    }\n  }),\n  yn = /* @__PURE__ */H({\n    __name: \"BCardFooter\",\n    props: {\n      text: {\n        default: void 0\n      },\n      bgVariant: {\n        default: void 0\n      },\n      borderVariant: {\n        default: void 0\n      },\n      html: {\n        default: void 0\n      },\n      tag: {\n        default: \"div\"\n      },\n      textVariant: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = e;\n      return (l, a) => (y(), D(fn, ae({\n        class: \"card-footer\"\n      }, t), {\n        default: j(() => [O(l.$slots, \"default\", {}, () => [re(Z(l.text), 1)])]),\n        _: 3\n      }, 16));\n    }\n  }),\n  bn = /* @__PURE__ */H({\n    __name: \"BCard\",\n    props: {\n      align: {\n        default: void 0\n      },\n      bgVariant: {\n        default: null\n      },\n      bodyBgVariant: {\n        default: void 0\n      },\n      bodyClass: {\n        default: void 0\n      },\n      bodyTag: {\n        default: \"div\"\n      },\n      bodyTextVariant: {\n        default: void 0\n      },\n      borderVariant: {\n        default: null\n      },\n      footer: {\n        default: void 0\n      },\n      footerBgVariant: {\n        default: void 0\n      },\n      footerBorderVariant: {\n        default: void 0\n      },\n      footerClass: {\n        default: void 0\n      },\n      footerHtml: {\n        default: \"\"\n      },\n      footerTag: {\n        default: \"div\"\n      },\n      footerTextVariant: {\n        default: void 0\n      },\n      header: {\n        default: void 0\n      },\n      headerBgVariant: {\n        default: void 0\n      },\n      headerBorderVariant: {\n        default: void 0\n      },\n      headerClass: {\n        default: void 0\n      },\n      headerHtml: {\n        default: \"\"\n      },\n      headerTag: {\n        default: \"div\"\n      },\n      headerTextVariant: {\n        default: void 0\n      },\n      imgAlt: {\n        default: void 0\n      },\n      imgBottom: {\n        type: [String, Boolean],\n        default: !1\n      },\n      imgEnd: {\n        type: [String, Boolean],\n        default: !1\n      },\n      imgHeight: {\n        default: void 0\n      },\n      imgSrc: {\n        default: void 0\n      },\n      imgStart: {\n        type: [String, Boolean],\n        default: !1\n      },\n      imgTop: {\n        type: [String, Boolean],\n        default: !1\n      },\n      imgWidth: {\n        default: void 0\n      },\n      noBody: {\n        type: [String, Boolean],\n        default: !1\n      },\n      overlay: {\n        type: [String, Boolean],\n        default: !1\n      },\n      subtitle: {\n        default: void 0\n      },\n      subtitleTag: {\n        default: \"h6\"\n      },\n      subtitleTextVariant: {\n        default: \"muted\"\n      },\n      tag: {\n        default: \"div\"\n      },\n      textVariant: {\n        default: null\n      },\n      title: {\n        default: void 0\n      },\n      titleTag: {\n        default: \"h4\"\n      },\n      bodyText: {\n        default: \"\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = xe(),\n        a = d(() => t.imgBottom),\n        o = d(() => t.imgEnd),\n        n = d(() => t.imgStart),\n        s = d(() => t.noBody),\n        r = i(() => !Fe(l.header)),\n        u = i(() => !Fe(l.footer)),\n        f = i(() => ({\n          [`text-${t.align}`]: t.align !== void 0,\n          [`text-${t.textVariant}`]: t.textVariant !== null,\n          [`bg-${t.bgVariant}`]: t.bgVariant !== null,\n          [`border-${t.borderVariant}`]: t.borderVariant !== null,\n          \"flex-row\": n.value,\n          \"flex-row-reverse\": o.value\n        })),\n        v = i(() => ({\n          bgVariant: t.headerBgVariant,\n          borderVariant: t.headerBorderVariant,\n          html: t.headerHtml,\n          tag: t.headerTag,\n          textVariant: t.headerTextVariant\n        })),\n        p = i(() => ({\n          overlay: t.overlay,\n          bodyBgVariant: t.bodyBgVariant,\n          bodyTag: t.bodyTag,\n          bodyTextVariant: t.bodyTextVariant,\n          subtitle: t.subtitle,\n          subtitleTag: t.subtitleTag,\n          subtitleTextVariant: t.subtitleTextVariant,\n          title: t.title,\n          titleTag: t.titleTag\n        })),\n        c = i(() => ({\n          bgVariant: t.footerBgVariant,\n          borderVariant: t.footerBorderVariant,\n          html: t.footerHtml,\n          tag: t.footerTag,\n          textVariant: t.footerTextVariant\n        })),\n        g = i(() => ({\n          src: t.imgSrc,\n          alt: t.imgAlt,\n          height: t.imgHeight,\n          width: t.imgWidth,\n          bottom: t.imgBottom,\n          end: t.imgEnd,\n          start: t.imgStart,\n          top: t.imgTop\n        }));\n      return (B, m) => (y(), D(oe(B.tag), {\n        class: R([\"card\", f.value])\n      }, {\n        default: j(() => [$(a) ? J(\"\", !0) : O(B.$slots, \"img\", {\n          key: 0\n        }, () => [B.imgSrc ? (y(), D(ia, $e(ae({\n          key: 0\n        }, g.value)), null, 16)) : J(\"\", !0)]), B.header || r.value || B.headerHtml ? (y(), D(vn, ae({\n          key: 1\n        }, v.value, {\n          class: B.headerClass\n        }), {\n          default: j(() => [O(B.$slots, \"header\", {}, () => [re(Z(B.header), 1)])]),\n          _: 3\n        }, 16, [\"class\"])) : J(\"\", !0), $(s) ? O(B.$slots, \"default\", {\n          key: 3\n        }, () => [re(Z(B.bodyText), 1)]) : (y(), D(gn, ae({\n          key: 2\n        }, p.value, {\n          class: B.bodyClass\n        }), {\n          default: j(() => [O(B.$slots, \"default\", {}, () => [re(Z(B.bodyText), 1)])]),\n          _: 3\n        }, 16, [\"class\"])), B.footer || u.value || B.footerHtml ? (y(), D(yn, ae({\n          key: 4\n        }, c.value, {\n          class: B.footerClass\n        }), {\n          default: j(() => [O(B.$slots, \"footer\", {}, () => [re(Z(B.footer), 1)])]),\n          _: 3\n        }, 16, [\"class\"])) : J(\"\", !0), $(a) ? O(B.$slots, \"img\", {\n          key: 5\n        }, () => [B.imgSrc ? (y(), D(ia, $e(ae({\n          key: 0\n        }, g.value)), null, 16)) : J(\"\", !0)]) : J(\"\", !0)]),\n        _: 3\n      }, 8, [\"class\"]));\n    }\n  }),\n  Oi = /* @__PURE__ */H({\n    __name: \"BCardGroup\",\n    props: {\n      columns: {\n        type: [String, Boolean],\n        default: !1\n      },\n      deck: {\n        type: [String, Boolean],\n        default: !1\n      },\n      tag: {\n        default: \"div\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = d(() => t.columns),\n        a = d(() => t.deck),\n        o = i(() => a.value ? \"card-deck\" : l.value ? \"card-columns\" : \"card-group\"),\n        n = i(() => [o.value]);\n      return (s, r) => (y(), D(oe(s.tag), {\n        class: R(n.value)\n      }, {\n        default: j(() => [O(s.$slots, \"default\")]),\n        _: 3\n      }, 8, [\"class\"]));\n    }\n  }),\n  Ai = /* @__PURE__ */H({\n    __name: \"BCardText\",\n    props: {\n      text: {\n        default: void 0\n      },\n      tag: {\n        default: \"p\"\n      }\n    },\n    setup(e) {\n      return (t, l) => (y(), D(oe(t.tag), {\n        class: \"card-text\"\n      }, {\n        default: j(() => [O(t.$slots, \"default\", {}, () => [re(Z(t.text), 1)])]),\n        _: 3\n      }));\n    }\n  }),\n  Pi = [\"id\", \"onMouseenter\", \"onMouseleave\"],\n  Ei = {\n    key: 0,\n    class: \"carousel-indicators\"\n  },\n  Fi = [\"aria-current\", \"aria-label\", \"onClick\"],\n  Ii = /* @__PURE__ */Y(\"span\", {\n    class: \"carousel-control-prev-icon\",\n    \"aria-hidden\": \"true\"\n  }, null, -1),\n  xi = {\n    class: \"visually-hidden\"\n  },\n  Li = /* @__PURE__ */Y(\"span\", {\n    class: \"carousel-control-next-icon\",\n    \"aria-hidden\": \"true\"\n  }, null, -1),\n  Ni = {\n    class: \"visually-hidden\"\n  },\n  zi = /* @__PURE__ */H({\n    __name: \"BCarousel\",\n    props: {\n      ride: {\n        type: [Boolean, String],\n        default: !1\n      },\n      noHoverPause: {\n        type: [String, Boolean],\n        default: !1\n      },\n      rideReverse: {\n        type: [String, Boolean],\n        default: !1\n      },\n      fade: {\n        type: [String, Boolean],\n        default: !1\n      },\n      id: {\n        default: void 0\n      },\n      imgHeight: {\n        default: void 0\n      },\n      imgWidth: {\n        default: void 0\n      },\n      background: {\n        default: void 0\n      },\n      modelValue: {\n        default: 0\n      },\n      controls: {\n        type: [String, Boolean],\n        default: !1\n      },\n      indicators: {\n        type: [String, Boolean],\n        default: !1\n      },\n      interval: {\n        default: 5e3\n      },\n      noTouch: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noWrap: {\n        type: [String, Boolean],\n        default: !1\n      },\n      controlsPrevText: {\n        default: \"Previous\"\n      },\n      controlsNextText: {\n        default: \"Next\"\n      },\n      indicatorsButtonLabel: {\n        default: \"Slide\"\n      },\n      keyboard: {\n        type: [String, Boolean],\n        default: !0\n      },\n      touchThreshold: {\n        default: 50\n      }\n    },\n    emits: [\"slid\", \"slide\", \"update:modelValue\"],\n    setup(e, {\n      expose: t,\n      emit: l\n    }) {\n      const a = e,\n        o = xe(),\n        n = Ve(() => a.id, \"carousel\"),\n        s = ke(a, \"modelValue\", l, {\n          passive: !0\n        }),\n        r = d(() => a.keyboard),\n        u = d(() => a.rideReverse),\n        f = d(() => a.noHoverPause),\n        v = d(() => a.fade),\n        p = d(() => a.controls),\n        c = d(() => a.indicators),\n        g = d(() => a.noTouch),\n        B = d(() => a.noWrap),\n        m = bt(() => a.touchThreshold, {\n          nanToZero: !0,\n          method: \"parseInt\"\n        }),\n        V = M(!1),\n        b = M(!1),\n        T = M(!0),\n        _ = M(null),\n        h = M(null),\n        k = M(s.value),\n        C = i(() => es(a.ride) ? Ma(a.ride) : a.ride),\n        w = i(() => `carousel-item carousel-item-${T.value ? \"prev\" : \"next\"} carousel-item-${T.value ? \"end\" : \"start\"}`),\n        P = i(() => `carousel-item active carousel-item-${T.value ? \"start\" : \"end\"}`),\n        {\n          pause: F,\n          resume: S\n        } = Ko(() => {\n          u.value ? G() : X();\n        }, () => a.interval, {\n          immediate: C.value === \"carousel\"\n        }),\n        I = i(() => C.value === !0 && b.value === !0 || C.value === \"carousel\"),\n        x = i(() => $a(o.default, \"BCarouselSlide\")),\n        z = i(() => [\"carousel\", \"slide\", \"pointer-event\", {\n          \"carousel-fade\": v.value\n        }]),\n        te = ee => {\n          var ne;\n          return new vo(ee, {\n            componentId: n.value,\n            cancelable: !1,\n            target: h.value,\n            direction: T.value ? \"right\" : \"left\",\n            from: k.value,\n            to: s.value,\n            relatedTarget: ((ne = _.value) == null ? void 0 : ne.children[s.value]) ?? null\n          });\n        },\n        Q = ee => {\n          if (V.value !== !0) {\n            if (C.value === !0 && (b.value = !0), I.value === !0 && S(), T.value = !(ee < s.value), ee >= x.value.length) {\n              if (B.value) return;\n              s.value = 0;\n              return;\n            }\n            if (ee < 0) {\n              if (B.value) return;\n              s.value = x.value.length - 1;\n              return;\n            }\n            k.value = s.value, s.value = ee;\n          }\n        },\n        G = () => {\n          Q(s.value - 1);\n        },\n        X = () => {\n          Q(s.value + 1);\n        },\n        U = ee => {\n          r.value !== !1 && ee();\n        },\n        pe = () => {\n          f.value || F();\n        },\n        be = () => {\n          I.value && S();\n        },\n        {\n          lengthX: he\n        } = Ur(h, {\n          passive: !0,\n          onSwipeStart() {\n            g.value !== !0 && F();\n          },\n          onSwipeEnd() {\n            if (g.value === !0) return;\n            const ee = () => {\n              I.value !== !1 && S();\n            };\n            if (he.value >= m.value) {\n              X(), ee();\n              return;\n            }\n            he.value <= -m.value && (G(), ee());\n          }\n        }),\n        ye = () => {\n          l(\"slide\", te(\"slide\")), V.value = !0;\n        },\n        q = () => {\n          l(\"slid\", te(\"slid\")), V.value = !1;\n        };\n      return se(() => a.ride, () => {\n        b.value = !1;\n      }), t({\n        pause: F,\n        resume: S,\n        prev: G,\n        next: X\n      }), Ke(_o, {\n        background: Be(Ae(a, \"background\")),\n        width: Be(Ae(a, \"imgWidth\")),\n        height: Be(Ae(a, \"imgHeight\"))\n      }), (ee, ne) => (y(), A(\"div\", {\n        id: $(n),\n        ref_key: \"element\",\n        ref: h,\n        class: R(z.value),\n        onKeydown: [ne[0] || (ne[0] = xt(ue => U(G), [\"left\"])), ne[1] || (ne[1] = xt(ue => U(X), [\"right\"]))],\n        onMouseenter: ut(pe, [\"stop\"]),\n        onMouseleave: ut(be, [\"stop\"])\n      }, [$(c) ? (y(), A(\"div\", Ei, [(y(!0), A(fe, null, we(x.value.length, (ue, N) => (y(), A(\"button\", {\n        key: N,\n        type: \"button\",\n        \"data-bs-target\": \"\",\n        class: R(N === $(s) ? \"active\" : \"\"),\n        \"aria-current\": N === $(s) ? !0 : void 0,\n        \"aria-label\": `${ee.indicatorsButtonLabel} ${N}`,\n        onClick: le => Q(N)\n      }, null, 10, Fi))), 128))])) : J(\"\", !0), Y(\"div\", {\n        ref_key: \"relatedTarget\",\n        ref: _,\n        class: \"carousel-inner\"\n      }, [_e(Kn, {\n        \"enter-from-class\": w.value,\n        \"enter-active-class\": w.value,\n        \"enter-to-class\": w.value,\n        \"leave-from-class\": P.value,\n        \"leave-active-class\": P.value,\n        \"leave-to-class\": P.value,\n        onBeforeLeave: ye,\n        onAfterLeave: q\n      }, {\n        default: j(() => [(y(!0), A(fe, null, we(x.value, (ue, N) => rt((y(), D(oe(ue), {\n          key: N,\n          class: R({\n            active: N === $(s) && V.value === !1\n          })\n        }, null, 8, [\"class\"])), [[da, N === $(s)]])), 128))]),\n        _: 1\n      }, 8, [\"enter-from-class\", \"enter-active-class\", \"enter-to-class\", \"leave-from-class\", \"leave-active-class\", \"leave-to-class\"])], 512), $(p) ? (y(), A(fe, {\n        key: 1\n      }, [Y(\"button\", {\n        class: \"carousel-control-prev\",\n        type: \"button\",\n        onClick: G\n      }, [Ii, Y(\"span\", xi, Z(ee.controlsPrevText), 1)]), Y(\"button\", {\n        class: \"carousel-control-next\",\n        type: \"button\",\n        onClick: X\n      }, [Li, Y(\"span\", Ni, Z(ee.controlsNextText), 1)])], 64)) : J(\"\", !0)], 42, Pi));\n    }\n  }),\n  Hi = [\"innerHTML\"],\n  Ri = {\n    key: 1\n  },\n  Mi = [\"innerHTML\"],\n  Di = {\n    key: 1\n  },\n  ji = /* @__PURE__ */H({\n    __name: \"BCarouselSlide\",\n    props: {\n      imgSrc: {\n        default: void 0\n      },\n      imgHeight: {\n        default: void 0\n      },\n      imgWidth: {\n        default: void 0\n      },\n      interval: {\n        default: void 0\n      },\n      background: {\n        default: void 0\n      },\n      caption: {\n        default: void 0\n      },\n      captionHtml: {\n        default: void 0\n      },\n      captionTag: {\n        default: \"h3\"\n      },\n      contentTag: {\n        default: \"div\"\n      },\n      contentVisibleUp: {\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      imgAlt: {\n        default: void 0\n      },\n      imgBlank: {\n        type: [String, Boolean],\n        default: !1\n      },\n      imgBlankColor: {\n        default: \"transparent\"\n      },\n      text: {\n        default: void 0\n      },\n      textHtml: {\n        default: void 0\n      },\n      textTag: {\n        default: \"p\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = xe(),\n        a = Ie(_o, null),\n        o = i(() => t.text || t.textHtml || !Fe(l.text)),\n        n = i(() => t.caption || t.captionHtml || !Fe(l.caption)),\n        s = i(() => o.value || n.value || !Fe(l.default)),\n        r = i(() => ({\n          background: `${t.background || (a == null ? void 0 : a.background.value) || \"rgb(171, 171, 171)\"} none repeat scroll 0% 0%`\n        })),\n        u = i(() => ({\n          \"d-none\": t.contentVisibleUp !== void 0,\n          [`d-${t.contentVisibleUp}-block`]: t.contentVisibleUp !== void 0\n        }));\n      return (f, v) => (y(), A(\"div\", {\n        class: \"carousel-item\",\n        style: De(r.value)\n      }, [O(f.$slots, \"img\", {}, () => {\n        var p, c;\n        return [_e(al, {\n          class: \"d-block w-100\",\n          alt: f.imgAlt,\n          src: f.imgSrc,\n          width: f.imgWidth || ((p = $(a)) == null ? void 0 : p.width.value),\n          height: f.imgHeight || ((c = $(a)) == null ? void 0 : c.height.value),\n          blank: f.imgBlank,\n          \"blank-color\": f.imgBlankColor\n        }, null, 8, [\"alt\", \"src\", \"width\", \"height\", \"blank\", \"blank-color\"])];\n      }), s.value ? (y(), D(oe(f.contentTag), {\n        key: 0,\n        class: R([\"carousel-caption\", u.value])\n      }, {\n        default: j(() => [n.value ? (y(), D(oe(f.captionTag), {\n          key: 0\n        }, {\n          default: j(() => [O(f.$slots, \"caption\", {}, () => [f.captionHtml ? (y(), A(\"span\", {\n            key: 0,\n            innerHTML: f.captionHtml\n          }, null, 8, Hi)) : (y(), A(\"span\", Ri, Z(f.caption), 1))])]),\n          _: 3\n        })) : J(\"\", !0), o.value ? (y(), D(oe(f.textTag), {\n          key: 1\n        }, {\n          default: j(() => [O(f.$slots, \"text\", {}, () => [f.textHtml ? (y(), A(\"span\", {\n            key: 0,\n            innerHTML: f.textHtml\n          }, null, 8, Mi)) : (y(), A(\"span\", Di, Z(f.text), 1))])]),\n          _: 3\n        })) : J(\"\", !0), O(f.$slots, \"default\")]),\n        _: 3\n      }, 8, [\"class\"])) : J(\"\", !0)], 4));\n    }\n  }),\n  Hl = ca(\"\", [], {\n    type: [Boolean, String, Number],\n    default: !1\n  }),\n  Rl = ca(\"offset\", [\"\"], {\n    type: [String, Number],\n    default: null\n  }),\n  Ml = ca(\"order\", [\"\"], {\n    type: [String, Number],\n    default: null\n  }),\n  qi = H({\n    name: \"BCol\",\n    slots: Object,\n    props: {\n      col: {\n        type: [Boolean, String],\n        default: !1\n      },\n      // Generic flexbox .col (xs)\n      cols: {\n        type: [String, Number],\n        default: null\n      },\n      // .col-[1-12]|auto (xs)\n      ...Hl,\n      offset: {\n        type: [String, Number],\n        default: null\n      },\n      ...Rl,\n      order: {\n        type: [String, Number],\n        default: null\n      },\n      ...Ml,\n      alignSelf: {\n        type: String,\n        default: null\n      },\n      tag: {\n        type: String,\n        default: \"div\"\n      }\n    },\n    setup(e) {\n      const t = [{\n          content: Hl,\n          propPrefix: \"cols\",\n          classPrefix: \"col\"\n        }, {\n          content: Rl,\n          propPrefix: \"offset\"\n        }, {\n          content: Ml,\n          propPrefix: \"order\"\n        }],\n        l = d(() => e.col),\n        a = i(() => t.flatMap(n => So(e, n.content, n.propPrefix, n.classPrefix)));\n      return {\n        computedClasses: i(() => [a.value, {\n          col: l.value || !a.value.some(n => /^col-/.test(n)) && !e.cols,\n          [`col-${e.cols}`]: !!e.cols,\n          [`offset-${e.offset}`]: !!e.offset,\n          [`order-${e.order}`]: !!e.order,\n          [`align-self-${e.alignSelf}`]: !!e.alignSelf\n        }])\n      };\n    }\n  }),\n  ll = (e, t) => {\n    const l = e.__vccOpts || e;\n    for (const [a, o] of t) l[a] = o;\n    return l;\n  };\nfunction Gi(e, t, l, a, o, n) {\n  return y(), D(oe(e.tag), {\n    class: R(e.computedClasses)\n  }, {\n    default: j(() => [O(e.$slots, \"default\")]),\n    _: 3\n  }, 8, [\"class\"]);\n}\nconst Pt = /* @__PURE__ */ll(qi, [[\"render\", Gi]]),\n  pt = {\n    autoHide: !0,\n    delay: 5e3,\n    noCloseButton: !1,\n    pos: \"top-right\",\n    value: !0\n  };\nclass Dl {\n  constructor(t) {\n    Pe(this, \"vm\");\n    Pe(this, \"containerPositions\");\n    Xn(t) ? this.vm = t : this.vm = Bt(t), this.containerPositions = i(() => {\n      const l = /* @__PURE__ */new Set([]);\n      return this.vm.toasts.map(a => {\n        a.options.pos && l.add(a.options.pos);\n      }), l;\n    });\n  }\n  toasts(t) {\n    return t ? i(() => this.vm.toasts.filter(l => {\n      if (l.options.pos === t && l.options.value) return l;\n    })) : i(() => this.vm.toasts);\n  }\n  remove(...t) {\n    this.vm.toasts = this.vm.toasts.filter(l => {\n      if (l.options.id && !t.includes(l.options.id)) return l;\n    });\n  }\n  isRoot() {\n    return this.vm.root ?? !1;\n  }\n  show(t, l = pt) {\n    const a = {\n        id: lt(),\n        ...pt,\n        ...l\n      },\n      o = {\n        options: Bt(a),\n        content: t\n      };\n    return this.vm.toasts.push(o), o;\n  }\n  info(t, l = pt) {\n    return this.show(t, {\n      variant: \"info\",\n      ...l\n    });\n  }\n  danger(t, l = pt) {\n    return this.show(t, {\n      variant: \"danger\",\n      ...l\n    });\n  }\n  warning(t, l = pt) {\n    return this.show(t, {\n      variant: \"warning\",\n      ...l\n    });\n  }\n  success(t, l = pt) {\n    return this.show(t, {\n      variant: \"success\",\n      ...l\n    });\n  }\n  hide() {}\n}\nclass Wi {\n  constructor() {\n    Pe(this, \"vms\");\n    Pe(this, \"rootInstance\");\n    Pe(this, \"useToast\", Bn);\n    this.vms = {};\n  }\n  getOrCreateViewModel(t) {\n    if (!t) {\n      if (this.rootInstance) return this.vms[this.rootInstance];\n      const l = {\n        root: !0,\n        toasts: [],\n        container: void 0,\n        id: Symbol(\"toast\")\n      };\n      return this.rootInstance = l.id, this.vms[l.id] = l, l;\n    }\n    if (t.root) {\n      if (this.rootInstance) return this.vms[this.rootInstance];\n      this.rootInstance = t.id;\n    }\n    return this.vms[t.id] = t, t;\n  }\n  getVM(t) {\n    if (!t && this.rootInstance) return this.vms[this.rootInstance];\n    if (t) return this.vms[t];\n  }\n}\nconst Aa = Symbol(\"toast\"),\n  hn = Symbol(\"toastFetch\"),\n  Ui = {\n    container: void 0,\n    toasts: [],\n    root: !1\n  };\nfunction Ki() {\n  return Ie(hn);\n}\nfunction Bn(e, t = Aa) {\n  const l = Ie(Ki());\n  if (!e) return new Dl(l.getOrCreateViewModel());\n  const a = {\n      id: Symbol(\"toastInstance\")\n    },\n    o = {\n      ...Ui,\n      ...a,\n      ...e\n    },\n    n = l.getOrCreateViewModel(o);\n  return new Dl(n);\n}\nconst Sn = {\n    install: (e, t) => {\n      var a;\n      const l = typeof (t == null ? void 0 : t.BToast) == \"object\" ? ((a = t == null ? void 0 : t.BToast) == null ? void 0 : a.injectkey) ?? Aa : Aa;\n      e.provide(hn, l), e.provide(l, new Wi());\n    }\n  },\n  Xi = \"toast-title\",\n  jl = 1e3,\n  _n = H({\n    components: {\n      BLink: Qe\n    },\n    props: {\n      ...fi,\n      delay: {\n        type: Number,\n        default: 5e3\n      },\n      bodyClass: {\n        type: String,\n        default: void 0\n      },\n      body: {\n        type: [Object, String],\n        default: void 0\n      },\n      headerClass: {\n        type: String,\n        default: void 0\n      },\n      headerTag: {\n        type: String,\n        default: \"div\"\n      },\n      animation: {\n        type: [Boolean, String],\n        default: !0\n      },\n      id: {\n        type: String,\n        default: void 0\n      },\n      // Switches role to 'status' and aria-live to 'polite'\n      isStatus: {\n        type: [Boolean, String],\n        default: !1\n      },\n      autoHide: {\n        type: [Boolean, String],\n        default: !0\n      },\n      noCloseButton: {\n        type: [Boolean, String],\n        default: !1\n      },\n      noFade: {\n        type: [Boolean, String],\n        default: !1\n      },\n      noHoverPause: {\n        type: [Boolean, String],\n        default: !1\n      },\n      solid: {\n        type: [Boolean, String],\n        default: !1\n      },\n      // Render the toast in place, rather than in a portal-target\n      static: {\n        type: [Boolean, String],\n        default: !1\n      },\n      title: {\n        type: String,\n        default: void 0\n      },\n      modelValue: {\n        type: [Boolean, String],\n        default: !1\n      },\n      toastClass: {\n        type: Array,\n        default: void 0\n      },\n      variant: {\n        type: String,\n        default: null\n      }\n    },\n    emits: [\"destroyed\", \"update:modelValue\"],\n    setup(e, {\n      emit: t,\n      slots: l\n    }) {\n      d(() => e.animation);\n      const a = d(() => e.isStatus),\n        o = d(() => e.autoHide),\n        n = d(() => e.noCloseButton),\n        s = d(() => e.noFade),\n        r = d(() => e.noHoverPause);\n      d(() => e.solid), d(() => e.static);\n      const u = d(() => e.modelValue),\n        f = M(!1),\n        v = M(!1),\n        p = M(!1),\n        c = i(() => ({\n          [`b-toast-${e.variant}`]: e.variant !== null,\n          show: p.value || f.value\n        }));\n      let g, B, m;\n      const V = () => {\n          typeof g > \"u\" || (clearTimeout(g), g = void 0);\n        },\n        b = i(() =>\n        // Minimum supported duration is 1 second\n        Math.max(ot(e.delay, 0), jl)),\n        T = () => {\n          u.value && (B = m = 0, V(), v.value = !0, Gt(() => {\n            p.value = !1;\n          }));\n        },\n        _ = () => {\n          V(), t(\"update:modelValue\", !0), B = m = 0, v.value = !1, Oe(() => {\n            Gt(() => {\n              p.value = !0;\n            });\n          });\n        },\n        h = () => {\n          if (!o.value || r.value || !g || m) return;\n          const x = Date.now() - B;\n          x > 0 && (V(), m = Math.max(b.value - x, jl));\n        },\n        k = () => {\n          (!o.value || r.value || !m) && (m = B = 0), C();\n        };\n      se(u, x => {\n        x ? _() : T();\n      });\n      const C = () => {\n          V(), o.value && (g = setTimeout(T, m || b.value), B = Date.now(), m = 0);\n        },\n        w = () => {\n          f.value = !0, t(\"update:modelValue\", !0);\n        },\n        P = () => {\n          f.value = !1, C();\n        },\n        F = () => {\n          f.value = !0;\n        },\n        S = () => {\n          f.value = !1, m = B = 0, t(\"update:modelValue\", !1);\n        };\n      Yn(() => {\n        V(), o.value && t(\"destroyed\", e.id);\n      }), qe(() => {\n        Oe(() => {\n          u.value && Gt(() => {\n            _();\n          });\n        });\n      });\n      const I = () => {\n        Oe(() => {\n          Gt(() => {\n            T();\n          });\n        });\n      };\n      return () => {\n        const x = () => {\n          const z = [],\n            te = Me(Xi, {\n              hide: T\n            }, l);\n          te ? z.push(ie(te)) : e.title && z.push(ie(\"strong\", {\n            class: \"me-auto\"\n          }, e.title)), !n.value && z.length !== 0 && z.push(ie(Ot, {\n            class: [\"btn-close\"],\n            onClick: () => {\n              T();\n            }\n          }));\n          const Q = [];\n          if (z.length > 0 && Q.push(ie(e.headerTag, {\n            class: \"toast-header\"\n          }, {\n            default: () => z\n          })), Me(\"default\", {\n            hide: T\n          }, l) || e.body) {\n            const G = ie(St(e) ? \"b-link\" : \"div\", {\n              class: [\"toast-body\", e.bodyClass],\n              onClick: St(e) ? {\n                click: I\n              } : {}\n            }, Me(\"default\", {\n              hide: T\n            }, l) || e.body);\n            Q.push(G);\n          }\n          return ie(\"div\", {\n            class: [\"toast\", e.toastClass, c.value],\n            tabindex: \"0\"\n          }, Q);\n        };\n        return ie(\"div\", {\n          class: [\"b-toast\"],\n          id: e.id,\n          role: v.value ? null : a.value ? \"status\" : \"alert\",\n          \"aria-live\": v.value ? null : a.value ? \"polite\" : \"assertive\",\n          \"aria-atomic\": v.value ? null : !0,\n          onmouseenter: h,\n          onmouseleave: k\n        }, [ie(Vt, {\n          noFade: s.value,\n          onAfterEnter: P,\n          onBeforeEnter: w,\n          onAfterLeave: S,\n          onBeforeLeave: F\n        }, () => [p.value ? x() : \"\"])]);\n      };\n    }\n  }),\n  Pa = /* @__PURE__ */H({\n    __name: \"BToaster\",\n    props: {\n      position: {\n        default: \"top-right\"\n      },\n      instance: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = {\n          \"top-left\": \"top-0 start-0\",\n          \"top-center\": \"top-0 start-50 translate-middle-x\",\n          \"top-right\": \"top-0 end-0\",\n          \"middle-left\": \"top-50 start-0 translate-middle-y\",\n          \"middle-center\": \"top-50 start-50 translate-middle\",\n          \"middle-right\": \"top-50 end-0 translate-middle-y\",\n          \"bottom-left\": \"bottom-0 start-0\",\n          \"bottom-center\": \"bottom-0 start-50 translate-middle-x\",\n          \"bottom-right\": \"bottom-0 end-0\"\n        },\n        a = i(() => l[t.position]),\n        o = n => {\n          var s;\n          (s = t.instance) == null || s.remove(n);\n        };\n      return (n, s) => {\n        var r;\n        return y(), A(\"div\", {\n          class: R([[a.value], \"b-toaster position-fixed p-3\"]),\n          style: {\n            \"z-index\": \"11\"\n          }\n        }, [(y(!0), A(fe, null, we((r = n.instance) == null ? void 0 : r.toasts(n.position).value, u => (y(), D(_n, {\n          id: u.options.id,\n          key: u.options.id,\n          modelValue: u.options.value,\n          \"onUpdate:modelValue\": f => u.options.value = f,\n          \"auto-hide\": u.options.autoHide,\n          delay: u.options.delay,\n          \"no-close-button\": u.options.noCloseButton,\n          title: u.content.title,\n          body: u.content.body,\n          component: u.content.body,\n          variant: u.options.variant,\n          onDestroyed: o\n        }, null, 8, [\"id\", \"modelValue\", \"onUpdate:modelValue\", \"auto-hide\", \"delay\", \"no-close-button\", \"title\", \"body\", \"component\", \"variant\"]))), 128))], 2);\n      };\n    }\n  }),\n  Yi = H({\n    slots: Object,\n    props: {\n      gutterX: {\n        type: String,\n        default: null\n      },\n      gutterY: {\n        type: String,\n        default: null\n      },\n      fluid: {\n        type: [Boolean, String],\n        default: !1\n      },\n      toast: {\n        type: Object,\n        default: void 0\n      },\n      position: {\n        type: String,\n        default: void 0\n      }\n    },\n    setup(e, {\n      slots: t,\n      expose: l\n    }) {\n      const a = M();\n      let o;\n      const n = i(() => ({\n        container: !e.fluid,\n        [\"container-fluid\"]: typeof e.fluid == \"boolean\" && e.fluid,\n        [`container-${e.fluid}`]: typeof e.fluid == \"string\",\n        [`gx-${e.gutterX}`]: e.gutterX !== null,\n        [`gy-${e.gutterY}`]: e.gutterY !== null\n      }));\n      return qe(() => {\n        e.toast;\n      }), e.toast && (o = Bn({\n        container: a,\n        root: e.toast.root\n      }), l({\n        // ...toastInstance?.useMethods,\n      })), () => {\n        var r;\n        const s = [];\n        return o == null || o.containerPositions.value.forEach(u => {\n          s.push(ie(Pa, {\n            key: u,\n            instance: o,\n            position: u\n          }));\n        }), ie(\"div\", {\n          class: [n.value, e.position],\n          ref: a\n        }, [...s, (r = t.default) == null ? void 0 : r.call(t)]);\n      };\n    },\n    methods: {}\n  }),\n  Ji = {\n    class: \"visually-hidden\"\n  },\n  Zi = [\"aria-labelledby\", \"role\"],\n  wn = /* @__PURE__ */H({\n    inheritAttrs: !1,\n    __name: \"BDropdown\",\n    props: {\n      ariaLabel: {\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      menuClass: {\n        default: void 0\n      },\n      size: {\n        default: \"md\"\n      },\n      splitClass: {\n        default: void 0\n      },\n      splitVariant: {\n        default: void 0\n      },\n      text: {\n        default: void 0\n      },\n      toggleClass: {\n        default: void 0\n      },\n      autoClose: {\n        type: [Boolean, String],\n        default: !0\n      },\n      block: {\n        type: [String, Boolean],\n        default: !1\n      },\n      dark: {\n        type: [String, Boolean],\n        default: !1\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      isNav: {\n        type: [String, Boolean],\n        default: !1\n      },\n      dropup: {\n        type: [String, Boolean],\n        default: !1\n      },\n      dropend: {\n        type: [String, Boolean],\n        default: !1\n      },\n      dropstart: {\n        type: [String, Boolean],\n        default: !1\n      },\n      center: {\n        type: [String, Boolean],\n        default: !1\n      },\n      end: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noFlip: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noShift: {\n        type: [String, Boolean],\n        default: !1\n      },\n      offset: {\n        default: 0\n      },\n      role: {\n        default: \"menu\"\n      },\n      split: {\n        type: [String, Boolean],\n        default: !1\n      },\n      splitButtonType: {\n        default: \"button\"\n      },\n      splitHref: {\n        default: void 0\n      },\n      splitDisabled: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      noCaret: {\n        type: [String, Boolean],\n        default: !1\n      },\n      toggleText: {\n        default: \"Toggle dropdown\"\n      },\n      variant: {\n        default: \"secondary\"\n      },\n      modelValue: {\n        type: [String, Boolean],\n        default: !1\n      },\n      lazy: {\n        type: [String, Boolean],\n        default: !1\n      },\n      strategy: {\n        default: \"absolute\"\n      },\n      floatingMiddleware: {\n        default: void 0\n      },\n      splitTo: {\n        default: void 0\n      }\n    },\n    emits: [\"show\", \"shown\", \"hide\", \"hidden\", \"hide-prevented\", \"show-prevented\", \"click\", \"toggle\", \"update:modelValue\"],\n    setup(e, {\n      expose: t,\n      emit: l\n    }) {\n      const a = e,\n        o = Ve(() => a.id, \"dropdown\"),\n        n = ke(a, \"modelValue\", l, {\n          passive: !0\n        }),\n        s = d(n),\n        r = d(() => a.block),\n        u = d(() => a.dark),\n        f = d(() => a.dropup),\n        v = d(() => a.dropend),\n        p = d(() => a.isNav),\n        c = d(() => a.dropstart),\n        g = d(() => a.center),\n        B = d(() => a.end),\n        m = d(() => a.split),\n        V = d(() => a.noCaret),\n        b = d(() => a.noFlip),\n        T = d(() => a.noShift),\n        _ = d(() => a.lazy),\n        h = d(() => a.splitDisabled),\n        k = i(() => typeof a.offset == \"string\" || typeof a.offset == \"number\" ? a.offset : NaN),\n        C = bt(k, {\n          method: \"parseInt\",\n          nanToZero: !0\n        }),\n        w = M(null),\n        P = M(null),\n        F = M(null),\n        S = i(() => m.value ? P.value : F.value),\n        I = i(() => ai({\n          top: f.value,\n          start: c.value,\n          end: v.value,\n          alignCenter: g.value,\n          alignEnd: B.value\n        })),\n        x = i(() => {\n          if (a.floatingMiddleware !== void 0) return a.floatingMiddleware;\n          const N = typeof a.offset == \"string\" || typeof a.offset == \"number\" ? C.value : a.offset,\n            le = [Io(N)];\n          return b.value === !1 && le.push(Fo()), T.value === !1 && le.push(xo()), le;\n        }),\n        {\n          x: z,\n          y: te,\n          strategy: Q,\n          update: G\n        } = Go(S, w, {\n          placement: I,\n          middleware: x,\n          strategy: a.strategy\n        }),\n        X = i(() => ({\n          \"d-grid\": r.value,\n          dropup: f.value,\n          dropend: v.value,\n          dropstart: c.value,\n          \"d-flex\": r.value && m.value\n        })),\n        U = i(() => [m.value ? a.splitClass : a.toggleClass, {\n          \"nav-link\": p.value,\n          \"dropdown-toggle\": !m.value,\n          \"dropdown-toggle-no-caret\": V.value && !m.value,\n          \"w-100\": m.value && r.value,\n          show: m.value ? void 0 : s.value\n        }]),\n        pe = i(() => [a.menuClass, {\n          \"dropdown-menu-dark\": u.value\n        }]),\n        be = i(() => ({\n          \"aria-label\": a.ariaLabel,\n          \"aria-expanded\": m.value ? void 0 : s.value,\n          \"aria-haspopup\": m.value ? void 0 : \"menu\",\n          href: m.value ? a.splitHref : void 0,\n          to: m.value && a.splitTo ? a.splitTo : void 0\n        })),\n        he = () => {\n          l(\"toggle\");\n          const N = s.value,\n            le = new Je(N ? \"hide\" : \"show\");\n          if (l(N ? \"hide\" : \"show\", le), le.defaultPrevented) {\n            l(N ? \"hide-prevented\" : \"show-prevented\");\n            return;\n          }\n          n.value = !N, l(N ? \"hidden\" : \"shown\");\n        },\n        ye = N => {\n          m.value ? l(\"click\", N) : he();\n        };\n      Jo(w, () => {\n        s.value && (a.autoClose === !0 || a.autoClose === \"outside\") && ue();\n      }, {\n        ignore: [P, F]\n      });\n      const q = () => {\n          s.value && (a.autoClose === !0 || a.autoClose === \"inside\") && ue();\n        },\n        ee = () => {\n          n.value = !1;\n        },\n        ne = () => {\n          n.value = !0;\n        },\n        ue = () => {\n          n.value = !s.value;\n        };\n      return se(s, G), t({\n        close: ee,\n        open: ne,\n        toggle: ue\n      }), Ke(Ao, {\n        id: o,\n        open: ne,\n        close: ee,\n        toggle: ue,\n        visible: s,\n        isNav: p\n      }), (N, le) => (y(), A(fe, null, [Y(\"div\", ae({\n        class: [X.value, \"btn-group\"]\n      }, N.$attrs), [_e(kt, ae({\n        id: $(o),\n        ref_key: \"splitButton\",\n        ref: F,\n        variant: N.splitVariant || N.variant,\n        size: N.size,\n        class: U.value,\n        disabled: $(h) || N.disabled,\n        type: N.splitButtonType\n      }, be.value, {\n        onClick: ye,\n        onKeydown: le[0] || (le[0] = xt(de => n.value = !$(s), [\"esc\"]))\n      }), {\n        default: j(() => [O(N.$slots, \"button-content\", {}, () => [re(Z(N.text), 1)])]),\n        _: 3\n      }, 16, [\"id\", \"variant\", \"size\", \"class\", \"disabled\", \"type\"]), $(m) ? (y(), D(kt, {\n        key: 0,\n        ref_key: \"button\",\n        ref: P,\n        variant: N.variant,\n        size: N.size,\n        disabled: N.disabled,\n        class: R([[N.toggleClass, $(s) ? \"show\" : void 0], \"dropdown-toggle-split dropdown-toggle\"]),\n        \"aria-expanded\": $(s),\n        \"aria-haspopup\": \"menu\",\n        onClick: he\n      }, {\n        default: j(() => [Y(\"span\", Ji, [O(N.$slots, \"toggle-text\", {}, () => [re(Z(N.toggleText), 1)])])]),\n        _: 3\n      }, 8, [\"variant\", \"size\", \"disabled\", \"class\", \"aria-expanded\"])) : J(\"\", !0)], 16), !$(_) || $(s) ? rt((y(), A(\"ul\", {\n        key: 0,\n        ref_key: \"floating\",\n        ref: w,\n        style: De({\n          position: $(Q) === \"absolute\" ? void 0 : \"fixed\",\n          top: `${$(te)}px`,\n          left: `${$(z)}px`,\n          width: \"max-content\"\n        }),\n        class: R([\"dropdown-menu show\", pe.value]),\n        \"aria-labelledby\": $(o),\n        role: N.role,\n        onClick: q\n      }, [O(N.$slots, \"default\")], 14, Zi)), [[da, $(_) || $(s)]]) : J(\"\", !0)], 64));\n    }\n  }),\n  Qi = {\n    role: \"presentation\"\n  },\n  eu = /* @__PURE__ */H({\n    __name: \"BDropdownDivider\",\n    props: {\n      tag: {\n        default: \"hr\"\n      }\n    },\n    setup(e) {\n      return (t, l) => (y(), A(\"li\", Qi, [(y(), D(oe(t.tag), {\n        class: \"dropdown-divider\",\n        role: \"separator\",\n        \"aria-orientation\": \"horizontal\"\n      }))]));\n    }\n  }),\n  tu = {\n    role: \"presentation\"\n  },\n  au = {\n    class: \"px-4 py-3\"\n  },\n  lu = /* @__PURE__ */H({\n    __name: \"BDropdownForm\",\n    setup(e) {\n      return (t, l) => (y(), A(\"li\", tu, [Y(\"form\", au, [O(t.$slots, \"default\")])]));\n    }\n  }),\n  ou = {\n    role: \"presentation\"\n  },\n  nu = [\"id\", \"aria-describedby\"],\n  su = /* @__PURE__ */H({\n    inheritAttrs: !1,\n    __name: \"BDropdownGroup\",\n    props: {\n      id: {\n        default: void 0\n      },\n      ariaDescribedby: {\n        default: void 0\n      },\n      header: {\n        default: void 0\n      },\n      headerClass: {\n        default: void 0\n      },\n      headerTag: {\n        default: \"header\"\n      },\n      headerVariant: {\n        default: null\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = i(() => t.id ? `${t.id}_group_dd_header` : void 0),\n        a = i(() => t.headerTag === \"header\" ? void 0 : \"heading\"),\n        o = i(() => [t.headerClass, {\n          [`text-${t.headerVariant}`]: t.headerVariant !== null\n        }]);\n      return (n, s) => (y(), A(\"li\", ou, [(y(), D(oe(n.headerTag), {\n        id: l.value,\n        class: R([\"dropdown-header\", o.value]),\n        role: a.value\n      }, {\n        default: j(() => [O(n.$slots, \"header\", {}, () => [re(Z(n.header), 1)])]),\n        _: 3\n      }, 8, [\"id\", \"class\", \"role\"])), Y(\"ul\", ae({\n        id: n.id,\n        role: \"group\",\n        class: \"list-unstyled\"\n      }, n.$attrs, {\n        \"aria-describedby\": n.ariaDescribedby || l.value\n      }), [O(n.$slots, \"default\")], 16, nu)]));\n    }\n  }),\n  ru = {\n    class: \"dropdown-header\"\n  },\n  iu = /* @__PURE__ */H({\n    __name: \"BDropdownHeader\",\n    setup(e) {\n      return (t, l) => (y(), A(\"li\", null, [Y(\"h6\", ru, [O(t.$slots, \"default\")])]));\n    }\n  }),\n  uu = /* @__PURE__ */H({\n    inheritAttrs: !1,\n    __name: \"BDropdownItem\",\n    props: {\n      href: {\n        default: void 0\n      },\n      linkClass: {\n        default: void 0\n      },\n      active: {\n        type: [String, Boolean],\n        default: !1\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      rel: {\n        default: void 0\n      },\n      target: {\n        default: \"_self\"\n      },\n      variant: {\n        default: null\n      }\n    },\n    emits: [\"click\"],\n    setup(e, {\n      emit: t\n    }) {\n      const l = e,\n        a = d(() => l.active),\n        o = d(() => l.disabled),\n        n = Ra(),\n        s = i(() => [l.linkClass, {\n          active: a.value,\n          disabled: o.value,\n          [`text-${l.variant}`]: l.variant !== null\n        }]),\n        r = i(() => l.href ? \"a\" : n.to ? Qe : \"button\"),\n        u = i(() => ({\n          disabled: o.value,\n          \"aria-current\": a.value ? !0 : null,\n          href: r.value === \"a\" ? l.href : null,\n          rel: l.rel,\n          type: r.value === \"button\" ? \"button\" : null,\n          target: l.target,\n          ...(n.to ? {\n            activeClass: \"active\",\n            ...n\n          } : n)\n        })),\n        f = Ie(Wa, null),\n        v = Ie(Ao, null),\n        p = Ie(Ua, null),\n        c = g => {\n          var B, m;\n          t(\"click\", g), p !== null && ((B = f == null ? void 0 : f.close) == null || B.call(f)), (m = v == null ? void 0 : v.close) == null || m.call(v);\n        };\n      return (g, B) => (y(), A(\"li\", {\n        role: \"presentation\",\n        class: R(g.$attrs.class)\n      }, [(y(), D(oe(r.value), ae({\n        class: [\"dropdown-item\", s.value]\n      }, u.value, {\n        onClick: c\n      }), {\n        default: j(() => [O(g.$slots, \"default\")]),\n        _: 3\n      }, 16, [\"class\"]))], 2));\n    }\n  }),\n  du = [\"disabled\"],\n  cu = /* @__PURE__ */H({\n    inheritAttrs: !1,\n    __name: \"BDropdownItemButton\",\n    props: {\n      buttonClass: {\n        default: void 0\n      },\n      active: {\n        type: [String, Boolean],\n        default: !1\n      },\n      activeClass: {\n        default: \"active\"\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      variant: {\n        default: null\n      }\n    },\n    emits: [\"click\"],\n    setup(e, {\n      emit: t\n    }) {\n      const l = e,\n        a = d(() => l.active),\n        o = d(() => l.disabled),\n        n = i(() => [l.buttonClass, {\n          [l.activeClass]: a.value,\n          disabled: o.value,\n          [`text-${l.variant}`]: l.variant !== null\n        }]),\n        s = r => t(\"click\", r);\n      return (r, u) => (y(), A(\"li\", {\n        role: \"presentation\",\n        class: R(r.$attrs.class)\n      }, [Y(\"button\", {\n        role: \"menu\",\n        type: \"button\",\n        class: R([\"dropdown-item\", n.value]),\n        disabled: $(o),\n        onClick: s\n      }, [O(r.$slots, \"default\")], 10, du)], 2));\n    }\n  }),\n  fu = {\n    role: \"presentation\"\n  },\n  vu = {\n    class: \"px-4 py-1 mb-0 text-muted\"\n  },\n  pu = /* @__PURE__ */H({\n    __name: \"BDropdownText\",\n    props: {\n      text: {\n        default: \"\"\n      }\n    },\n    setup(e) {\n      return (t, l) => (y(), A(\"li\", fu, [Y(\"p\", vu, [O(t.$slots, \"default\", {}, () => [re(Z(t.text), 1)])])]));\n    }\n  }),\n  mu = [\"id\", \"novalidate\", \"onSubmit\"],\n  $n = /* @__PURE__ */H({\n    __name: \"BForm\",\n    props: {\n      id: {\n        default: void 0\n      },\n      floating: {\n        type: [String, Boolean],\n        default: !1\n      },\n      novalidate: {\n        type: [String, Boolean],\n        default: !1\n      },\n      validated: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    emits: [\"submit\"],\n    setup(e, {\n      emit: t\n    }) {\n      const l = e,\n        a = d(() => l.floating),\n        o = d(() => l.novalidate),\n        n = d(() => l.validated),\n        s = i(() => ({\n          \"form-floating\": a.value,\n          \"was-validated\": n.value\n        })),\n        r = u => t(\"submit\", u);\n      return (u, f) => (y(), A(\"form\", {\n        id: u.id,\n        novalidate: $(o),\n        class: R(s.value),\n        onSubmit: ut(r, [\"prevent\"])\n      }, [O(u.$slots, \"default\")], 42, mu));\n    }\n  }),\n  gu = {\n    class: \"form-floating\"\n  },\n  yu = [\"for\"],\n  bu = /* @__PURE__ */H({\n    __name: \"BFormFloatingLabel\",\n    props: {\n      labelFor: {\n        default: void 0\n      },\n      label: {\n        default: void 0\n      },\n      text: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      return (t, l) => (y(), A(\"div\", gu, [O(t.$slots, \"default\", {}, () => [re(Z(t.text), 1)]), Y(\"label\", {\n        for: t.labelFor\n      }, [O(t.$slots, \"label\", {}, () => [re(Z(t.label), 1)])], 8, yu)]));\n    }\n  }),\n  Ea = /* @__PURE__ */H({\n    __name: \"BFormInvalidFeedback\",\n    props: {\n      ariaLive: {\n        default: void 0\n      },\n      forceShow: {\n        type: [String, Boolean],\n        default: !1\n      },\n      id: {\n        default: void 0\n      },\n      text: {\n        default: void 0\n      },\n      role: {\n        default: void 0\n      },\n      state: {\n        type: [String, Boolean, null],\n        default: null\n      },\n      tag: {\n        default: \"div\"\n      },\n      tooltip: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = d(() => t.forceShow),\n        a = d(() => t.state),\n        o = d(() => t.tooltip),\n        n = i(() => l.value === !0 || a.value === !1),\n        s = i(() => ({\n          \"d-block\": n.value,\n          \"invalid-feedback\": !o.value,\n          \"invalid-tooltip\": o.value\n        })),\n        r = i(() => ({\n          id: t.id,\n          role: t.role,\n          \"aria-live\": t.ariaLive,\n          \"aria-atomic\": t.ariaLive ? !0 : void 0\n        }));\n      return (u, f) => (y(), D(oe(u.tag), ae({\n        class: s.value\n      }, r.value), {\n        default: j(() => [O(u.$slots, \"default\", {}, () => [re(Z(u.text), 1)])]),\n        _: 3\n      }, 16, [\"class\"]));\n    }\n  }),\n  Zt = /* @__PURE__ */H({\n    __name: \"BFormRow\",\n    props: {\n      tag: {\n        default: \"div\"\n      }\n    },\n    setup(e) {\n      return (t, l) => (y(), D(oe(t.tag), {\n        class: \"row d-flex flex-wrap\"\n      }, {\n        default: j(() => [O(t.$slots, \"default\")]),\n        _: 3\n      }));\n    }\n  }),\n  Fa = /* @__PURE__ */H({\n    __name: \"BFormText\",\n    props: {\n      id: {\n        default: void 0\n      },\n      inline: {\n        type: [String, Boolean],\n        default: !1\n      },\n      tag: {\n        default: \"small\"\n      },\n      text: {\n        default: void 0\n      },\n      textVariant: {\n        default: \"muted\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = d(() => t.inline),\n        a = i(() => ({\n          [`text-${t.textVariant}`]: t.textVariant !== null,\n          \"form-text\": !l.value\n        }));\n      return (o, n) => (y(), D(oe(o.tag), {\n        id: o.id,\n        class: R(a.value)\n      }, {\n        default: j(() => [O(o.$slots, \"default\", {}, () => [re(Z(o.text), 1)])]),\n        _: 3\n      }, 8, [\"id\", \"class\"]));\n    }\n  }),\n  Ia = /* @__PURE__ */H({\n    __name: \"BFormValidFeedback\",\n    props: {\n      ariaLive: {\n        default: void 0\n      },\n      forceShow: {\n        type: [String, Boolean],\n        default: !1\n      },\n      id: {\n        default: void 0\n      },\n      role: {\n        default: void 0\n      },\n      text: {\n        default: void 0\n      },\n      state: {\n        type: [String, Boolean, null],\n        default: null\n      },\n      tag: {\n        default: \"div\"\n      },\n      tooltip: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = d(() => t.forceShow),\n        a = d(() => t.state),\n        o = d(() => t.tooltip),\n        n = i(() => l.value === !0 || a.value === !0),\n        s = i(() => ({\n          \"d-block\": n.value,\n          \"valid-feedback\": !o.value,\n          \"valid-tooltip\": o.value\n        })),\n        r = i(() => t.ariaLive ? !0 : void 0);\n      return (u, f) => (y(), D(oe(u.tag), {\n        id: u.id,\n        role: u.role,\n        \"aria-live\": u.ariaLive,\n        \"aria-atomic\": r.value,\n        class: R(s.value)\n      }, {\n        default: j(() => [O(u.$slots, \"default\", {}, () => [re(Z(u.text), 1)])]),\n        _: 3\n      }, 8, [\"id\", \"role\", \"aria-live\", \"aria-atomic\", \"class\"]));\n    }\n  }),\n  hu = [\"id\", \"disabled\", \"required\", \"name\", \"form\", \"aria-label\", \"aria-labelledby\", \"aria-required\", \"value\", \"indeterminate\"],\n  Bu = [\"for\"],\n  kn = /* @__PURE__ */H({\n    inheritAttrs: !1,\n    __name: \"BFormCheckbox\",\n    props: {\n      ariaLabel: {\n        default: void 0\n      },\n      ariaLabelledBy: {\n        default: void 0\n      },\n      form: {\n        default: void 0\n      },\n      indeterminate: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      name: {\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      autofocus: {\n        type: [String, Boolean],\n        default: !1\n      },\n      plain: {\n        type: [String, Boolean],\n        default: !1\n      },\n      button: {\n        type: [String, Boolean],\n        default: !1\n      },\n      buttonGroup: {\n        type: [String, Boolean],\n        default: !1\n      },\n      switch: {\n        type: [String, Boolean],\n        default: !1\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      buttonVariant: {\n        default: null\n      },\n      inline: {\n        type: [String, Boolean],\n        default: !1\n      },\n      required: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      size: {\n        default: void 0\n      },\n      state: {\n        type: [String, Boolean, null],\n        default: null\n      },\n      uncheckedValue: {\n        type: [Array, Set, Boolean, String, Object, Number, null],\n        default: !1\n      },\n      value: {\n        type: [Array, Set, Boolean, String, Object, Number, null],\n        default: !0\n      },\n      modelValue: {\n        type: [Array, Set, Boolean, String, Object, Number, null],\n        default: void 0\n      }\n    },\n    emits: [\"update:modelValue\", \"input\", \"change\"],\n    setup(e, {\n      expose: t,\n      emit: l\n    }) {\n      const a = e,\n        o = xe(),\n        n = ke(a, \"modelValue\", l, {\n          passive: !0\n        }),\n        s = Ve(() => a.id, \"form-check\"),\n        r = d(() => a.indeterminate),\n        u = d(() => a.autofocus),\n        f = d(() => a.plain),\n        v = d(() => a.button),\n        p = d(() => a.buttonGroup),\n        c = d(() => a.switch),\n        g = d(() => a.disabled),\n        B = d(() => a.inline),\n        m = d(() => a.required),\n        V = d(() => a.state),\n        b = Ie(Vo, null),\n        T = M(null),\n        {\n          focused: _\n        } = ze(T, {\n          initialValue: u.value\n        }),\n        h = i(() => !Fe(o.default)),\n        k = i({\n          get: () => b !== null ? b.modelValue.value.map(x => JSON.stringify(x)).includes(JSON.stringify(a.value)) : JSON.stringify(n.value) === JSON.stringify(a.value),\n          set: x => {\n            const z = x ? a.value : a.uncheckedValue;\n            l(\"input\", z), n.value = z, Oe(() => {\n              l(\"change\", z);\n            });\n          }\n        });\n      se(n, x => {\n        if (b !== null) {\n          if (x === !1) {\n            b.remove(a.value);\n            return;\n          }\n          b.set(a.value);\n        }\n      });\n      const C = i(() => !!(a.name ?? (b == null ? void 0 : b.name.value)) && (m.value || (b == null ? void 0 : b.required.value))),\n        w = i(() => p.value || ((b == null ? void 0 : b.buttons.value) ?? !1)),\n        P = i(() => ({\n          plain: f.value || ((b == null ? void 0 : b.plain.value) ?? !1),\n          button: v.value || ((b == null ? void 0 : b.buttons.value) ?? !1),\n          inline: B.value || ((b == null ? void 0 : b.inline.value) ?? !1),\n          switch: c.value || ((b == null ? void 0 : b.switch.value) ?? !1),\n          state: V.value || (b == null ? void 0 : b.state.value),\n          size: a.size !== void 0 ? a.size : (b == null ? void 0 : b.size.value) ?? \"md\",\n          // This is where the true default is made\n          buttonVariant: a.buttonVariant !== null ? a.buttonVariant : (b == null ? void 0 : b.buttonVariant.value) ?? \"secondary\"\n          // This is where the true default is made\n        })),\n        F = en(P),\n        S = tn(P),\n        I = an(P);\n      return t({\n        focus: () => {\n          _.value = !0;\n        },\n        blur: () => {\n          _.value = !1;\n        }\n      }), (x, z) => (y(), D(Qa, {\n        skip: w.value,\n        class: R($(F))\n      }, {\n        default: j(() => {\n          var te, Q, G;\n          return [rt(Y(\"input\", ae({\n            id: $(s)\n          }, x.$attrs, {\n            ref_key: \"input\",\n            ref: T,\n            \"onUpdate:modelValue\": z[0] || (z[0] = X => k.value = X),\n            class: $(S),\n            type: \"checkbox\",\n            disabled: $(g) || ((te = $(b)) == null ? void 0 : te.disabled.value),\n            required: C.value || void 0,\n            name: x.name || ((Q = $(b)) == null ? void 0 : Q.name.value),\n            form: x.form || ((G = $(b)) == null ? void 0 : G.form.value),\n            \"aria-label\": x.ariaLabel,\n            \"aria-labelledby\": x.ariaLabelledBy,\n            \"aria-required\": C.value || void 0,\n            value: x.value,\n            indeterminate: $(r)\n          }), null, 16, hu), [[Jn, k.value]]), h.value || $(f) === !1 ? (y(), A(\"label\", {\n            key: 0,\n            for: $(s),\n            class: R($(I))\n          }, [O(x.$slots, \"default\")], 10, Bu)) : J(\"\", !0)];\n        }),\n        _: 3\n      }, 8, [\"skip\", \"class\"]));\n    }\n  }),\n  Su = [\"id\"],\n  _u = [\"innerHTML\"],\n  wu = [\"textContent\"],\n  $u = /* @__PURE__ */H({\n    __name: \"BFormCheckboxGroup\",\n    props: {\n      id: {\n        default: void 0\n      },\n      form: {\n        default: void 0\n      },\n      modelValue: {\n        default: () => []\n      },\n      ariaInvalid: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      autofocus: {\n        type: [String, Boolean],\n        default: !1\n      },\n      buttonVariant: {\n        default: \"secondary\"\n      },\n      buttons: {\n        type: [String, Boolean],\n        default: !1\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      disabledField: {\n        default: \"disabled\"\n      },\n      htmlField: {\n        default: \"html\"\n      },\n      name: {\n        default: void 0\n      },\n      options: {\n        default: () => []\n      },\n      plain: {\n        type: [String, Boolean],\n        default: !1\n      },\n      required: {\n        type: [String, Boolean],\n        default: !1\n      },\n      size: {\n        default: \"md\"\n      },\n      stacked: {\n        type: [String, Boolean],\n        default: !1\n      },\n      state: {\n        type: [String, Boolean, null],\n        default: null\n      },\n      switches: {\n        type: [String, Boolean],\n        default: !1\n      },\n      textField: {\n        default: \"text\"\n      },\n      validated: {\n        type: [String, Boolean],\n        default: !1\n      },\n      valueField: {\n        default: \"value\"\n      }\n    },\n    emits: [\"input\", \"update:modelValue\", \"change\"],\n    setup(e, {\n      expose: t,\n      emit: l\n    }) {\n      const a = e,\n        o = ke(a, \"modelValue\", l),\n        n = Ve(() => a.id, \"checkbox\"),\n        s = Ve(() => a.name, \"checkbox\"),\n        r = d(() => a.autofocus),\n        u = d(() => a.buttons),\n        f = d(() => a.disabled),\n        v = d(() => a.plain),\n        p = d(() => a.required),\n        c = d(() => a.stacked),\n        g = d(() => a.state),\n        B = d(() => a.switches),\n        m = d(() => a.validated),\n        V = M(null),\n        {\n          focused: b\n        } = ze(V, {\n          initialValue: r.value\n        });\n      Ke(Vo, {\n        set: C => {\n          const w = [...o.value];\n          w.push(C), l(\"input\", w), o.value = w, Oe(() => {\n            l(\"change\", w);\n          });\n        },\n        remove: C => {\n          const w = [...o.value];\n          w.splice(o.value.indexOf(C), 1), l(\"input\", w), o.value = w, Oe(() => {\n            l(\"change\", w);\n          });\n        },\n        modelValue: i(() => o.value),\n        switch: B,\n        buttonVariant: Be(Ae(a, \"buttonVariant\")),\n        form: Be(Ae(a, \"form\")),\n        name: s,\n        state: g,\n        plain: v,\n        size: Be(Ae(a, \"size\")),\n        inline: i(() => !c.value),\n        required: p,\n        buttons: u,\n        disabled: f\n      });\n      const T = i(() => a.options.map((C, w) => typeof C == \"string\" || typeof C == \"number\" ? {\n          props: {\n            value: C,\n            disabled: f.value\n          },\n          text: C.toString(),\n          html: void 0,\n          self: Symbol(`checkboxGroupOptionItem${w}`)\n        } : {\n          props: {\n            value: C[a.valueField],\n            disabled: C[a.disabledField],\n            ...(C.props ? C.props : {})\n          },\n          text: C[a.textField],\n          html: C[a.htmlField],\n          self: Symbol(`checkboxGroupOptionItem${w}`)\n        })),\n        _ = i(() => ({\n          required: p.value,\n          ariaInvalid: a.ariaInvalid,\n          state: g.value,\n          validated: m.value,\n          buttons: u.value,\n          stacked: c.value,\n          size: a.size\n        })),\n        h = ln(_),\n        k = on(_);\n      return t({\n        focus: () => {\n          b.value = !0;\n        },\n        blur: () => {\n          b.value = !1;\n        }\n      }), (C, w) => (y(), A(\"div\", ae($(h), {\n        id: $(n),\n        ref_key: \"element\",\n        ref: V,\n        role: \"group\",\n        class: [$(k), \"bv-no-focus-ring\"],\n        tabindex: \"-1\"\n      }), [O(C.$slots, \"first\"), (y(!0), A(fe, null, we(T.value, P => (y(), D(kn, ae({\n        key: P.self\n      }, P.props), {\n        default: j(() => [P.html ? (y(), A(\"span\", {\n          key: 0,\n          innerHTML: P.html\n        }, null, 8, _u)) : (y(), A(\"span\", {\n          key: 1,\n          textContent: Z(P.text)\n        }, null, 8, wu))]),\n        _: 2\n      }, 1040))), 128)), O(C.$slots, \"default\")], 16, Su));\n    }\n  }),\n  ku = [\"for\"],\n  Cu = [\"id\", \"form\", \"name\", \"multiple\", \"disabled\", \"capture\", \"accept\", \"required\", \"aria-required\", \"directory\", \"webkitdirectory\"],\n  Tu = /* @__PURE__ */H({\n    inheritAttrs: !1,\n    __name: \"BFormFile\",\n    props: {\n      accept: {\n        default: \"\"\n      },\n      autofocus: {\n        type: [String, Boolean],\n        default: !1\n      },\n      capture: {\n        type: [Boolean, String],\n        default: !1\n      },\n      directory: {\n        type: [String, Boolean],\n        default: !1\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      form: {\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      multiple: {\n        type: [String, Boolean],\n        default: !1\n      },\n      name: {\n        default: void 0\n      },\n      noDrop: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noTraverse: {\n        type: [String, Boolean],\n        default: !1\n      },\n      required: {\n        type: [String, Boolean],\n        default: !1\n      },\n      size: {\n        default: void 0\n      },\n      state: {\n        type: [String, Boolean, null],\n        default: null\n      },\n      modelValue: {\n        default: null\n      },\n      label: {\n        default: \"\"\n      },\n      labelClasses: {\n        default: void 0\n      }\n    },\n    emits: [\"update:modelValue\", \"change\"],\n    setup(e, {\n      expose: t,\n      emit: l\n    }) {\n      const a = e,\n        o = xe(),\n        n = ke(a, \"modelValue\", l),\n        s = Ve(() => a.id),\n        r = d(() => a.autofocus),\n        u = d(() => a.directory),\n        f = d(() => a.disabled),\n        v = d(() => a.multiple),\n        p = d(() => a.noDrop);\n      d(() => a.noTraverse);\n      const c = d(() => a.required),\n        g = d(() => a.state),\n        B = Tt(g),\n        m = M(null),\n        {\n          focused: V\n        } = ze(m, {\n          initialValue: r.value\n        }),\n        b = i(() => !Fe(o.label)),\n        T = i(() => typeof a.accept == \"string\" ? a.accept : a.accept.join(\",\")),\n        _ = i(() => a.capture === \"user\" || a.capture === \"environment\" ? a.capture : Ma(a.capture)),\n        h = i(() => [B.value, {\n          [`form-control-${a.size}`]: a.size !== void 0\n        }]),\n        k = P => {\n          var S, I;\n          const F = ((S = m.value) == null ? void 0 : S.files) === null || ((I = m.value) == null ? void 0 : I.files) === void 0 ? null : [...m.value.files];\n          n.value = F === null ? null : v.value === !0 ? F : F[0], l(\"change\", P);\n        },\n        C = P => {\n          p.value === !0 && P.preventDefault();\n        },\n        w = () => {\n          n.value = null;\n        };\n      return se(n, P => {\n        P === null && m.value !== null && (m.value.value = \"\");\n      }), t({\n        focus: () => {\n          V.value = !0;\n        },\n        blur: () => {\n          V.value = !1;\n        },\n        reset: w\n      }), (P, F) => (y(), A(fe, null, [b.value || P.label ? (y(), A(\"label\", {\n        key: 0,\n        for: $(s),\n        class: R([\"form-label\", P.labelClasses])\n      }, [O(P.$slots, \"label\", {}, () => [re(Z(P.label), 1)])], 10, ku)) : J(\"\", !0), Y(\"input\", ae({\n        id: $(s)\n      }, P.$attrs, {\n        ref_key: \"input\",\n        ref: m,\n        type: \"file\",\n        class: [\"form-control\", h.value],\n        form: P.form,\n        name: P.name,\n        multiple: $(v),\n        disabled: $(f),\n        capture: _.value,\n        accept: T.value || void 0,\n        required: $(c) || void 0,\n        \"aria-required\": $(c) || void 0,\n        directory: $(u),\n        webkitdirectory: $(u),\n        onChange: k,\n        onDrop: C\n      }), null, 16, Cu)], 64));\n    }\n  }),\n  Cn = [\"input\", \"select\", \"textarea\"],\n  Vu = Cn.map(e => `${e}:not([disabled])`).join(),\n  Ou = [...Cn, \"a\", \"button\", \"label\"],\n  Au = \"label\",\n  Pu = \"invalid-feedback\",\n  Eu = \"valid-feedback\",\n  Fu = \"description\",\n  Iu = \"default\",\n  xu = H({\n    components: {\n      BCol: Pt,\n      BFormInvalidFeedback: Ea,\n      BFormRow: Zt,\n      BFormText: Fa,\n      BFormValidFeedback: Ia\n    },\n    props: {\n      contentCols: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      contentColsLg: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      contentColsMd: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      contentColsSm: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      contentColsXl: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      description: {\n        type: [String],\n        default: void 0\n      },\n      disabled: {\n        type: [Boolean, String],\n        default: !1\n      },\n      feedbackAriaLive: {\n        type: String,\n        default: \"assertive\"\n      },\n      id: {\n        type: String,\n        default: void 0\n      },\n      invalidFeedback: {\n        type: String,\n        default: void 0\n      },\n      label: {\n        type: String,\n        default: void 0\n      },\n      labelAlign: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      labelAlignLg: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      labelAlignMd: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      labelAlignSm: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      labelAlignXl: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      labelClass: {\n        type: [Array, Object, String],\n        default: void 0\n      },\n      labelCols: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      labelColsLg: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      labelColsMd: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      labelColsSm: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      labelColsXl: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      labelFor: {\n        type: String,\n        default: void 0\n      },\n      labelSize: {\n        type: String,\n        default: void 0\n      },\n      labelSrOnly: {\n        type: [Boolean, String],\n        default: !1\n      },\n      state: {\n        type: [Boolean, String],\n        default: null\n      },\n      tooltip: {\n        type: [Boolean, String],\n        default: !1\n      },\n      validFeedback: {\n        type: String,\n        default: void 0\n      },\n      validated: {\n        type: [Boolean, String],\n        default: !1\n      },\n      floating: {\n        type: [Boolean, String],\n        default: !1\n      }\n    },\n    setup(e, {\n      attrs: t\n    }) {\n      const l = d(() => e.disabled),\n        a = d(() => e.labelSrOnly),\n        o = d(() => e.state),\n        n = d(() => e.tooltip),\n        s = d(() => e.validated),\n        r = d(() => e.floating),\n        u = null,\n        f = [\"xs\", \"sm\", \"md\", \"lg\", \"xl\"],\n        v = (k, C) => f.reduce((w, P) => {\n          const F = vl(P === \"xs\" ? \"\" : P, `${C}Align`),\n            S = k[F] || null;\n          return S && (P === \"xs\" ? w.push(`text-${S}`) : w.push(`text-${P}-${S}`)), w;\n        }, []),\n        p = (k, C) => f.reduce((w, P) => {\n          const F = vl(P === \"xs\" ? \"\" : P, `${C}Cols`);\n          let S = k[F];\n          return S = S === \"\" ? !0 : S || !1, typeof S != \"boolean\" && S !== \"auto\" && (S = Es(S, 0), S = S > 0 ? S : !1), S && (P === \"xs\" ? w[typeof S == \"boolean\" ? \"col\" : \"cols\"] = S : w[P || (typeof S == \"boolean\" ? \"col\" : \"cols\")] = S), w;\n        }, {}),\n        c = M(),\n        g = (k, C = null) => {\n          if (qa && e.labelFor) {\n            const w = ho(`#${fs(e.labelFor)}`, c);\n            if (w) {\n              const P = \"aria-describedby\",\n                F = (k || \"\").split(Yt),\n                S = (C || \"\").split(Yt),\n                I = (Ga(w, P) || \"\").split(Yt).filter(x => !S.includes(x)).concat(F).filter((x, z, te) => te.indexOf(x) === z).filter(x => x).join(\" \").trim();\n              I ? Vs(w, P, I) : Os(w, P);\n            }\n          }\n        },\n        B = i(() => p(e, \"content\")),\n        m = i(() => v(e, \"label\")),\n        V = i(() => p(e, \"label\")),\n        b = i(() =>\n        // Determine if the form group will be rendered horizontal\n        // based on the existence of 'content-col' or 'label-col' props\n        Object.keys(B.value).length > 0 || Object.keys(V.value).length > 0),\n        T = Tt(o),\n        _ = i(() => fa(t.ariaInvalid, o.value));\n      return se(() => u, (k, C) => {\n        k !== C && g(k, C);\n      }), qe(() => {\n        Oe(() => {\n          g(u);\n        });\n      }), {\n        disabledBoolean: l,\n        labelSrOnlyBoolean: a,\n        stateBoolean: o,\n        tooltipBoolean: n,\n        validatedBoolean: s,\n        floatingBoolean: r,\n        ariaDescribedby: u,\n        computedAriaInvalid: _,\n        contentColProps: B,\n        isHorizontal: b,\n        labelAlignClasses: m,\n        labelColProps: V,\n        onLegendClick: k => {\n          if (e.labelFor) return;\n          const {\n              target: C\n            } = k,\n            w = C ? C.tagName : \"\";\n          if (Ou.indexOf(w) !== -1) return;\n          const P = Cs(Vu, c).filter(ks);\n          P.length === 1 && ws(P[0]);\n        },\n        stateClass: T\n      };\n    },\n    render() {\n      const e = this.$props,\n        t = this.$slots,\n        l = Ve(),\n        a = !e.labelFor;\n      let o = null;\n      const n = Me(Au, {}, t) || e.label,\n        s = n ? lt(\"_BV_label_\") : null;\n      if (n || this.isHorizontal) {\n        const h = a ? \"legend\" : \"label\";\n        if (this.labelSrOnlyBoolean) n && (o = ie(h, {\n          class: \"visually-hidden\",\n          id: s,\n          for: e.labelFor || null\n        }, n)), this.isHorizontal ? o = ie(Pt, this.labelColProps, {\n          default: () => o\n        }) : o = ie(\"div\", {}, [o]);else {\n          const k = {\n            onClick: a ? this.onLegendClick : null,\n            ...(this.isHorizontal ? this.labelColProps : {}),\n            tag: this.isHorizontal ? h : null,\n            id: s,\n            for: e.labelFor || null,\n            tabIndex: a ? \"-1\" : null,\n            class: [this.isHorizontal ? \"col-form-label\" : \"form-label\", {\n              \"bv-no-focus-ring\": a,\n              \"col-form-label\": this.isHorizontal || a,\n              \"pt-0\": !this.isHorizontal && a,\n              \"d-block\": !this.isHorizontal && !a,\n              [`col-form-label-${e.labelSize}`]: !!e.labelSize\n            }, this.labelAlignClasses, e.labelClass]\n          };\n          this.isHorizontal ? o = ie(Pt, k, {\n            default: () => n\n          }) : o = ie(h, k, n);\n        }\n      }\n      let r = null;\n      const u = Me(Pu, {}, t) || this.invalidFeedback,\n        f = u ? lt(\"_BV_feedback_invalid_\") : void 0;\n      u && (r = ie(Ea, {\n        ariaLive: e.feedbackAriaLive,\n        id: f,\n        state: this.stateBoolean,\n        tooltip: this.tooltipBoolean\n      }, {\n        default: () => u\n      }));\n      let v = null;\n      const p = Me(Eu, {}, t) || this.validFeedback,\n        c = p ? lt(\"_BV_feedback_valid_\") : void 0;\n      p && (v = ie(Ia, {\n        ariaLive: e.feedbackAriaLive,\n        id: c,\n        state: this.stateBoolean,\n        tooltip: this.tooltipBoolean\n      }, {\n        default: () => p\n      }\n      // validFeedbackContent\n      ));\n\n      let g = null;\n      const B = Me(Fu, {}, t) || this.description,\n        m = B ? lt(\"_BV_description_\") : void 0;\n      B && (g = ie(Fa, {\n        id: m\n      }, {\n        default: () => B\n      }));\n      const V = this.ariaDescribedby = [m, this.stateBoolean === !1 ? f : null, this.stateBoolean === !0 ? c : null].filter(h => h).join(\" \") || null,\n        b = [Me(Iu, {\n          ariaDescribedby: V,\n          descriptionId: m,\n          id: l,\n          labelId: s\n        }, t) || \"\", r, v, g];\n      !this.isHorizontal && this.floatingBoolean && b.push(o);\n      let T = ie(\"div\", {\n        ref: \"content\",\n        class: [{\n          \"form-floating\": !this.isHorizontal && this.floatingBoolean\n        }]\n      }, b);\n      this.isHorizontal && (T = ie(Pt, {\n        ref: \"content\",\n        ...this.contentColProps\n      }, {\n        default: () => b\n      }));\n      const _ = {\n        class: [this.stateClass, {\n          \"was-validated\": this.validatedBoolean\n        }],\n        id: Ve(() => e.id).value,\n        disabled: a ? this.disabledBoolean : null,\n        role: a ? null : \"group\",\n        \"aria-invalid\": this.computedAriaInvalid,\n        // Only apply `aria-labelledby` if we are a horizontal fieldset\n        // as the legend is no longer a direct child of fieldset\n        \"aria-labelledby\": a && this.isHorizontal ? s : null\n      };\n      return this.isHorizontal && !a ? ie(Zt, _, {\n        default: () => [o, T]\n      }) : ie(a ? \"fieldset\" : \"div\", _, this.isHorizontal && a ? [ie(Zt, null, {\n        default: () => [o, T]\n      })] : this.isHorizontal || !this.floatingBoolean ? [o, T] : [T]);\n    }\n  }),\n  Lu = [\"id\", \"name\", \"form\", \"type\", \"disabled\", \"placeholder\", \"required\", \"autocomplete\", \"readonly\", \"min\", \"max\", \"step\", \"list\", \"aria-required\", \"aria-invalid\"],\n  Nu = /* @__PURE__ */H({\n    __name: \"BFormInput\",\n    props: {\n      max: {\n        default: void 0\n      },\n      min: {\n        default: void 0\n      },\n      step: {\n        default: void 0\n      },\n      type: {\n        default: \"text\"\n      },\n      ariaInvalid: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      autocomplete: {\n        default: void 0\n      },\n      autofocus: {\n        type: [String, Boolean],\n        default: !1\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      form: {\n        default: void 0\n      },\n      formatter: {\n        type: Function,\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      lazy: {\n        type: [String, Boolean],\n        default: !1\n      },\n      lazyFormatter: {\n        type: [String, Boolean],\n        default: !1\n      },\n      list: {\n        default: void 0\n      },\n      modelValue: {\n        default: \"\"\n      },\n      name: {\n        default: void 0\n      },\n      number: {\n        type: [String, Boolean],\n        default: !1\n      },\n      placeholder: {\n        default: void 0\n      },\n      plaintext: {\n        type: [String, Boolean],\n        default: !1\n      },\n      readonly: {\n        type: [String, Boolean],\n        default: !1\n      },\n      required: {\n        type: [String, Boolean],\n        default: !1\n      },\n      size: {\n        default: void 0\n      },\n      state: {\n        type: [String, Boolean, null],\n        default: null\n      },\n      trim: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    emits: [\"update:modelValue\", \"change\", \"blur\", \"input\"],\n    setup(e, {\n      expose: t,\n      emit: l\n    }) {\n      const a = e,\n        {\n          input: o,\n          computedId: n,\n          computedAriaInvalid: s,\n          onInput: r,\n          onChange: u,\n          onBlur: f,\n          focus: v,\n          blur: p\n        } = nn(a, l),\n        c = d(() => a.disabled),\n        g = d(() => a.required),\n        B = d(() => a.readonly),\n        m = d(() => a.plaintext),\n        V = d(() => a.state),\n        b = Tt(V),\n        T = M(!1),\n        _ = i(() => {\n          const h = a.type === \"range\",\n            k = a.type === \"color\";\n          return [b.value, {\n            \"form-control-highlighted\": T.value,\n            \"form-range\": h,\n            \"form-control\": k || !a.plaintext && !h,\n            \"form-control-color\": k,\n            \"form-control-plaintext\": a.plaintext && !h && !k,\n            [`form-control-${a.size}`]: !!a.size\n          }];\n        });\n      return t({\n        focus: v,\n        blur: p\n      }), (h, k) => (y(), A(\"input\", {\n        id: $(n),\n        ref_key: \"input\",\n        ref: o,\n        class: R(_.value),\n        name: h.name || void 0,\n        form: h.form || void 0,\n        type: h.type,\n        disabled: $(c),\n        placeholder: h.placeholder,\n        required: $(g) || void 0,\n        autocomplete: h.autocomplete || void 0,\n        readonly: $(B) || $(m),\n        min: h.min,\n        max: h.max,\n        step: h.step,\n        list: h.type !== \"password\" ? h.list : void 0,\n        \"aria-required\": $(g) || void 0,\n        \"aria-invalid\": $(s),\n        onInput: k[0] || (k[0] = C => $(r)(C)),\n        onChange: k[1] || (k[1] = C => $(u)(C)),\n        onBlur: k[2] || (k[2] = C => $(f)(C))\n      }, null, 42, Lu));\n    }\n  }),\n  zu = [\"id\", \"checked\", \"disabled\", \"required\", \"name\", \"form\", \"aria-label\", \"aria-labelledby\", \"value\", \"aria-required\"],\n  Hu = [\"for\"],\n  Tn = /* @__PURE__ */H({\n    inheritAttrs: !1,\n    __name: \"BFormRadio\",\n    props: {\n      ariaLabel: {\n        default: void 0\n      },\n      ariaLabelledby: {\n        default: void 0\n      },\n      form: {\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      name: {\n        default: void 0\n      },\n      size: {\n        default: void 0\n      },\n      autofocus: {\n        type: [String, Boolean],\n        default: !1\n      },\n      modelValue: {\n        type: [Boolean, String, Array, Object, Number, null],\n        default: void 0\n      },\n      plain: {\n        type: [String, Boolean],\n        default: !1\n      },\n      button: {\n        type: [String, Boolean],\n        default: !1\n      },\n      buttonGroup: {\n        type: [String, Boolean],\n        default: !1\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      buttonVariant: {\n        default: null\n      },\n      inline: {\n        type: [String, Boolean],\n        default: !1\n      },\n      required: {\n        type: [String, Boolean],\n        default: !1\n      },\n      state: {\n        type: [String, Boolean, null],\n        default: null\n      },\n      value: {\n        type: [String, Boolean, Object, Number],\n        default: !0\n      }\n    },\n    emits: [\"input\", \"change\", \"update:modelValue\"],\n    setup(e, {\n      expose: t,\n      emit: l\n    }) {\n      const a = e,\n        o = xe(),\n        n = ke(a, \"modelValue\", l, {\n          passive: !0\n        }),\n        s = Ve(() => a.id, \"form-check\"),\n        r = d(() => a.autofocus),\n        u = d(() => a.plain),\n        f = d(() => a.button),\n        v = d(() => a.buttonGroup),\n        p = d(() => a.disabled),\n        c = d(() => a.inline),\n        g = d(() => a.required),\n        B = d(() => a.state),\n        m = Ie(Oo, null),\n        V = M(null),\n        {\n          focused: b\n        } = ze(V, {\n          initialValue: r.value\n        }),\n        T = i(() => !Fe(o.default)),\n        _ = i({\n          get: () => m !== null ? JSON.stringify(m.modelValue.value) === JSON.stringify(a.value) : JSON.stringify(n.value) === JSON.stringify(a.value),\n          set: S => {\n            const I = S || S === \"\" || S === 0 ? a.value : !1;\n            l(\"input\", I), n.value = I, Oe(() => {\n              l(\"change\", I);\n            });\n          }\n        });\n      se(() => m == null ? void 0 : m.modelValue.value, S => {\n        JSON.stringify(S) === JSON.stringify(a.value) !== !0 && (_.value = !1);\n      }), se(n, S => {\n        m === null || S === !1 || m.set(a.value);\n      });\n      const h = i(() => !!(a.name ?? (m == null ? void 0 : m.name.value)) && (g.value || (m == null ? void 0 : m.required.value))),\n        k = i(() => v.value || ((m == null ? void 0 : m.buttons.value) ?? !1)),\n        C = i(() => ({\n          plain: u.value || ((m == null ? void 0 : m.plain.value) ?? !1),\n          button: f.value || ((m == null ? void 0 : m.buttons.value) ?? !1),\n          inline: c.value || ((m == null ? void 0 : m.inline.value) ?? !1),\n          state: B.value || (m == null ? void 0 : m.state.value),\n          size: a.size !== void 0 ? a.size : (m == null ? void 0 : m.size.value) ?? \"md\",\n          // This is where the true default is made\n          buttonVariant: a.buttonVariant !== null ? a.buttonVariant : (m == null ? void 0 : m.buttonVariant.value) ?? \"secondary\"\n          // This is where the true default is made\n        })),\n        w = en(C),\n        P = tn(C),\n        F = an(C);\n      return t({\n        focus: () => {\n          b.value = !0;\n        },\n        blur: () => {\n          b.value = !1;\n        }\n      }), (S, I) => (y(), D(Qa, {\n        skip: k.value,\n        class: R($(w))\n      }, {\n        default: j(() => {\n          var x, z, te;\n          return [rt(Y(\"input\", ae({\n            id: $(s)\n          }, S.$attrs, {\n            ref_key: \"input\",\n            ref: V,\n            \"onUpdate:modelValue\": I[0] || (I[0] = Q => _.value = Q),\n            checked: _.value,\n            class: $(P),\n            type: \"radio\",\n            disabled: $(p) || ((x = $(m)) == null ? void 0 : x.disabled.value),\n            required: h.value || void 0,\n            name: S.name || ((z = $(m)) == null ? void 0 : z.name.value),\n            form: S.form || ((te = $(m)) == null ? void 0 : te.form.value),\n            \"aria-label\": S.ariaLabel,\n            \"aria-labelledby\": S.ariaLabelledby,\n            value: S.value,\n            \"aria-required\": h.value || void 0\n          }), null, 16, zu), [[Zn, _.value]]), T.value || $(u) === !1 ? (y(), A(\"label\", {\n            key: 0,\n            for: $(s),\n            class: R($(F))\n          }, [O(S.$slots, \"default\")], 10, Hu)) : J(\"\", !0)];\n        }),\n        _: 3\n      }, 8, [\"skip\", \"class\"]));\n    }\n  }),\n  Ru = [\"id\"],\n  Mu = [\"innerHTML\"],\n  Du = [\"textContent\"],\n  ju = /* @__PURE__ */H({\n    __name: \"BFormRadioGroup\",\n    props: {\n      size: {\n        default: \"md\"\n      },\n      form: {\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      name: {\n        default: void 0\n      },\n      modelValue: {\n        type: [String, Boolean, Array, Object, Number, null],\n        default: null\n      },\n      ariaInvalid: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      autofocus: {\n        type: [String, Boolean],\n        default: !1\n      },\n      buttonVariant: {\n        default: \"secondary\"\n      },\n      buttons: {\n        type: [String, Boolean],\n        default: !1\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      disabledField: {\n        default: \"disabled\"\n      },\n      htmlField: {\n        default: \"html\"\n      },\n      options: {\n        default: () => []\n      },\n      plain: {\n        type: [String, Boolean],\n        default: !1\n      },\n      required: {\n        type: [String, Boolean],\n        default: !1\n      },\n      stacked: {\n        type: [String, Boolean],\n        default: !1\n      },\n      state: {\n        type: [String, Boolean, null],\n        default: null\n      },\n      textField: {\n        default: \"text\"\n      },\n      validated: {\n        type: [String, Boolean],\n        default: !1\n      },\n      valueField: {\n        default: \"value\"\n      }\n    },\n    emits: [\"input\", \"update:modelValue\", \"change\"],\n    setup(e, {\n      expose: t,\n      emit: l\n    }) {\n      const a = e,\n        o = ke(a, \"modelValue\", l),\n        n = Ve(() => a.id, \"radio\"),\n        s = Ve(() => a.name, \"checkbox\"),\n        r = d(() => a.autofocus),\n        u = d(() => a.buttons),\n        f = d(() => a.disabled),\n        v = d(() => a.plain),\n        p = d(() => a.required),\n        c = d(() => a.stacked),\n        g = d(() => a.state),\n        B = d(() => a.validated),\n        m = M(null),\n        {\n          focused: V\n        } = ze(m, {\n          initialValue: r.value\n        });\n      Ke(Oo, {\n        set: k => {\n          l(\"input\", k), o.value = k, Oe(() => {\n            l(\"change\", k);\n          });\n        },\n        modelValue: i(() => o.value),\n        buttonVariant: Be(Ae(a, \"buttonVariant\")),\n        form: Be(Ae(a, \"form\")),\n        name: s,\n        buttons: u,\n        state: g,\n        plain: v,\n        size: Be(Ae(a, \"size\")),\n        inline: i(() => !c.value),\n        required: p,\n        disabled: f\n      });\n      const b = i(() => a.options.map((k, C) => typeof k == \"string\" || typeof k == \"number\" ? {\n          props: {\n            value: k,\n            disabled: f.value\n          },\n          text: k.toString(),\n          html: void 0,\n          self: Symbol(`radioGroupOptionItem${C}`)\n        } : {\n          props: {\n            value: k[a.valueField],\n            disabled: k[a.disabledField],\n            ...(k.props ? k.props : {})\n          },\n          text: k[a.textField],\n          html: k[a.htmlField],\n          self: Symbol(`radioGroupOptionItem${C}`)\n        })),\n        T = i(() => ({\n          required: p.value,\n          ariaInvalid: a.ariaInvalid,\n          state: g.value,\n          validated: B.value,\n          buttons: u.value,\n          stacked: c.value,\n          size: a.size\n        })),\n        _ = ln(T),\n        h = on(T);\n      return t({\n        focus: () => {\n          V.value = !0;\n        },\n        blur: () => {\n          V.value = !1;\n        }\n      }), (k, C) => (y(), A(\"div\", ae($(_), {\n        id: $(n),\n        ref_key: \"element\",\n        ref: m,\n        role: \"radiogroup\",\n        class: [$(h), \"bv-no-focus-ring\"],\n        tabindex: \"-1\"\n      }), [O(k.$slots, \"first\"), (y(!0), A(fe, null, we(b.value, w => (y(), D(Tn, ae({\n        key: w.self\n      }, w.props), {\n        default: j(() => [w.html ? (y(), A(\"span\", {\n          key: 0,\n          innerHTML: w.html\n        }, null, 8, Mu)) : (y(), A(\"span\", {\n          key: 1,\n          textContent: Z(w.text)\n        }, null, 8, Du))]),\n        _: 2\n      }, 1040))), 128)), O(k.$slots, \"default\")], 16, Ru));\n    }\n  }),\n  qu = [\"value\", \"disabled\"],\n  ol = /* @__PURE__ */H({\n    __name: \"BFormSelectOption\",\n    props: {\n      value: {\n        default: void 0\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = d(() => t.disabled);\n      return (a, o) => (y(), A(\"option\", {\n        value: a.value,\n        disabled: $(l)\n      }, [O(a.$slots, \"default\")], 8, qu));\n    }\n  }),\n  Gu = [\"label\"],\n  Vn = /* @__PURE__ */H({\n    __name: \"BFormSelectOptionGroup\",\n    props: {\n      label: {\n        default: void 0\n      },\n      disabledField: {\n        default: \"disabled\"\n      },\n      htmlField: {\n        default: \"html\"\n      },\n      options: {\n        default: () => []\n      },\n      textField: {\n        default: \"text\"\n      },\n      valueField: {\n        default: \"value\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = i(() => el(t.options, \"BFormSelectOptionGroup\", t));\n      return (a, o) => (y(), A(\"optgroup\", {\n        label: a.label\n      }, [O(a.$slots, \"first\"), (y(!0), A(fe, null, we(l.value, (n, s) => (y(), D(ol, ae({\n        key: s,\n        value: n.value,\n        disabled: n.disabled\n      }, a.$attrs, {\n        innerHTML: n.html || n.text\n      }), null, 16, [\"value\", \"disabled\", \"innerHTML\"]))), 128)), O(a.$slots, \"default\")], 8, Gu));\n    }\n  }),\n  Wu = [\"id\", \"name\", \"form\", \"multiple\", \"size\", \"disabled\", \"required\", \"aria-required\", \"aria-invalid\"],\n  Uu = /* @__PURE__ */H({\n    __name: \"BFormSelect\",\n    props: {\n      ariaInvalid: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      autofocus: {\n        type: [String, Boolean],\n        default: !1\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      disabledField: {\n        default: \"disabled\"\n      },\n      form: {\n        default: void 0\n      },\n      htmlField: {\n        default: \"html\"\n      },\n      id: {\n        default: void 0\n      },\n      labelField: {\n        default: \"label\"\n      },\n      multiple: {\n        type: [String, Boolean],\n        default: !1\n      },\n      name: {\n        default: void 0\n      },\n      options: {\n        default: () => []\n      },\n      optionsField: {\n        default: \"options\"\n      },\n      plain: {\n        type: [String, Boolean],\n        default: !1\n      },\n      required: {\n        type: [String, Boolean],\n        default: !1\n      },\n      selectSize: {\n        default: 0\n      },\n      size: {\n        default: \"md\"\n      },\n      state: {\n        type: [String, Boolean, null],\n        default: null\n      },\n      textField: {\n        default: \"text\"\n      },\n      valueField: {\n        default: \"value\"\n      },\n      modelValue: {\n        default: \"\"\n      }\n    },\n    emits: [\"input\", \"update:modelValue\", \"change\"],\n    setup(e, {\n      expose: t,\n      emit: l\n    }) {\n      const a = e,\n        o = ke(a, \"modelValue\", l),\n        n = Ve(() => a.id, \"input\"),\n        s = d(() => a.autofocus),\n        r = d(() => a.disabled),\n        u = d(() => a.multiple),\n        f = d(() => a.plain),\n        v = d(() => a.required),\n        p = d(() => a.state),\n        c = Tt(p),\n        g = M(),\n        {\n          focused: B\n        } = ze(g, {\n          initialValue: s.value\n        }),\n        m = i(() => [c.value, {\n          \"form-control\": f.value,\n          [`form-control-${a.size}`]: a.size !== \"md\" && f.value,\n          \"form-select\": !f.value,\n          [`form-select-${a.size}`]: a.size !== \"md\" && !f.value\n        }]),\n        V = i(() => a.selectSize || f.value ? a.selectSize : void 0),\n        b = i(() => fa(a.ariaInvalid, p.value)),\n        T = i(() => el(a.options, \"BFormSelect\", a)),\n        _ = i({\n          get: () => o.value,\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          set: h => {\n            l(\"input\", h), o.value = h, Oe(() => {\n              l(\"change\", h);\n            });\n          }\n        });\n      return t({\n        focus: () => {\n          B.value = !0;\n        },\n        blur: () => {\n          B.value = !1;\n        }\n      }), (h, k) => rt((y(), A(\"select\", ae({\n        id: $(n),\n        ref_key: \"input\",\n        ref: g\n      }, h.$attrs, {\n        \"onUpdate:modelValue\": k[0] || (k[0] = C => _.value = C),\n        class: m.value,\n        name: h.name,\n        form: h.form || void 0,\n        multiple: $(u) || void 0,\n        size: V.value,\n        disabled: $(r),\n        required: $(v) || void 0,\n        \"aria-required\": $(v) || void 0,\n        \"aria-invalid\": b.value\n      }), [O(h.$slots, \"first\"), (y(!0), A(fe, null, we(T.value, (C, w) => (y(), A(fe, {\n        key: w\n      }, [Array.isArray(C.options) ? (y(), D(Vn, {\n        key: 0,\n        label: C.label,\n        options: C.options\n      }, null, 8, [\"label\", \"options\"])) : (y(), D(ol, {\n        key: 1,\n        value: C.value,\n        disabled: C.disabled,\n        innerHTML: C.html || C.text\n      }, null, 8, [\"value\", \"disabled\", \"innerHTML\"]))], 64))), 128)), O(h.$slots, \"default\")], 16, Wu)), [[Qn, _.value]]);\n    }\n  }),\n  ql = [\"ar\", \"az\", \"ckb\", \"fa\", \"he\", \"ks\", \"lrc\", \"mzn\", \"ps\", \"sd\", \"te\", \"ug\", \"ur\", \"yi\"].map(e => e.toLowerCase()),\n  Ku = e => {\n    const t = Qt(e).toLowerCase().replace(ss, \"\").split(\"-\"),\n      l = t.slice(0, 2).join(\"-\"),\n      [a] = t;\n    return ql.includes(l) || ql.includes(a);\n  },\n  Xu = e => bs ? Sa(e) ? e : {\n    capture: !!e || !1\n  } : !!(Sa(e) ? e.capture : e),\n  Yu = (e, t, l, a) => {\n    e && e.addEventListener && e.addEventListener(t, l, Xu(a));\n  },\n  Ju = (e, t, l, a) => {\n    e && e.removeEventListener && e.removeEventListener(t, l, a);\n  },\n  Gl = (e, t) => {\n    (e ? Yu : Ju)(...t);\n  },\n  Kt = (e, {\n    preventDefault: t = !0,\n    propagation: l = !0,\n    immediatePropagation: a = !1\n  } = {}) => {\n    t && e.preventDefault(), l && e.stopPropagation(), a && e.stopImmediatePropagation();\n  },\n  xa = \"ArrowDown\",\n  On = \"End\",\n  An = \"Home\",\n  Pn = \"PageDown\",\n  En = \"PageUp\",\n  La = \"ArrowUp\",\n  Wl = 1,\n  Ul = 100,\n  Kl = 1,\n  Xl = 500,\n  Yl = 100,\n  Jl = 10,\n  Zl = 4,\n  Ql = [La, xa, An, On, En, Pn],\n  Zu = H({\n    props: {\n      ariaControls: {\n        type: String,\n        default: void 0\n      },\n      ariaLabel: {\n        type: String,\n        default: void 0\n      },\n      labelIncrement: {\n        type: String,\n        default: \"Increment\"\n      },\n      labelDecrement: {\n        type: String,\n        default: \"Decrement\"\n      },\n      modelValue: {\n        type: Number,\n        default: null\n      },\n      // V-model prop\n      name: {\n        type: String,\n        default: \"BFormSpinButton\"\n      },\n      disabled: {\n        type: [Boolean, String],\n        default: !1\n      },\n      placeholder: {\n        type: String,\n        default: void 0\n      },\n      locale: {\n        type: String,\n        default: \"locale\"\n      },\n      form: {\n        type: String,\n        default: void 0\n      },\n      inline: {\n        type: Boolean,\n        default: !1\n      },\n      size: {\n        type: String,\n        default: void 0\n      },\n      formatterFn: {\n        type: Function,\n        default: void 0\n      },\n      readonly: {\n        type: Boolean,\n        default: !1\n      },\n      vertical: {\n        type: Boolean,\n        default: !1\n      },\n      repeatDelay: {\n        type: [String, Number],\n        default: Xl\n      },\n      repeatInterval: {\n        type: [String, Number],\n        default: Yl\n      },\n      repeatStepMultiplier: {\n        type: [String, Number],\n        default: Zl\n      },\n      repeatThreshold: {\n        type: [String, Number],\n        default: Jl\n      },\n      required: {\n        type: [Boolean, String],\n        default: !1\n      },\n      step: {\n        type: [String, Number],\n        default: Kl\n      },\n      min: {\n        type: [String, Number],\n        default: Wl\n      },\n      max: {\n        type: [String, Number],\n        default: Ul\n      },\n      wrap: {\n        type: Boolean,\n        default: !1\n      },\n      state: {\n        type: [Boolean, String],\n        default: null\n      }\n    },\n    emits: [\"update:modelValue\", \"change\"],\n    setup(e, {\n      emit: t\n    }) {\n      const l = ke(e, \"modelValue\", t),\n        a = M(!1),\n        o = i(() => 1),\n        n = () => {\n          t(\"change\", r.value);\n        },\n        s = M(null),\n        r = i({\n          get: () => l.value === null ? s.value : l.value,\n          set: q => {\n            l.value === null ? s.value = q : l.value = q;\n          }\n        });\n      let u,\n        f,\n        v = !1;\n      const p = i(() => Et(e.step, Kl)),\n        c = i(() => Et(e.min, Wl)),\n        g = i(() => {\n          const q = Et(e.max, Ul),\n            ee = p.value,\n            ne = c.value;\n          return Math.floor((q - ne) / ee) * ee + ne;\n        }),\n        B = i(() => {\n          const q = ot(e.repeatDelay, 0);\n          return q > 0 ? q : Xl;\n        }),\n        m = i(() => {\n          const q = ot(e.repeatInterval, 0);\n          return q > 0 ? q : Yl;\n        }),\n        V = i(() => Math.max(ot(e.repeatThreshold, Jl), 1)),\n        b = i(() => Math.max(ot(e.repeatStepMultiplier, Zl), 1)),\n        T = i(() => {\n          const q = p.value;\n          return Math.floor(q) === q ? 0 : (q.toString().split(\".\")[1] || \"\").length;\n        }),\n        _ = i(() => Math.pow(10, T.value || 0)),\n        h = i(() => {\n          const {\n            value: q\n          } = r;\n          return q === null ? \"\" : q.toFixed(T.value);\n        }),\n        k = i(() => {\n          const q = [e.locale];\n          return new Intl.NumberFormat(q).resolvedOptions().locale;\n        }),\n        C = i(() =>\n        //todo\n        Ku(k.value)),\n        w = () => {\n          const q = T.value;\n          return new Intl.NumberFormat(k.value, {\n            style: \"decimal\",\n            useGrouping: !1,\n            minimumIntegerDigits: 1,\n            minimumFractionDigits: q,\n            maximumFractionDigits: q,\n            notation: \"standard\"\n          }).format;\n        },\n        P = i(() => e.formatterFn ?? w()),\n        F = i(() => ({\n          role: \"group\",\n          lang: k.value,\n          tabindex: e.disabled ? null : \"-1\",\n          title: e.ariaLabel\n        })),\n        S = i(() => l.value !== null || s.value !== null),\n        I = i(() => ({\n          dir: C.value,\n          spinId: o.value,\n          tabindex: e.disabled ? null : \"0\",\n          role: \"spinbutton\",\n          \"aria-live\": \"off\",\n          \"aria-label\": e.ariaLabel || null,\n          \"aria-controls\": e.ariaControls || null,\n          \"aria-invalid\": e.state === !1 || !S.value && e.required ? !0 : null,\n          \"aria-required\": e.required ? !0 : null,\n          \"aria-valuemin\": c.value,\n          \"aria-valuemax\": g.value,\n          \"aria-valuenow\": r.value !== null ? r.value : null,\n          \"aria-valuetext\": r.value !== null ? P.value(r.value) : null\n        })),\n        x = q => {\n          let {\n            value: ee\n          } = r;\n          if (!e.disabled && ee !== null) {\n            const ne = p.value * q,\n              ue = c.value,\n              N = g.value,\n              le = _.value,\n              {\n                wrap: de\n              } = e;\n            ee = Math.round((ee - ue) / ne) * ne + ue + ne, ee = Math.round(ee * le) / le, r.value = ee > N ? de ? ue : N : ee < ue ? de ? N : ue : ee;\n          }\n        },\n        z = (q = 1) => {\n          r.value === null ? r.value = c.value : x(1 * q);\n        },\n        te = (q = 1) => {\n          r.value === null ? r.value = e.wrap ? g.value : c.value : x(-1 * q);\n        },\n        Q = q => {\n          const {\n            code: ee,\n            altKey: ne,\n            ctrlKey: ue,\n            metaKey: N\n          } = q;\n          if (!(e.disabled || e.readonly || ne || ue || N) && Ql.includes(ee)) {\n            if (Kt(q, {\n              propagation: !1\n            }), v) return;\n            he(), [La, xa].includes(ee) ? (v = !0, ee === La ? X(q, z) : ee === xa && X(q, te)) : ee === En ? z(b.value) : ee === Pn ? te(b.value) : ee === An ? r.value = c.value : ee === On && (r.value = g.value);\n          }\n        },\n        G = q => {\n          const {\n            code: ee,\n            altKey: ne,\n            ctrlKey: ue,\n            metaKey: N\n          } = q;\n          e.disabled || e.readonly || ne || ue || N || Ql.includes(ee) && (Kt(q, {\n            propagation: !1\n          }), he(), v = !1, n());\n        },\n        X = (q, ee) => {\n          const {\n            type: ne\n          } = q || {};\n          if (!e.disabled && !e.readonly) {\n            if (U(q) && ne === \"mousedown\" && q.button) return;\n            he(), ee(1);\n            const ue = V.value,\n              N = b.value,\n              le = B.value,\n              de = m.value;\n            u = setTimeout(() => {\n              let Se = 0;\n              f = setInterval(() => {\n                ee(Se < ue ? 1 : N), Se++;\n              }, de);\n            }, le);\n          }\n        };\n      function U(q) {\n        return q.type === \"mouseup\" || q.type === \"mousedown\";\n      }\n      const pe = q => {\n          U(q) && q.type === \"mouseup\" && q.button || (Kt(q, {\n            propagation: !1\n          }), he(), be(!1), n());\n        },\n        be = q => {\n          try {\n            Gl(q, [document.body, \"mouseup\", pe, !1]), Gl(q, [document.body, \"touchend\", pe, !1]);\n          } catch {\n            return 0;\n          }\n        },\n        he = () => {\n          clearTimeout(u), clearInterval(f), u = void 0, f = void 0;\n        },\n        ye = (q, ee, ne, ue, N, le, de) => {\n          const Se = ie(ne, {\n              props: {\n                scale: a.value ? 1.5 : 1.25\n              },\n              attrs: {\n                \"aria-hidden\": !0\n              }\n            }),\n            Ce = {\n              hasFocus: a.value\n            },\n            K = ce => {\n              !e.disabled && !e.readonly && (Kt(ce, {\n                propagation: !1\n              }), be(!0), X(ce, q));\n            };\n          return ie(\"button\", {\n            class: [{\n              \"py-0\": !e.vertical\n            }, \"btn\", \"btn-sm\", \"border-0\", \"rounded-0\"],\n            tabindex: \"-1\",\n            type: \"button\",\n            disabled: e.disabled || e.readonly || le,\n            \"aria-disabled\": e.disabled || e.readonly || le ? !0 : null,\n            \"aria-controls\": o.value,\n            \"aria-label\": ee || null,\n            \"aria-keyshortcuts\": N || null,\n            onmousedown: K,\n            ontouchstart: K\n            // 'ref': keyRef,\n          }, [Me(de, Ce) || Se]);\n        };\n      return () => {\n        const q = ye(z, e.labelIncrement, ie(\"svg\", {\n            xmlns: \"http://www.w3.org/2000/svg\",\n            width: \"16\",\n            height: \"16\",\n            fill: \"currentColor\",\n            class: \"bi bi-plus\",\n            viewBox: \"0 0 16 16\"\n          }, ie(\"path\", {\n            d: \"M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z\"\n          })), \"inc\", \"ArrowUp\", !1, \"increment\"),\n          ee = ye(te, e.labelDecrement, ie(\"svg\", {\n            xmlns: \"http://www.w3.org/2000/svg\",\n            width: \"16\",\n            height: \"16\",\n            fill: \"currentColor\",\n            class: \"bi bi-dash\",\n            viewBox: \"0 0 16 16\"\n          }, ie(\"path\", {\n            d: \"M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z\"\n          })), \"dec\", \"ArrowDown\", !1, \"decrement\"),\n          ne = [];\n        e.name && !e.disabled && ne.push(ie(\"input\", {\n          type: \"hidden\",\n          name: e.name,\n          form: e.form || null,\n          // TODO: Should this be set to '' if value is out of range?\n          value: h.value,\n          key: \"hidden\"\n        }));\n        const ue = ie(\n        // We use 'output' element to make this accept a `<label for=\"id\">` (Except IE)\n        \"output\", {\n          class: [{\n            \"d-flex\": e.vertical\n          }, {\n            \"align-self-center\": !e.vertical\n          }, {\n            \"align-items-center\": e.vertical\n          }, {\n            \"border-top\": e.vertical\n          }, {\n            \"border-bottom\": e.vertical\n          }, {\n            \"border-start\": !e.vertical\n          }, {\n            \"border-end\": !e.vertical\n          }, \"flex-grow-1\"],\n          ...I.value,\n          key: \"output\"\n          // ref: 'spinner',\n        }, [ie(\"bdi\",\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        //@ts-ignore How can we narrow this type down\n        S.value ? P.value(r.value) : e.placeholder || \"\")]);\n        return ie(\"div\", {\n          class: [\"b-form-spinbutton form-control\", {\n            disabled: e.disabled\n          }, {\n            readonly: e.readonly\n          }, {\n            focus: a\n          }, {\n            \"d-inline-flex\": e.inline || e.vertical\n          }, {\n            \"d-flex\": !e.inline && !e.vertical\n          }, {\n            \"align-items-stretch\": !e.vertical\n          }, {\n            \"flex-column\": e.vertical\n          }, e.size ? `form-control-${e.size}` : null\n          // this.stateClass //TODO\n          ],\n\n          ...F.value,\n          onkeydown: Q,\n          onkeyup: G\n          // We use capture phase (`!` prefix) since focus and blur do not bubble\n          // 'focus': onFocusBlur, //TODO\n          // 'blur': onFocusBlur, //TODO\n        }, e.vertical ? [q, ne, ue, ee] : [ee, ne, ue, q]);\n      };\n    }\n  }),\n  Qu = [\"id\"],\n  Fn = /* @__PURE__ */H({\n    __name: \"BFormTag\",\n    props: {\n      id: {\n        default: void 0\n      },\n      title: {\n        default: void 0\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noRemove: {\n        type: [String, Boolean],\n        default: !1\n      },\n      pill: {\n        type: [String, Boolean],\n        default: !1\n      },\n      removeLabel: {\n        default: \"Remove tag\"\n      },\n      tag: {\n        default: \"span\"\n      },\n      variant: {\n        default: \"secondary\"\n      }\n    },\n    emits: [\"remove\"],\n    setup(e, {\n      emit: t\n    }) {\n      const l = e,\n        a = xe(),\n        o = Ve(() => l.id),\n        n = d(() => l.disabled),\n        s = d(() => l.noRemove),\n        r = d(() => l.pill),\n        u = i(() => {\n          var p;\n          return ((((p = a.default) == null ? void 0 : p.call(a)[0].children) ?? \"\").toString() || l.title) ?? \"\";\n        }),\n        f = i(() => `${o.value}taglabel__`),\n        v = i(() => ({\n          [`bg-${l.variant}`]: l.variant !== null,\n          \"text-dark\": l.variant !== null && [\"warning\", \"info\", \"light\"].includes(l.variant),\n          \"rounded-pill\": r.value,\n          disabled: n.value\n        }));\n      return (p, c) => (y(), D(oe(p.tag), {\n        id: $(o),\n        title: u.value,\n        class: R([\"badge b-form-tag d-inline-flex align-items-center mw-100\", v.value]),\n        \"aria-labelledby\": f.value\n      }, {\n        default: j(() => [Y(\"span\", {\n          id: f.value,\n          class: \"b-form-tag-content flex-grow-1 text-truncate\"\n        }, [O(p.$slots, \"default\", {}, () => [re(Z(u.value), 1)])], 8, Qu), !$(n) && !$(s) ? (y(), D(Ot, {\n          key: 0,\n          \"aria-keyshortcuts\": \"Delete\",\n          \"aria-label\": p.removeLabel,\n          class: \"b-form-tag-remove\",\n          white: p.variant !== null && ![\"warning\", \"info\", \"light\"].includes(p.variant),\n          \"aria-describedby\": f.value,\n          \"aria-controls\": p.id,\n          onClick: c[0] || (c[0] = g => t(\"remove\", u.value))\n        }, null, 8, [\"aria-label\", \"white\", \"aria-describedby\", \"aria-controls\"])) : J(\"\", !0)]),\n        _: 3\n      }, 8, [\"id\", \"title\", \"class\", \"aria-labelledby\"]));\n    }\n  }),\n  ed = [\"id\"],\n  td = [\"id\", \"for\", \"aria-live\"],\n  ad = [\"id\", \"aria-live\"],\n  ld = [\"id\"],\n  od = [\"aria-controls\"],\n  nd = {\n    role: \"group\",\n    class: \"d-flex\"\n  },\n  sd = [\"id\", \"disabled\", \"value\", \"type\", \"placeholder\", \"form\", \"required\", \"aria-required\"],\n  rd = [\"disabled\"],\n  id = {\n    \"aria-live\": \"polite\",\n    \"aria-atomic\": \"true\"\n  },\n  ud = {\n    key: 0,\n    class: \"d-block invalid-feedback\"\n  },\n  dd = {\n    key: 1,\n    class: \"form-text text-muted\"\n  },\n  cd = {\n    key: 2,\n    class: \"form-text text-muted\"\n  },\n  fd = [\"name\", \"value\"],\n  vd = /* @__PURE__ */H({\n    __name: \"BFormTags\",\n    props: {\n      addButtonText: {\n        default: \"Add\"\n      },\n      addButtonVariant: {\n        default: \"outline-secondary\"\n      },\n      addOnChange: {\n        type: [String, Boolean],\n        default: !1\n      },\n      autofocus: {\n        type: [String, Boolean],\n        default: !1\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      duplicateTagText: {\n        default: \"Duplicate tag(s)\"\n      },\n      inputAttrs: {\n        default: void 0\n      },\n      inputClass: {\n        default: void 0\n      },\n      inputId: {\n        default: void 0\n      },\n      inputType: {\n        default: \"text\"\n      },\n      invalidTagText: {\n        default: \"Invalid tag(s)\"\n      },\n      form: {\n        default: void 0\n      },\n      limit: {\n        default: void 0\n      },\n      limitTagsText: {\n        default: \"Tag limit reached\"\n      },\n      modelValue: {\n        default: () => []\n      },\n      name: {\n        default: void 0\n      },\n      noAddOnEnter: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noOuterFocus: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noTagRemove: {\n        type: [String, Boolean],\n        default: !1\n      },\n      placeholder: {\n        default: \"Add tag...\"\n      },\n      removeOnDelete: {\n        type: [String, Boolean],\n        default: !1\n      },\n      required: {\n        type: [String, Boolean],\n        default: !1\n      },\n      separator: {\n        default: void 0\n      },\n      state: {\n        type: [String, Boolean, null],\n        default: null\n      },\n      size: {\n        default: \"md\"\n      },\n      tagClass: {\n        default: void 0\n      },\n      tagPills: {\n        type: [String, Boolean],\n        default: !1\n      },\n      tagRemoveLabel: {\n        default: void 0\n      },\n      tagRemovedLabel: {\n        default: \"Tag removed\"\n      },\n      tagValidator: {\n        type: Function,\n        default: () => !0\n      },\n      tagVariant: {\n        default: \"secondary\"\n      }\n    },\n    emits: [\"update:modelValue\", \"input\", \"tag-state\", \"focus\", \"focusin\", \"focusout\", \"blur\"],\n    setup(e, {\n      expose: t,\n      emit: l\n    }) {\n      const a = e,\n        o = ke(a, \"modelValue\", l),\n        n = Ve(),\n        s = d(() => a.addOnChange),\n        r = d(() => a.autofocus),\n        u = d(() => a.disabled),\n        f = d(() => a.noAddOnEnter),\n        v = d(() => a.noOuterFocus),\n        p = d(() => a.noTagRemove),\n        c = d(() => a.removeOnDelete),\n        g = d(() => a.required),\n        B = d(() => a.state),\n        m = d(() => a.tagPills),\n        V = Tt(B),\n        b = M(null),\n        {\n          focused: T\n        } = ze(b, {\n          initialValue: r.value\n        }),\n        _ = i(() => a.inputId || `${n.value}input__`),\n        h = M(o.value),\n        k = M(\"\"),\n        C = M(o.value.length > 0),\n        w = M(\"\"),\n        P = M([]),\n        F = M([]),\n        S = M([]),\n        I = i(() => [V.value, {\n          [`form-control-${a.size}`]: a.size !== \"md\",\n          disabled: u.value,\n          focus: T.value\n        }]),\n        x = i(() => h.value.includes(k.value)),\n        z = i(() => k.value === \"\" ? !1 : !a.tagValidator(k.value)),\n        te = i(() => h.value.length === a.limit),\n        Q = i(() => !z.value && !x.value),\n        G = i(() => ({\n          addButtonText: a.addButtonText,\n          addButtonVariant: a.addButtonVariant,\n          addTag: ne,\n          disableAddButton: Q.value,\n          disabled: u.value,\n          duplicateTagText: a.duplicateTagText,\n          duplicateTags: S.value,\n          form: a.form,\n          inputAttrs: {\n            ...a.inputAttrs,\n            disabled: u.value,\n            form: a.form,\n            id: _,\n            value: k\n          },\n          inputHandlers: {\n            input: be,\n            keydown: ye,\n            change: he\n          },\n          inputId: _,\n          inputType: a.inputType,\n          invalidTagText: a.invalidTagText,\n          invalidTags: F.value,\n          isDuplicate: x.value,\n          isInvalid: z.value,\n          isLimitReached: te.value,\n          limitTagsText: a.limitTagsText,\n          limit: a.limit,\n          noTagRemove: p.value,\n          placeholder: a.placeholder,\n          removeTag: ue,\n          required: g.value,\n          separator: a.separator,\n          size: a.size,\n          state: B.value,\n          tagClass: a.tagClass,\n          tagPills: m.value,\n          tagRemoveLabel: a.tagRemoveLabel,\n          tagVariant: a.tagVariant,\n          tags: h.value\n        }));\n      se(o, N => {\n        h.value = N;\n      });\n      const X = N => {\n          if (u.value) {\n            N.target.blur();\n            return;\n          }\n          l(\"focusin\", N);\n        },\n        U = N => {\n          u.value || v.value || (T.value = !0, l(\"focus\", N));\n        },\n        pe = N => {\n          T.value = !1, l(\"blur\", N);\n        },\n        be = N => {\n          var de, Se;\n          const le = typeof N == \"string\" ? N : N.target.value;\n          if (C.value = !1, (de = a.separator) != null && de.includes(le.charAt(0)) && le.length > 0) {\n            b.value && (b.value.value = \"\");\n            return;\n          }\n          if (k.value = le, (Se = a.separator) != null && Se.includes(le.charAt(le.length - 1))) {\n            ne(le.slice(0, le.length - 1));\n            return;\n          }\n          P.value = a.tagValidator(le) && !x.value ? [le] : [], F.value = a.tagValidator(le) ? [] : [le], S.value = x.value ? [le] : [], l(\"tag-state\", P.value, F.value, S.value);\n        },\n        he = N => {\n          s.value && (be(N), x.value || ne(k.value));\n        },\n        ye = N => {\n          if (N.key === \"Enter\" && !f.value) {\n            ne(k.value);\n            return;\n          }\n          (N.key === \"Backspace\" || N.key === \"Delete\") && c.value && k.value === \"\" && C.value && h.value.length > 0 ? ue(h.value[h.value.length - 1]) : C.value = !0;\n        },\n        q = i(() => {\n          if (a.separator) return typeof a.separator == \"string\" ? a.separator : a.separator.join(\"\");\n        }),\n        ee = i(() => {\n          if (q.value) return new RegExp(`[${cs(q.value)}]+`);\n        }),\n        ne = N => {\n          N = (N ?? k.value).trim();\n          const le = ee.value ? N.split(ee.value).map(Ce => Ce.trim()) : [N],\n            de = [];\n          for (const Ce of le) if (!(Ce === \"\" || x.value || !a.tagValidator(Ce))) {\n            if (a.limit && te.value) break;\n            de.push(Ce);\n          }\n          const Se = [...o.value, ...de];\n          k.value = \"\", C.value = !0, o.value = Se, l(\"input\", Se), T.value = !0;\n        },\n        ue = N => {\n          const le = h.value.indexOf((N == null ? void 0 : N.toString()) ?? \"\");\n          w.value = h.value.splice(le, 1).toString(), o.value = h.value;\n        };\n      return t({\n        focus: () => {\n          T.value = !0;\n        },\n        blur: () => {\n          T.value = !1;\n        }\n      }), (N, le) => (y(), A(\"div\", {\n        id: $(n),\n        class: R([\"b-form-tags form-control h-auto\", I.value]),\n        role: \"group\",\n        tabindex: \"-1\",\n        onFocusin: X,\n        onFocusout: le[1] || (le[1] = de => l(\"focusout\", de))\n      }, [Y(\"output\", {\n        id: `${$(n)}selected_tags__`,\n        class: \"visually-hidden\",\n        for: _.value,\n        \"aria-live\": $(T) ? \"polite\" : \"off\",\n        \"aria-atomic\": \"true\",\n        \"aria-relevant\": \"additions text\"\n      }, Z(h.value.join(\", \")), 9, td), Y(\"div\", {\n        id: `${$(n)}removed_tags__`,\n        role: \"status\",\n        \"aria-live\": $(T) ? \"assertive\" : \"off\",\n        \"aria-atomic\": \"true\",\n        class: \"visually-hidden\"\n      }, \" (\" + Z(N.tagRemovedLabel) + \") \" + Z(w.value), 9, ad), O(N.$slots, \"default\", $e(Ee(G.value)), () => [Y(\"ul\", {\n        id: `${$(n)}tag_list__`,\n        class: \"b-form-tags-list list-unstyled mb-0 d-flex flex-wrap align-items-center\"\n      }, [(y(!0), A(fe, null, we(h.value, (de, Se) => O(N.$slots, \"tag\", $e(ae({\n        key: Se\n      }, {\n        tag: de,\n        tagClass: N.tagClass,\n        tagVariant: N.tagVariant,\n        tagPills: $(m),\n        removeTag: ue\n      })), () => [(y(), D(Fn, {\n        key: de,\n        class: R(N.tagClass),\n        tag: \"li\",\n        variant: N.tagVariant,\n        pill: N.tagPills,\n        onRemove: ue\n      }, {\n        default: j(() => [re(Z(de), 1)]),\n        _: 2\n      }, 1032, [\"class\", \"variant\", \"pill\"]))])), 128)), Y(\"li\", {\n        role: \"none\",\n        \"aria-live\": \"off\",\n        class: \"b-from-tags-field flex-grow-1\",\n        \"aria-controls\": `${$(n)}tag_list__`\n      }, [Y(\"div\", nd, [Y(\"input\", ae({\n        id: _.value,\n        ref_key: \"input\",\n        ref: b,\n        disabled: $(u),\n        value: k.value,\n        type: N.inputType,\n        placeholder: N.placeholder,\n        class: \"b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0\",\n        style: {\n          outline: \"currentcolor none 0px\",\n          \"min-width\": \"5rem\"\n        }\n      }, N.inputAttrs, {\n        form: N.form,\n        required: $(g) || void 0,\n        \"aria-required\": $(g) || void 0,\n        onInput: be,\n        onChange: he,\n        onKeydown: ye,\n        onFocus: U,\n        onBlur: pe\n      }), null, 16, sd), Q.value ? (y(), A(\"button\", {\n        key: 0,\n        type: \"button\",\n        class: R([\"btn b-form-tags-button py-0\", [N.inputClass, {\n          [`btn-${N.addButtonVariant}`]: N.addButtonVariant !== null,\n          \"disabled invisible\": k.value.length === 0\n        }]]),\n        style: {\n          \"font-size\": \"90%\"\n        },\n        disabled: $(u) || k.value.length === 0 || te.value,\n        onClick: le[0] || (le[0] = de => ne(k.value))\n      }, [O(N.$slots, \"add-button-text\", {}, () => [re(Z(N.addButtonText), 1)])], 10, rd)) : J(\"\", !0)])], 8, od)], 8, ld), Y(\"div\", id, [z.value ? (y(), A(\"div\", ud, Z(N.invalidTagText) + \": \" + Z(k.value), 1)) : J(\"\", !0), x.value ? (y(), A(\"small\", dd, Z(N.duplicateTagText) + \": \" + Z(k.value), 1)) : J(\"\", !0), h.value.length === N.limit ? (y(), A(\"small\", cd, \"Tag limit reached\")) : J(\"\", !0)])]), N.name ? (y(!0), A(fe, {\n        key: 0\n      }, we(h.value, (de, Se) => (y(), A(\"input\", {\n        key: Se,\n        type: \"hidden\",\n        name: N.name,\n        value: de\n      }, null, 8, fd))), 128)) : J(\"\", !0)], 42, ed));\n    }\n  }),\n  pd = [\"id\", \"name\", \"form\", \"disabled\", \"placeholder\", \"required\", \"autocomplete\", \"readonly\", \"aria-required\", \"aria-invalid\", \"rows\", \"wrap\"],\n  md = /* @__PURE__ */H({\n    __name: \"BFormTextarea\",\n    props: {\n      noResize: {\n        type: [String, Boolean],\n        default: !1\n      },\n      rows: {\n        default: 2\n      },\n      wrap: {\n        default: \"soft\"\n      },\n      ariaInvalid: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      autocomplete: {\n        default: void 0\n      },\n      autofocus: {\n        type: [String, Boolean],\n        default: !1\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      form: {\n        default: void 0\n      },\n      formatter: {\n        type: Function,\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      lazy: {\n        type: [String, Boolean],\n        default: !1\n      },\n      lazyFormatter: {\n        type: [String, Boolean],\n        default: !1\n      },\n      list: {\n        default: void 0\n      },\n      modelValue: {\n        default: \"\"\n      },\n      name: {\n        default: void 0\n      },\n      number: {\n        type: [String, Boolean],\n        default: !1\n      },\n      placeholder: {\n        default: void 0\n      },\n      plaintext: {\n        type: [String, Boolean],\n        default: !1\n      },\n      readonly: {\n        type: [String, Boolean],\n        default: !1\n      },\n      required: {\n        type: [String, Boolean],\n        default: !1\n      },\n      size: {\n        default: void 0\n      },\n      state: {\n        type: [String, Boolean, null],\n        default: null\n      },\n      trim: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    emits: [\"update:modelValue\", \"change\", \"blur\", \"input\"],\n    setup(e, {\n      expose: t,\n      emit: l\n    }) {\n      const a = e,\n        {\n          input: o,\n          computedId: n,\n          computedAriaInvalid: s,\n          onInput: r,\n          onChange: u,\n          onBlur: f,\n          focus: v,\n          blur: p\n        } = nn(a, l),\n        c = d(() => a.disabled),\n        g = d(() => a.required),\n        B = d(() => a.readonly),\n        m = d(() => a.plaintext),\n        V = d(() => a.noResize),\n        b = d(() => a.state),\n        T = Tt(b),\n        _ = i(() => [T.value, {\n          \"form-control\": !a.plaintext,\n          \"form-control-plaintext\": a.plaintext,\n          [`form-control-${a.size}`]: !!a.size\n        }]),\n        h = i(() => ({\n          resize: V.value ? \"none\" : void 0\n        }));\n      return t({\n        focus: v,\n        blur: p\n      }), (k, C) => (y(), A(\"textarea\", {\n        id: $(n),\n        ref_key: \"input\",\n        ref: o,\n        class: R(_.value),\n        name: k.name || void 0,\n        form: k.form || void 0,\n        disabled: $(c),\n        placeholder: k.placeholder,\n        required: $(g) || void 0,\n        autocomplete: k.autocomplete || void 0,\n        readonly: $(B) || $(m),\n        \"aria-required\": k.required || void 0,\n        \"aria-invalid\": $(s),\n        rows: k.rows,\n        style: De(h.value),\n        wrap: k.wrap || void 0,\n        onInput: C[0] || (C[0] = w => $(r)(w)),\n        onChange: C[1] || (C[1] = w => $(u)(w)),\n        onBlur: C[2] || (C[2] = w => $(f)(w))\n      }, null, 46, pd));\n    }\n  }),\n  gd = {\n    key: 0,\n    class: \"input-group-text\"\n  },\n  yd = [\"innerHTML\"],\n  bd = {\n    key: 1\n  },\n  hd = {\n    key: 0,\n    class: \"input-group-text\"\n  },\n  Bd = [\"innerHTML\"],\n  Sd = {\n    key: 1\n  },\n  _d = /* @__PURE__ */H({\n    __name: \"BInputGroup\",\n    props: {\n      append: {\n        default: void 0\n      },\n      appendHtml: {\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      prepend: {\n        default: void 0\n      },\n      prependHtml: {\n        default: void 0\n      },\n      size: {\n        default: \"md\"\n      },\n      tag: {\n        default: \"div\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = i(() => ({\n          [`input-group-${t.size}`]: t.size !== \"md\"\n        })),\n        a = i(() => !!t.append || !!t.appendHtml),\n        o = i(() => !!t.prepend || !!t.prependHtml);\n      return (n, s) => (y(), D(oe(n.tag), {\n        id: n.id,\n        class: R([\"input-group\", l.value]),\n        role: \"group\"\n      }, {\n        default: j(() => [O(n.$slots, \"prepend\", {}, () => [o.value ? (y(), A(\"span\", gd, [n.prependHtml ? (y(), A(\"span\", {\n          key: 0,\n          innerHTML: n.prependHtml\n        }, null, 8, yd)) : (y(), A(\"span\", bd, Z(n.prepend), 1))])) : J(\"\", !0)]), O(n.$slots, \"default\"), O(n.$slots, \"append\", {}, () => [a.value ? (y(), A(\"span\", hd, [n.appendHtml ? (y(), A(\"span\", {\n          key: 0,\n          innerHTML: n.appendHtml\n        }, null, 8, Bd)) : (y(), A(\"span\", Sd, Z(n.append), 1))])) : J(\"\", !0)])]),\n        _: 3\n      }, 8, [\"id\", \"class\"]));\n    }\n  }),\n  In = /* @__PURE__ */H({\n    __name: \"BInputGroupText\",\n    props: {\n      tag: {\n        default: \"div\"\n      },\n      text: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      return (t, l) => (y(), D(oe(t.tag), {\n        class: \"input-group-text\"\n      }, {\n        default: j(() => [O(t.$slots, \"default\", {}, () => [re(Z(t.text), 1)])]),\n        _: 3\n      }));\n    }\n  }),\n  nl = /* @__PURE__ */H({\n    __name: \"BInputGroupAddon\",\n    props: {\n      isText: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = d(() => t.isText);\n      return (a, o) => $(l) ? (y(), D(In, {\n        key: 0\n      }, {\n        default: j(() => [O(a.$slots, \"default\")]),\n        _: 3\n      })) : O(a.$slots, \"default\", {\n        key: 1\n      });\n    }\n  }),\n  wd = /* @__PURE__ */H({\n    __name: \"BInputGroupAppend\",\n    props: {\n      isText: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    setup(e) {\n      return (t, l) => (y(), D(nl, {\n        \"is-text\": t.isText\n      }, {\n        default: j(() => [O(t.$slots, \"default\")]),\n        _: 3\n      }, 8, [\"is-text\"]));\n    }\n  }),\n  $d = /* @__PURE__ */H({\n    __name: \"BInputGroupPrepend\",\n    props: {\n      isText: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    setup(e) {\n      return (t, l) => (y(), D(nl, {\n        \"is-text\": t.isText\n      }, {\n        default: j(() => [O(t.$slots, \"default\")]),\n        _: 3\n      }, 8, [\"is-text\"]));\n    }\n  }),\n  kd = /* @__PURE__ */H({\n    __name: \"BListGroup\",\n    props: {\n      flush: {\n        type: [String, Boolean],\n        default: !1\n      },\n      horizontal: {\n        type: [Boolean, String],\n        default: !1\n      },\n      numbered: {\n        type: [String, Boolean],\n        default: !1\n      },\n      tag: {\n        default: \"div\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = d(() => t.flush),\n        a = d(() => t.numbered),\n        o = i(() => {\n          const s = l.value ? !1 : t.horizontal;\n          return {\n            \"list-group-flush\": l.value,\n            \"list-group-horizontal\": s === !0,\n            [`list-group-horizontal-${s}`]: typeof s == \"string\",\n            \"list-group-numbered\": a.value\n          };\n        }),\n        n = i(() => a.value === !0 ? \"ol\" : t.tag);\n      return Ke(ko, {\n        numbered: a\n      }), (s, r) => (y(), D(oe(n.value), {\n        class: R([\"list-group\", o.value])\n      }, {\n        default: j(() => [O(s.$slots, \"default\")]),\n        _: 3\n      }, 8, [\"class\"]));\n    }\n  }),\n  Cd = /* @__PURE__ */H({\n    __name: \"BListGroupItem\",\n    props: {\n      action: {\n        type: [String, Boolean],\n        default: !1\n      },\n      active: {\n        type: [String, Boolean],\n        default: !1\n      },\n      button: {\n        type: [String, Boolean],\n        default: !1\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      href: {\n        default: void 0\n      },\n      tag: {\n        default: \"div\"\n      },\n      target: {\n        default: \"_self\"\n      },\n      to: {\n        default: void 0\n      },\n      variant: {\n        default: null\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = Ra(),\n        a = Ie(ko, null),\n        o = d(() => t.action),\n        n = d(() => t.active),\n        s = d(() => t.button),\n        r = d(() => t.disabled),\n        u = i(() => !s.value && (!!t.href || !!t.to)),\n        f = i(() => a != null && a.numbered.value ? \"li\" : s.value ? \"button\" : u.value ? Qe : t.tag),\n        v = i(() => o.value || u.value || s.value || [\"a\", \"router-link\", \"button\", \"b-link\"].includes(t.tag)),\n        p = i(() => ({\n          [`list-group-item-${t.variant}`]: t.variant !== null,\n          \"list-group-item-action\": v.value,\n          active: n.value,\n          disabled: r.value\n        })),\n        c = i(() => {\n          const g = {};\n          return s.value && ((!l || !l.type) && (g.type = \"button\"), r.value && (g.disabled = !0)), g;\n        });\n      return (g, B) => (y(), D(oe(f.value), ae({\n        class: [\"list-group-item\", p.value],\n        \"aria-current\": $(n) ? !0 : void 0,\n        \"aria-disabled\": $(r) ? !0 : void 0,\n        target: u.value ? g.target : void 0,\n        href: $(s) ? void 0 : g.href,\n        to: $(s) ? void 0 : g.to\n      }, c.value), {\n        default: j(() => [O(g.$slots, \"default\")]),\n        _: 3\n      }, 16, [\"class\", \"aria-current\", \"aria-disabled\", \"target\", \"href\", \"to\"]));\n    }\n  }),\n  Td = [\"id\", \"aria-labelledby\", \"aria-describedby\"],\n  Vd = [\"id\"],\n  Od = /* @__PURE__ */H({\n    inheritAttrs: !1,\n    __name: \"BModal\",\n    props: {\n      bodyBgVariant: {\n        default: null\n      },\n      bodyClass: {\n        default: void 0\n      },\n      bodyTextVariant: {\n        default: null\n      },\n      busy: {\n        type: [String, Boolean],\n        default: !1\n      },\n      lazy: {\n        type: [String, Boolean],\n        default: !1\n      },\n      buttonSize: {\n        default: \"md\"\n      },\n      cancelDisabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      cancelTitle: {\n        default: \"Cancel\"\n      },\n      cancelVariant: {\n        default: \"secondary\"\n      },\n      centered: {\n        type: [String, Boolean],\n        default: !1\n      },\n      contentClass: {\n        default: void 0\n      },\n      dialogClass: {\n        default: void 0\n      },\n      footerBgVariant: {\n        default: null\n      },\n      footerBorderVariant: {\n        default: null\n      },\n      footerClass: {\n        default: void 0\n      },\n      footerTextVariant: {\n        default: null\n      },\n      fullscreen: {\n        type: [Boolean, String],\n        default: !1\n      },\n      headerBgVariant: {\n        default: null\n      },\n      headerBorderVariant: {\n        default: null\n      },\n      headerClass: {\n        default: void 0\n      },\n      headerCloseLabel: {\n        default: \"Close\"\n      },\n      headerCloseWhite: {\n        type: [String, Boolean],\n        default: !1\n      },\n      headerTextVariant: {\n        default: null\n      },\n      hideBackdrop: {\n        type: [String, Boolean],\n        default: !1\n      },\n      hideFooter: {\n        type: [String, Boolean],\n        default: !1\n      },\n      hideHeader: {\n        type: [String, Boolean],\n        default: !1\n      },\n      hideHeaderClose: {\n        type: [String, Boolean],\n        default: !1\n      },\n      id: {\n        default: void 0\n      },\n      modalClass: {\n        default: void 0\n      },\n      modelValue: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noCloseOnBackdrop: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noCloseOnEsc: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noFade: {\n        type: [String, Boolean],\n        default: !1\n      },\n      autoFocus: {\n        type: [String, Boolean],\n        default: !0\n      },\n      okDisabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      okOnly: {\n        type: [String, Boolean],\n        default: !1\n      },\n      okTitle: {\n        default: \"Ok\"\n      },\n      okVariant: {\n        default: \"primary\"\n      },\n      scrollable: {\n        type: [String, Boolean],\n        default: !1\n      },\n      show: {\n        type: [String, Boolean],\n        default: !1\n      },\n      size: {\n        default: \"md\"\n      },\n      title: {\n        default: void 0\n      },\n      titleClass: {\n        default: void 0\n      },\n      titleSrOnly: {\n        type: [String, Boolean],\n        default: !1\n      },\n      titleTag: {\n        default: \"h5\"\n      },\n      autoFocusButton: {\n        default: void 0\n      },\n      teleportDisabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      teleportTo: {\n        default: \"body\"\n      },\n      bodyScrolling: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    emits: [\"update:modelValue\", \"show\", \"shown\", \"hide\", \"hidden\", \"hide-prevented\", \"show-prevented\", \"ok\", \"cancel\", \"close\"],\n    setup(e, {\n      expose: t,\n      emit: l\n    }) {\n      const a = e,\n        o = xe(),\n        n = Ve(() => a.id, \"modal\"),\n        s = ke(a, \"modelValue\", l),\n        r = d(() => a.busy),\n        u = d(() => a.lazy),\n        f = d(() => a.cancelDisabled),\n        v = d(() => a.centered),\n        p = d(() => a.hideBackdrop),\n        c = d(() => a.hideFooter),\n        g = d(() => a.hideHeader),\n        B = d(() => a.hideHeaderClose),\n        m = d(s),\n        V = d(() => a.noCloseOnBackdrop),\n        b = d(() => a.noCloseOnEsc),\n        T = d(() => a.noFade),\n        _ = d(() => a.autoFocus),\n        h = d(() => a.okDisabled),\n        k = d(() => a.okOnly),\n        C = d(() => a.scrollable),\n        w = d(() => a.titleSrOnly),\n        P = d(() => a.teleportDisabled),\n        F = d(() => a.bodyScrolling),\n        S = M(null),\n        I = M(null),\n        x = M(null),\n        z = M(null),\n        te = M(m.value),\n        Q = M(!1);\n      sn(m, F);\n      const {\n          focused: G\n        } = ze(S, {\n          initialValue: m.value && a.autoFocusButton === void 0\n        }),\n        {\n          focused: X\n        } = ze(I, {\n          initialValue: m.value && a.autoFocusButton === \"ok\"\n        }),\n        {\n          focused: U\n        } = ze(x, {\n          initialValue: m.value && a.autoFocusButton === \"cancel\"\n        }),\n        {\n          focused: pe\n        } = ze(z, {\n          initialValue: m.value && a.autoFocusButton === \"close\"\n        }),\n        be = i(() => [a.modalClass, {\n          fade: !T.value,\n          show: te.value\n        }]),\n        he = i(() => u.value === !1 || u.value === !0 && Q.value === !0 || u.value === !0 && m.value === !0),\n        ye = i(() => !Fe(o[\"header-close\"])),\n        q = i(() => [a.dialogClass, {\n          \"modal-fullscreen\": a.fullscreen === !0,\n          [`modal-fullscreen-${a.fullscreen}-down`]: typeof a.fullscreen == \"string\",\n          [`modal-${a.size}`]: a.size !== \"md\",\n          \"modal-dialog-centered\": v.value,\n          \"modal-dialog-scrollable\": C.value\n        }]),\n        ee = i(() => [a.bodyClass, {\n          [`bg-${a.bodyBgVariant}`]: a.bodyBgVariant !== null,\n          [`text-${a.bodyTextVariant}`]: a.bodyTextVariant !== null\n        }]),\n        ne = i(() => [a.headerClass, {\n          [`bg-${a.headerBgVariant}`]: a.headerBgVariant !== null,\n          [`border-${a.headerBorderVariant}`]: a.headerBorderVariant !== null,\n          [`text-${a.headerTextVariant}`]: a.headerTextVariant !== null\n        }]),\n        ue = i(() => [a.footerClass, {\n          [`bg-${a.footerBgVariant}`]: a.footerBgVariant !== null,\n          [`border-${a.footerBorderVariant}`]: a.footerBorderVariant !== null,\n          [`text-${a.footerTextVariant}`]: a.footerTextVariant !== null\n        }]),\n        N = i(() => [a.titleClass, {\n          [\"visually-hidden\"]: w.value\n        }]),\n        le = i(() => f.value || r.value),\n        de = i(() => h.value || r.value),\n        Se = (L, me = {}) => new Mt(L, {\n          cancelable: !1,\n          target: S.value || null,\n          relatedTarget: null,\n          trigger: null,\n          ...me,\n          componentId: n.value\n        }),\n        Ce = (L = \"\") => {\n          const me = Se(\"hide\", {\n            cancelable: L !== \"\",\n            trigger: L\n          });\n          if (L === \"ok\" && l(L, me), L === \"cancel\" && l(L, me), L === \"close\" && l(L, me), l(\"hide\", me), me.defaultPrevented || L === \"backdrop\" && V.value || L === \"esc\" && b.value) {\n            l(\"hide-prevented\");\n            return;\n          }\n          s.value = !1;\n        },\n        K = () => {\n          const L = Se(\"show\", {\n            cancelable: !0\n          });\n          if (l(\"show\", L), L.defaultPrevented) {\n            s.value = !1, l(\"show-prevented\");\n            return;\n          }\n          s.value = !0;\n        },\n        ce = () => {\n          _.value !== !1 && (a.autoFocusButton === \"ok\" ? X.value = !0 : a.autoFocusButton === \"close\" ? pe.value = !0 : a.autoFocusButton === \"cancel\" ? U.value = !0 : G.value = !0);\n        },\n        Le = () => K(),\n        E = () => {\n          te.value = !0, ce(), l(\"shown\", Se(\"shown\")), u.value === !0 && (Q.value = !0);\n        },\n        W = () => {\n          te.value = !1;\n        },\n        ge = () => {\n          l(\"hidden\", Se(\"hidden\")), u.value === !0 && (Q.value = !1);\n        };\n      return Zr(te), Te(S, \"bv-toggle\", () => {\n        m.value ? Ce() : K();\n      }), t({\n        hide: Ce,\n        show: K\n      }), (L, me) => (y(), D(Ha, {\n        to: L.teleportTo,\n        disabled: $(P)\n      }, [_e(Vt, {\n        \"no-fade\": !0,\n        \"trans-props\": {\n          enterToClass: \"show\"\n        },\n        onBeforeEnter: Le,\n        onAfterEnter: E,\n        onLeave: W,\n        onAfterLeave: ge\n      }, {\n        default: j(() => [rt(Y(\"div\", ae({\n          id: $(n),\n          ref_key: \"element\",\n          ref: S,\n          class: [\"modal\", be.value],\n          role: \"dialog\",\n          \"aria-labelledby\": `${$(n)}-label`,\n          \"aria-describedby\": `${$(n)}-body`,\n          tabindex: \"-1\"\n        }, L.$attrs, {\n          onKeyup: me[5] || (me[5] = xt(ve => Ce(\"esc\"), [\"esc\"]))\n        }), [Y(\"div\", {\n          class: R([\"modal-dialog\", q.value])\n        }, [he.value ? (y(), A(\"div\", {\n          key: 0,\n          class: R([\"modal-content\", L.contentClass])\n        }, [$(g) ? J(\"\", !0) : (y(), A(\"div\", {\n          key: 0,\n          class: R([\"modal-header\", ne.value])\n        }, [O(L.$slots, \"header\", {}, () => [(y(), D(oe(L.titleTag), {\n          id: `${$(n)}-label`,\n          class: R([\"modal-title\", N.value])\n        }, {\n          default: j(() => [O(L.$slots, \"title\", {}, () => [re(Z(L.title), 1)], !0)]),\n          _: 3\n        }, 8, [\"id\", \"class\"])), $(B) ? J(\"\", !0) : (y(), A(fe, {\n          key: 0\n        }, [ye.value ? (y(), A(\"button\", {\n          key: 0,\n          type: \"button\",\n          onClick: me[0] || (me[0] = ve => Ce(\"close\"))\n        }, [O(L.$slots, \"header-close\", {}, void 0, !0)])) : (y(), D(Ot, {\n          key: 1,\n          ref_key: \"closeButton\",\n          ref: z,\n          \"aria-label\": L.headerCloseLabel,\n          white: L.headerCloseWhite,\n          onClick: me[1] || (me[1] = ve => Ce(\"close\"))\n        }, null, 8, [\"aria-label\", \"white\"]))], 64))], !0)], 2)), Y(\"div\", {\n          id: `${$(n)}-body`,\n          class: R([\"modal-body\", ee.value])\n        }, [O(L.$slots, \"default\", {}, void 0, !0)], 10, Vd), $(c) ? J(\"\", !0) : (y(), A(\"div\", {\n          key: 1,\n          class: R([\"modal-footer\", ue.value])\n        }, [O(L.$slots, \"footer\", {}, () => [O(L.$slots, \"cancel\", {}, () => [$(k) ? J(\"\", !0) : (y(), D(kt, {\n          key: 0,\n          ref_key: \"cancelButton\",\n          ref: x,\n          disabled: le.value,\n          size: L.buttonSize,\n          variant: L.cancelVariant,\n          onClick: me[2] || (me[2] = ve => Ce(\"cancel\"))\n        }, {\n          default: j(() => [re(Z(L.cancelTitle), 1)]),\n          _: 1\n        }, 8, [\"disabled\", \"size\", \"variant\"]))], !0), O(L.$slots, \"ok\", {}, () => [_e(kt, {\n          ref_key: \"okButton\",\n          ref: I,\n          disabled: de.value,\n          size: L.buttonSize,\n          variant: L.okVariant,\n          onClick: me[3] || (me[3] = ve => Ce(\"ok\"))\n        }, {\n          default: j(() => [re(Z(L.okTitle), 1)]),\n          _: 1\n        }, 8, [\"disabled\", \"size\", \"variant\"])], !0)], !0)], 2))], 2)) : J(\"\", !0)], 2), $(p) ? J(\"\", !0) : O(L.$slots, \"backdrop\", {\n          key: 0\n        }, () => [Y(\"div\", {\n          class: \"modal-backdrop fade show\",\n          onClick: me[4] || (me[4] = ve => Ce(\"backdrop\"))\n        })], !0)], 16, Td), [[da, $(m)]])]),\n        _: 3\n      })], 8, [\"to\", \"disabled\"]));\n    }\n  });\nconst Ad = /* @__PURE__ */ll(Od, [[\"__scopeId\", \"data-v-b5795927\"]]),\n  Pd = /* @__PURE__ */H({\n    __name: \"BNav\",\n    props: {\n      align: {\n        default: void 0\n      },\n      cardHeader: {\n        type: [String, Boolean],\n        default: !1\n      },\n      fill: {\n        type: [String, Boolean],\n        default: !1\n      },\n      justified: {\n        type: [String, Boolean],\n        default: !1\n      },\n      pills: {\n        type: [String, Boolean],\n        default: !1\n      },\n      small: {\n        type: [String, Boolean],\n        default: !1\n      },\n      tabs: {\n        type: [String, Boolean],\n        default: !1\n      },\n      tag: {\n        default: \"ul\"\n      },\n      vertical: {\n        type: [String, Boolean],\n        default: !1\n      },\n      underline: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = d(() => t.cardHeader),\n        a = d(() => t.fill),\n        o = d(() => t.justified),\n        n = d(() => t.pills),\n        s = d(() => t.small),\n        r = d(() => t.tabs),\n        u = d(() => t.vertical),\n        f = jt(() => t.align),\n        v = d(() => t.underline),\n        p = i(() => ({\n          \"nav-tabs\": r.value,\n          \"nav-pills\": n.value && !r.value,\n          \"card-header-tabs\": !u.value && l.value && r.value,\n          \"card-header-pills\": !u.value && l.value && n.value && !r.value,\n          \"flex-column\": u.value,\n          \"nav-fill\": !u.value && a.value,\n          \"nav-justified\": !u.value && o.value,\n          [f.value]: !u.value && t.align !== void 0,\n          small: s.value,\n          \"nav-underline\": v.value\n        }));\n      return (c, g) => (y(), D(oe(c.tag), {\n        class: R([\"nav\", p.value])\n      }, {\n        default: j(() => [O(c.$slots, \"default\")]),\n        _: 3\n      }, 8, [\"class\"]));\n    }\n  }),\n  Ed = /* @__PURE__ */H({\n    __name: \"BNavForm\",\n    props: {\n      role: {\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      floating: {\n        type: [String, Boolean],\n        default: !1\n      },\n      novalidate: {\n        type: [String, Boolean],\n        default: !1\n      },\n      validated: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    emits: [\"submit\"],\n    setup(e, {\n      emit: t\n    }) {\n      const l = e,\n        a = i(() => ({\n          floating: l.floating,\n          role: l.role,\n          id: l.id,\n          novalidate: l.novalidate,\n          validated: l.validated\n        })),\n        o = n => t(\"submit\", n);\n      return (n, s) => (y(), D($n, ae(a.value, {\n        class: \"d-flex\",\n        onSubmit: ut(o, [\"prevent\"])\n      }), {\n        default: j(() => [O(n.$slots, \"default\")]),\n        _: 3\n      }, 16, [\"onSubmit\"]));\n    }\n  }),\n  Fd = {\n    class: \"nav-item\"\n  },\n  Id = /* @__PURE__ */H({\n    __name: \"BNavItem\",\n    props: {\n      linkClasses: {\n        default: void 0\n      },\n      linkAttrs: {\n        default: void 0\n      },\n      active: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      activeClass: {\n        default: \"router-link-active\"\n      },\n      append: {\n        type: [String, Boolean],\n        default: !1\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      href: {\n        default: void 0\n      },\n      rel: {\n        default: void 0\n      },\n      replace: {\n        type: [String, Boolean],\n        default: !1\n      },\n      routerComponentName: {\n        default: \"router-link\"\n      },\n      target: {\n        default: \"_self\"\n      },\n      to: {\n        default: void 0\n      },\n      variant: {\n        default: void 0\n      },\n      opacity: {\n        default: void 0\n      },\n      opacityHover: {\n        default: void 0\n      },\n      underlineVariant: {\n        default: null\n      },\n      underlineOffset: {\n        default: void 0\n      },\n      underlineOffsetHover: {\n        default: void 0\n      },\n      underlineOpacity: {\n        default: void 0\n      },\n      underlineOpacityHover: {\n        default: void 0\n      },\n      icon: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = d(() => t.disabled),\n        a = i(() => Dt(t, {\n          active: !0,\n          activeClass: !0,\n          append: !0,\n          disabled: !0,\n          href: !0,\n          icon: !0,\n          opacity: !0,\n          opacityHover: !0,\n          rel: !0,\n          replace: !0,\n          routerComponentName: !0,\n          target: !0,\n          to: !0,\n          underlineOffset: !0,\n          underlineOffsetHover: !0,\n          underlineOpacity: !0,\n          underlineOpacityHover: !0,\n          underlineVariant: !0,\n          variant: !0\n        }));\n      return (o, n) => (y(), A(\"li\", Fd, [_e(Qe, ae({\n        class: [\"nav-link\", o.linkClasses]\n      }, {\n        ...a.value,\n        ...o.linkAttrs\n      }, {\n        \"active-class\": \"active\",\n        tabindex: $(l) ? -1 : void 0,\n        \"aria-disabled\": $(l) ? !0 : void 0\n      }), {\n        default: j(() => [O(o.$slots, \"default\")]),\n        _: 3\n      }, 16, [\"class\", \"tabindex\", \"aria-disabled\"])]));\n    }\n  }),\n  xd = {\n    class: \"nav-item dropdown\"\n  },\n  Ld = /* @__PURE__ */H({\n    __name: \"BNavItemDropdown\",\n    props: {\n      id: {\n        default: void 0\n      },\n      text: {\n        default: void 0\n      },\n      toggleClass: {\n        default: void 0\n      },\n      size: {\n        default: \"md\"\n      },\n      offset: {\n        default: void 0\n      },\n      autoClose: {\n        type: [Boolean, String],\n        default: void 0\n      },\n      dark: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      splitVariant: {\n        default: void 0\n      },\n      noCaret: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      variant: {\n        default: \"link\"\n      },\n      modelValue: {\n        type: [String, Boolean],\n        default: !1\n      },\n      lazy: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      strategy: {\n        default: void 0\n      },\n      floatingMiddleware: {\n        default: void 0\n      },\n      noFlip: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      noShift: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      dropup: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      dropend: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      dropstart: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      center: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      end: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      menuClass: {\n        default: void 0\n      }\n    },\n    emits: [\"update:modelValue\"],\n    setup(e, {\n      expose: t,\n      emit: l\n    }) {\n      const a = e,\n        o = ke(a, \"modelValue\", l, {\n          passive: !0\n        }),\n        n = d(o),\n        s = i({\n          get: () => n.value,\n          set: p => {\n            o.value = p;\n          }\n        }),\n        r = i(() => Fs(a, [\"modelValue\"]));\n      return t({\n        close: () => {\n          o.value = !1;\n        },\n        open: () => {\n          o.value = !0;\n        },\n        toggle: () => {\n          o.value = !n.value;\n        }\n      }), (p, c) => (y(), A(\"li\", xd, [_e(wn, ae({\n        modelValue: s.value,\n        \"onUpdate:modelValue\": c[0] || (c[0] = g => s.value = g)\n      }, r.value, {\n        \"is-nav\": \"\"\n      }), {\n        \"button-content\": j(() => [O(p.$slots, \"button-content\")]),\n        \"toggle-text\": j(() => [O(p.$slots, \"toggle-text\")]),\n        default: j(() => [O(p.$slots, \"default\")]),\n        _: 3\n      }, 16, [\"modelValue\"])]));\n    }\n  }),\n  Nd = {\n    class: \"navbar-text\"\n  },\n  zd = /* @__PURE__ */H({\n    __name: \"BNavText\",\n    props: {\n      text: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      return (t, l) => (y(), A(\"li\", Nd, [O(t.$slots, \"default\", {}, () => [re(Z(t.text), 1)])]));\n    }\n  }),\n  Hd = /* @__PURE__ */H({\n    __name: \"BNavbar\",\n    props: {\n      fixed: {\n        default: void 0\n      },\n      print: {\n        type: [String, Boolean],\n        default: !1\n      },\n      sticky: {\n        default: void 0\n      },\n      tag: {\n        default: \"nav\"\n      },\n      toggleable: {\n        type: [Boolean, String],\n        default: !1\n      },\n      dark: {\n        type: [String, Boolean],\n        default: !1\n      },\n      variant: {\n        default: null\n      },\n      container: {\n        type: [String, Boolean],\n        default: \"fluid\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = d(() => t.print),\n        a = d(() => t.dark),\n        o = i(() => t.tag === \"nav\" ? void 0 : \"navigation\"),\n        n = i(() => typeof t.toggleable == \"string\" ? `navbar-expand-${t.toggleable}` : t.toggleable === !1 ? \"navbar-expand\" : void 0),\n        s = i(() => t.container === !0 ? \"container\" : \"container-fluid\"),\n        r = i(() => ({\n          \"d-print\": l.value,\n          [`sticky-${t.sticky}`]: t.sticky !== void 0,\n          \"navbar-dark\": a.value,\n          [`bg-${t.variant}`]: t.variant !== null,\n          [`fixed-${t.fixed}`]: t.fixed !== void 0,\n          [`${n.value}`]: n.value !== void 0\n        }));\n      return Ke(Ua, {\n        tag: Be(Ae(t, \"tag\"))\n      }), (u, f) => (y(), D(oe(u.tag), {\n        class: R([\"navbar\", r.value]),\n        role: o.value\n      }, {\n        default: j(() => [u.container !== !1 ? (y(), A(\"div\", {\n          key: 0,\n          class: R(s.value)\n        }, [O(u.$slots, \"default\")], 2)) : O(u.$slots, \"default\", {\n          key: 1\n        })]),\n        _: 3\n      }, 8, [\"class\", \"role\"]));\n    }\n  }),\n  Rd = /* @__PURE__ */H({\n    __name: \"BNavbarBrand\",\n    props: {\n      tag: {\n        default: \"div\"\n      },\n      active: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      activeClass: {\n        default: \"router-link-active\"\n      },\n      append: {\n        type: [String, Boolean],\n        default: !1\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      href: {\n        default: void 0\n      },\n      rel: {\n        default: void 0\n      },\n      replace: {\n        type: [String, Boolean],\n        default: !1\n      },\n      routerComponentName: {\n        default: \"router-link\"\n      },\n      target: {\n        default: \"_self\"\n      },\n      to: {\n        default: void 0\n      },\n      variant: {\n        default: void 0\n      },\n      opacity: {\n        default: void 0\n      },\n      opacityHover: {\n        default: void 0\n      },\n      underlineVariant: {\n        default: null\n      },\n      underlineOffset: {\n        default: void 0\n      },\n      underlineOffsetHover: {\n        default: void 0\n      },\n      underlineOpacity: {\n        default: void 0\n      },\n      underlineOpacityHover: {\n        default: void 0\n      },\n      icon: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = i(() => St(t)),\n        a = i(() => l.value ? Qe : t.tag),\n        o = i(() => l.value ? Dt(t, {\n          active: !0,\n          activeClass: !0,\n          append: !0,\n          disabled: !0,\n          href: !0,\n          rel: !0,\n          replace: !0,\n          routerComponentName: !0,\n          target: !0,\n          to: !0,\n          variant: !0,\n          opacity: !0,\n          opacityHover: !0,\n          underlineVariant: !0,\n          underlineOffset: !0,\n          underlineOffsetHover: !0,\n          underlineOpacity: !0,\n          underlineOpacityHover: !0,\n          icon: !0\n        }) : {});\n      return (n, s) => (y(), D(oe(a.value), ae({\n        class: \"navbar-brand\"\n      }, o.value), {\n        default: j(() => [O(n.$slots, \"default\")]),\n        _: 3\n      }, 16));\n    }\n  }),\n  Md = /* @__PURE__ */H({\n    __name: \"BNavbarNav\",\n    props: {\n      align: {\n        default: void 0\n      },\n      fill: {\n        type: [String, Boolean],\n        default: !1\n      },\n      justified: {\n        type: [String, Boolean],\n        default: !1\n      },\n      small: {\n        type: [String, Boolean],\n        default: !1\n      },\n      tag: {\n        default: \"ul\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = d(() => t.fill),\n        a = d(() => t.justified),\n        o = d(() => t.small),\n        n = jt(() => t.align),\n        s = i(() => ({\n          \"nav-fill\": l.value,\n          \"nav-justified\": a.value,\n          [n.value]: t.align !== void 0,\n          small: o.value\n        }));\n      return (r, u) => (y(), A(\"ul\", {\n        class: R([\"navbar-nav\", s.value])\n      }, [O(r.$slots, \"default\")], 2));\n    }\n  }),\n  eo = (e, t) => e.setAttribute(\"data-bs-theme\", t),\n  Dd = {\n    mounted(e, t) {\n      eo(e, t.value);\n    },\n    updated(e, t) {\n      eo(e, t.value);\n    }\n  },\n  sl = (e, t) => {\n    const {\n        modifiers: l,\n        arg: a,\n        value: o\n      } = e,\n      n = Object.keys(l || {}),\n      s = typeof o == \"string\" ? o.split(Yt) : o;\n    if (As(t.tagName, \"a\")) {\n      const r = Ga(t, \"href\") || \"\";\n      ns.test(r) && n.push(r.replace(os, \"\"));\n    }\n    return Array.prototype.concat.apply([], [a, s]).forEach(r => typeof r == \"string\" && n.push(r)), n.filter((r, u, f) => r && f.indexOf(r) === u);\n  },\n  jd = (e, t) => {\n    sl(e, t).forEach(a => {\n      const o = document.getElementById(a);\n      o !== null && o.dispatchEvent(new Event(\"bv-toggle\"));\n    }), setTimeout(() => xn(e, t), 50);\n  },\n  xn = (e, t) => {\n    const l = sl(e, t);\n    let a = !1;\n    l.forEach(o => {\n      const n = document.getElementById(o);\n      n != null && n.classList.contains(\"show\") && (a = !0), n != null && n.classList.contains(\"closing\") && (a = !1);\n    }), t.setAttribute(\"aria-expanded\", a ? \"true\" : \"false\");\n  },\n  Na = {\n    mounted(e, t) {\n      e.__toggle = () => jd(t, e), e.addEventListener(\"click\", e.__toggle), xn(t, e), e.setAttribute(\"aria-controls\", sl(t, e).join(\" \"));\n    },\n    unmounted(e) {\n      e.removeEventListener(\"click\", e.__toggle), e.removeAttribute(\"aria-controls\"), e.removeAttribute(\"aria-expanded\");\n    }\n  },\n  qd = {\n    mounted(e, t) {\n      if (!Ht(t.value)) return;\n      const a = sa(t.value, e);\n      !a.content && !a.title || (e.$__state = M({\n        ...ra(t, e),\n        ...a\n      }), rn(e, t));\n    },\n    updated(e, t) {\n      if (!Ht(t.value)) return;\n      const a = sa(t.value, e);\n      !a.content && !a.title || e.$__state && (e.$__state.value = {\n        ...ra(t, e),\n        ...a\n      });\n    },\n    beforeUnmount(e) {\n      un(e);\n    }\n  },\n  Gd = {\n    mounted(e, t) {\n      const l = Ht(t.value);\n      if (!l) return;\n      const a = sa(t.value, e);\n      !a.content && !a.title || (e.$__state = M({\n        ...ra(t, e),\n        title: a.title ?? a.content ?? \"\",\n        tooltip: l\n      }), rn(e, t));\n    },\n    updated(e, t) {\n      const l = Ht(t.value);\n      if (!l) return;\n      const a = sa(t.value, e);\n      !a.content && !a.title || e.$__state && (e.$__state.value = {\n        ...ra(t, e),\n        title: a.title ?? a.content ?? \"\",\n        tooltip: l\n      });\n    },\n    beforeUnmount(e) {\n      un(e);\n    }\n  },\n  to = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n    __proto__: null,\n    vBColorMode: Dd,\n    vBModal: Na,\n    vBPopover: qd,\n    vBToggle: Na,\n    vBTooltip: Gd\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  })),\n  Wd = /* @__PURE__ */Y(\"span\", {\n    class: \"navbar-toggler-icon\"\n  }, null, -1),\n  Ud = /* @__PURE__ */H({\n    __name: \"BNavbarToggle\",\n    props: {\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      label: {\n        default: \"Toggle navigation\"\n      },\n      target: {\n        default: void 0\n      }\n    },\n    emits: [\"click\"],\n    setup(e, {\n      emit: t\n    }) {\n      const l = e,\n        a = d(() => l.disabled),\n        o = i(() => ({\n          disabled: a.value,\n          \"aria-label\": l.label\n        })),\n        n = i(() => ({\n          disabled: a.value\n        })),\n        s = r => {\n          a.value || t(\"click\", r);\n        };\n      return (r, u) => rt((y(), A(\"button\", ae({\n        class: [\"navbar-toggler\", n.value],\n        type: \"button\"\n      }, o.value, {\n        onClick: s\n      }), [O(r.$slots, \"default\", {}, () => [Wd])], 16)), [[$(Na), $(a) ? void 0 : r.target]]);\n    }\n  }),\n  Ln = /* @__PURE__ */H({\n    __name: \"BOverlay\",\n    props: {\n      bgColor: {\n        default: void 0\n      },\n      blur: {\n        default: \"2px\"\n      },\n      fixed: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noCenter: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noFade: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noWrap: {\n        type: [String, Boolean],\n        default: !1\n      },\n      opacity: {\n        default: 0.85\n      },\n      overlayTag: {\n        default: \"div\"\n      },\n      rounded: {\n        type: [Boolean, String],\n        default: !1\n      },\n      show: {\n        type: [String, Boolean],\n        default: !1\n      },\n      spinnerSmall: {\n        type: [String, Boolean],\n        default: !1\n      },\n      spinnerType: {\n        default: \"border\"\n      },\n      spinnerVariant: {\n        default: void 0\n      },\n      noSpinner: {\n        type: [String, Boolean],\n        default: !1\n      },\n      variant: {\n        default: \"light\"\n      },\n      wrapTag: {\n        default: \"div\"\n      },\n      zIndex: {\n        default: 10\n      }\n    },\n    emits: [\"click\", \"hidden\", \"shown\"],\n    setup(e, {\n      emit: t\n    }) {\n      const l = e,\n        a = {\n          top: 0,\n          left: 0,\n          bottom: 0,\n          right: 0\n        },\n        o = d(() => l.fixed),\n        n = d(() => l.noSpinner),\n        s = d(() => l.noCenter),\n        r = d(() => l.noWrap),\n        u = d(() => l.show),\n        f = d(() => l.spinnerSmall),\n        v = i(() => l.rounded === !0 || l.rounded === \"\" ? \"rounded\" : l.rounded === !1 ? \"\" : `rounded-${l.rounded}`),\n        p = i(() => l.variant !== null && !l.bgColor ? `bg-${l.variant}` : \"\"),\n        c = i(() => u.value ? !0 : null),\n        g = i(() => ({\n          type: l.spinnerType,\n          variant: l.spinnerVariant,\n          small: f.value\n        })),\n        B = i(() => ({\n          ...a,\n          zIndex: l.zIndex || 10\n        })),\n        m = i(() => [\"b-overlay\", {\n          \"position-absolute\": !r.value || !o.value,\n          \"position-fixed\": r.value && o.value\n        }]),\n        V = i(() => [p.value, v.value]),\n        b = i(() => ({\n          ...a,\n          opacity: l.opacity,\n          backgroundColor: l.bgColor || void 0,\n          backdropFilter: l.blur ? `blur(${l.blur})` : void 0\n        })),\n        T = i(() => s.value ? a : {\n          top: \"50%\",\n          left: \"50%\",\n          transform: \"translateX(-50%) translateY(-50%)\"\n        });\n      return (_, h) => (y(), D(oe(_.wrapTag), {\n        class: \"b-overlay-wrap position-relative\",\n        \"aria-busy\": c.value\n      }, {\n        default: j(() => [O(_.$slots, \"default\"), _e(Vt, {\n          \"no-fade\": _.noFade,\n          \"trans-props\": {\n            enterToClass: \"show\"\n          },\n          name: \"fade\",\n          onOnAfterEnter: h[1] || (h[1] = k => t(\"shown\")),\n          onOnAfterLeave: h[2] || (h[2] = k => t(\"hidden\"))\n        }, {\n          default: j(() => [$(u) ? (y(), D(oe(_.overlayTag), {\n            key: 0,\n            class: R(m.value),\n            style: De(B.value),\n            onClick: h[0] || (h[0] = k => t(\"click\", k))\n          }, {\n            default: j(() => [Y(\"div\", {\n              class: R([\"position-absolute\", V.value]),\n              style: De(b.value)\n            }, null, 6), Y(\"div\", {\n              class: \"position-absolute\",\n              style: De(T.value)\n            }, [O(_.$slots, \"overlay\", $e(Ee(g.value)), () => [$(n) ? J(\"\", !0) : (y(), D(ma, $e(ae({\n              key: 0\n            }, g.value)), null, 16))])], 4)]),\n            _: 3\n          }, 8, [\"class\", \"style\"])) : J(\"\", !0)]),\n          _: 3\n        }, 8, [\"no-fade\"])]),\n        _: 3\n      }, 8, [\"aria-busy\"]));\n    }\n  }),\n  Kd = [\"id\", \"aria-labelledby\"],\n  Xd = [\"id\"],\n  Yd = /* @__PURE__ */H({\n    inheritAttrs: !1,\n    __name: \"BOffcanvas\",\n    props: {\n      dismissLabel: {\n        default: \"Close\"\n      },\n      modelValue: {\n        type: [String, Boolean],\n        default: !1\n      },\n      bodyScrolling: {\n        type: [String, Boolean],\n        default: !1\n      },\n      backdrop: {\n        type: [String, Boolean],\n        default: !0\n      },\n      noCloseOnBackdrop: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noCloseOnEsc: {\n        type: [String, Boolean],\n        default: !1\n      },\n      placement: {\n        default: \"start\"\n      },\n      title: {\n        default: void 0\n      },\n      noHeaderClose: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noHeader: {\n        type: [String, Boolean],\n        default: !1\n      },\n      lazy: {\n        type: [String, Boolean],\n        default: !1\n      },\n      id: {\n        default: void 0\n      },\n      noFocus: {\n        type: [String, Boolean],\n        default: !1\n      },\n      backdropVariant: {\n        default: \"dark\"\n      },\n      headerClass: {\n        default: void 0\n      },\n      bodyClass: {\n        default: void 0\n      },\n      footerClass: {\n        default: void 0\n      },\n      teleportDisabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      teleportTo: {\n        default: \"body\"\n      }\n    },\n    emits: [\"update:modelValue\", \"show\", \"shown\", \"hide\", \"hidden\", \"hide-prevented\", \"show-prevented\", \"esc\", \"close\"],\n    setup(e, {\n      expose: t,\n      emit: l\n    }) {\n      const a = e,\n        o = xe(),\n        n = ke(a, \"modelValue\", l, {\n          passive: !0\n        }),\n        s = d(n),\n        r = d(() => a.bodyScrolling),\n        u = d(() => a.backdrop),\n        f = d(() => a.noHeaderClose),\n        v = d(() => a.noHeader),\n        p = d(() => a.noFocus),\n        c = d(() => a.noCloseOnBackdrop),\n        g = d(() => a.noCloseOnEsc),\n        B = d(() => a.lazy),\n        m = d(() => a.teleportDisabled),\n        V = Ve(() => a.id, \"offcanvas\");\n      sn(s, r);\n      const b = M(null),\n        {\n          focused: T\n        } = ze(b, {\n          initialValue: s.value && p.value === !1\n        }),\n        _ = M(s.value),\n        h = M(!1),\n        k = i(() => u.value === !0 && s.value === !0),\n        C = i(() => B.value === !1 || B.value === !0 && h.value === !0 || B.value === !0 && s.value === !0),\n        w = i(() => !Fe(o.footer)),\n        P = i(() => [\n        // props.responsive === undefined ? 'offcanvas' : `offcanvas-${props.responsive}`,\n        \"offcanvas\",\n        // Remove when above check is fixed\n        `offcanvas-${a.placement}`, {\n          show: s.value && _.value === !0\n        }]),\n        F = (X, U = {}) => new Mt(X, {\n          cancelable: !1,\n          target: b.value || null,\n          relatedTarget: null,\n          trigger: null,\n          ...U,\n          componentId: V.value\n        }),\n        S = (X = \"\") => {\n          const U = F(\"hide\", {\n            cancelable: X !== \"\",\n            trigger: X\n          });\n          if (X === \"close\" && l(X, U), X === \"esc\" && l(X, U), l(\"hide\", U), U.defaultPrevented || X === \"backdrop\" && c.value || X === \"esc\" && g.value) {\n            l(\"hide-prevented\");\n            return;\n          }\n          n.value = !1;\n        },\n        I = () => {\n          const X = F(\"show\", {\n            cancelable: !0\n          });\n          if (l(\"show\", X), X.defaultPrevented) {\n            n.value = !1, l(\"show-prevented\");\n            return;\n          }\n          n.value = !0;\n        },\n        x = () => {\n          Oe(() => {\n            p.value === !1 && (T.value = !0);\n          });\n        },\n        z = () => I(),\n        te = () => {\n          _.value = !0, x(), l(\"shown\", F(\"shown\")), B.value === !0 && (h.value = !0);\n        },\n        Q = () => {\n          _.value = !1;\n        },\n        G = () => {\n          l(\"hidden\", F(\"hidden\")), B.value === !0 && (h.value = !1);\n        };\n      return Te(b, \"bv-toggle\", () => {\n        s.value ? S() : I();\n      }), t({\n        hide: S,\n        show: I\n      }), (X, U) => (y(), D(Ha, {\n        to: X.teleportTo,\n        disabled: $(m)\n      }, [_e(Vt, {\n        \"no-fade\": !0,\n        \"trans-props\": {\n          enterToClass: \"showing\",\n          enterFromClass: \"\",\n          leaveToClass: \"hiding show\",\n          leaveFromClass: \"show\"\n        },\n        onBeforeEnter: z,\n        onAfterEnter: te,\n        onLeave: Q,\n        onAfterLeave: G\n      }, {\n        default: j(() => [rt(Y(\"div\", ae({\n          id: $(V),\n          ref_key: \"element\",\n          ref: b,\n          \"aria-modal\": \"true\",\n          role: \"dialog\",\n          class: P.value,\n          tabindex: \"-1\",\n          \"aria-labelledby\": `${$(V)}-offcanvas-label`,\n          \"data-bs-backdrop\": \"false\"\n        }, X.$attrs, {\n          onKeyup: U[1] || (U[1] = xt(pe => S(\"esc\"), [\"esc\"]))\n        }), [C.value ? (y(), A(fe, {\n          key: 0\n        }, [$(v) ? J(\"\", !0) : (y(), A(\"div\", {\n          key: 0,\n          class: R([\"offcanvas-header\", X.headerClass])\n        }, [O(X.$slots, \"header\", $e(Ee({\n          visible: $(s),\n          placement: X.placement,\n          hide: S\n        })), () => [Y(\"h5\", {\n          id: `${$(V)}-offcanvas-label`,\n          class: \"offcanvas-title\"\n        }, [O(X.$slots, \"title\", {}, () => [re(Z(X.title), 1)])], 8, Xd), $(f) ? J(\"\", !0) : (y(), D(Ot, {\n          key: 0,\n          class: \"text-reset\",\n          \"aria-label\": X.dismissLabel,\n          onClick: U[0] || (U[0] = pe => S(\"close\"))\n        }, null, 8, [\"aria-label\"]))])], 2)), Y(\"div\", {\n          class: R([\"offcanvas-body\", X.bodyClass])\n        }, [O(X.$slots, \"default\")], 2), w.value ? (y(), A(\"div\", {\n          key: 1,\n          class: R(X.footerClass)\n        }, [O(X.$slots, \"footer\", $e(Ee({\n          visible: $(s),\n          placement: X.placement,\n          hide: S\n        })))], 2)) : J(\"\", !0)], 64)) : J(\"\", !0)], 16, Kd), [[da, $(n)]])]),\n        _: 3\n      }), _e(Ln, {\n        variant: X.backdropVariant,\n        show: k.value,\n        fixed: !0,\n        \"no-wrap\": \"\",\n        \"no-spinner\": !0,\n        onClick: U[2] || (U[2] = pe => S(\"backdrop\"))\n      }, null, 8, [\"variant\", \"show\"])], 8, [\"to\", \"disabled\"]));\n    }\n  }),\n  Jd = 5,\n  Nn = 20,\n  zn = 0,\n  Xe = 3,\n  Zd = \"ellipsis-text\",\n  Qd = \"first-text\",\n  ec = \"last-text\",\n  tc = \"next-text\",\n  ac = \"page\",\n  lc = \"prev-text\",\n  ao = e => Math.max(ot(e) || Nn, 1),\n  lo = e => Math.max(ot(e) || zn, 0),\n  oc = (e, t) => {\n    const l = ot(e) || 1;\n    return l > t ? t : l < 1 ? 1 : l;\n  },\n  nc = H({\n    name: \"BPagination\",\n    props: {\n      align: {\n        type: String,\n        default: \"start\"\n      },\n      ariaControls: {\n        type: String,\n        default: void 0\n      },\n      ariaLabel: {\n        type: String,\n        default: \"Pagination\"\n      },\n      disabled: {\n        type: [Boolean, String],\n        default: !1\n      },\n      ellipsisClass: {\n        type: [Array, String],\n        default: () => []\n      },\n      ellipsisText: {\n        type: String,\n        default: \"â¦\"\n      },\n      firstClass: {\n        type: [Array, String],\n        default: () => []\n      },\n      firstNumber: {\n        type: [Boolean, String],\n        default: !1\n      },\n      firstText: {\n        type: String,\n        default: \"Â«\"\n      },\n      hideEllipsis: {\n        type: [Boolean, String],\n        default: !1\n      },\n      hideGotoEndButtons: {\n        type: [Boolean, String],\n        default: !1\n      },\n      labelFirstPage: {\n        type: String,\n        default: \"Go to first page\"\n      },\n      labelLastPage: {\n        type: String,\n        default: \"Go to last page\"\n      },\n      labelNextPage: {\n        type: String,\n        default: \"Go to next page\"\n      },\n      labelPage: {\n        type: String,\n        default: \"Go to page\"\n      },\n      labelPrevPage: {\n        type: String,\n        default: \"Go to previous page\"\n      },\n      lastClass: {\n        type: [Array, String],\n        default: () => []\n      },\n      lastNumber: {\n        type: [Boolean, String],\n        default: !1\n      },\n      lastText: {\n        type: String,\n        default: \"Â»\"\n      },\n      limit: {\n        type: Number,\n        default: Jd\n      },\n      modelValue: {\n        type: Number,\n        default: 1\n      },\n      // V-model prop\n      nextClass: {\n        type: [Array, String],\n        default: () => []\n      },\n      nextText: {\n        type: String,\n        default: \"âº\"\n      },\n      pageClass: {\n        type: [Array, String],\n        default: () => []\n      },\n      perPage: {\n        type: Number,\n        default: Nn\n      },\n      pills: {\n        type: [Boolean, String],\n        default: !1\n      },\n      prevClass: {\n        type: [Array, String],\n        default: () => []\n      },\n      prevText: {\n        type: String,\n        default: \"â¹\"\n      },\n      size: {\n        type: String,\n        default: \"md\"\n      },\n      totalRows: {\n        type: Number,\n        default: zn\n      }\n    },\n    emits: [\"update:modelValue\", \"page-click\"],\n    setup(e, {\n      emit: t,\n      slots: l\n    }) {\n      const a = ke(e, \"modelValue\", t),\n        o = d(() => e.disabled),\n        n = d(() => e.firstNumber),\n        s = d(() => e.hideEllipsis),\n        r = d(() => e.hideGotoEndButtons),\n        u = d(() => e.lastNumber),\n        f = d(() => e.pills),\n        v = i(() => e.align === \"fill\" ? \"start\" : e.align),\n        p = jt(v),\n        c = i(() => Math.ceil(lo(e.totalRows) / ao(e.perPage))),\n        g = i(() => {\n          let C;\n          return c.value - a.value + 2 < e.limit && e.limit > Xe ? C = c.value - m.value + 1 : C = a.value - Math.floor(m.value / 2), C < 1 ? C = 1 : C > c.value - m.value && (C = c.value - m.value + 1), e.limit <= Xe && u.value && c.value === C + m.value - 1 && (C = Math.max(C - 1, 1)), C;\n        }),\n        B = i(() => {\n          const C = c.value - a.value;\n          let w = !1;\n          return C + 2 < e.limit && e.limit > Xe ? e.limit > Xe && (w = !0) : e.limit > Xe && (w = !!(!s.value || n.value)), g.value <= 1 && (w = !1), w && n.value && g.value < 4 && (w = !1), w;\n        }),\n        m = i(() => {\n          let C = e.limit;\n          return c.value <= e.limit ? C = c.value : a.value < e.limit - 1 && e.limit > Xe ? ((!s.value || u.value) && (C = e.limit - (n.value ? 0 : 1)), C = Math.min(C, e.limit)) : c.value - a.value + 2 < e.limit && e.limit > Xe ? (!s.value || n.value) && (C = e.limit - (u.value ? 0 : 1)) : e.limit > Xe && (C = e.limit - (s.value ? 0 : 2)), C;\n        }),\n        V = i(() => {\n          const C = c.value - m.value;\n          let w = !1;\n          a.value < e.limit - 1 && e.limit > Xe ? (!s.value || u.value) && (w = !0) : e.limit > Xe && (w = !!(!s.value || u.value)), g.value > C && (w = !1);\n          const P = g.value + m.value - 1;\n          return w && u.value && P > c.value - 3 && (w = !1), w;\n        }),\n        b = Bt({\n          pageSize: ao(e.perPage),\n          totalRows: lo(e.totalRows),\n          numberOfPages: c.value\n        }),\n        T = (C, w) => {\n          if (w === a.value) return;\n          const {\n              target: P\n            } = C,\n            F = new Je(\"page-click\", {\n              cancelable: !0,\n              target: P\n            });\n          t(\"page-click\", F, w), !F.defaultPrevented && (a.value = w);\n        },\n        _ = i(() => e.size ? `pagination-${e.size}` : \"\"),\n        h = i(() => f.value ? \"b-pagination-pills\" : \"\");\n      se(a, C => {\n        const w = oc(C, c.value);\n        w !== a.value && (a.value = w);\n      }), se(b, (C, w) => {\n        C != null && (w.pageSize !== C.pageSize && w.totalRows === C.totalRows || w.numberOfPages !== C.numberOfPages && a.value > w.numberOfPages) && (a.value = 1);\n      });\n      const k = i(() => {\n        const C = [];\n        for (let w = 0; w < m.value; w++) C.push({\n          number: g.value + w,\n          classes: null\n        });\n        return C;\n      });\n      return () => {\n        const C = [],\n          w = k.value.map(G => G.number),\n          P = G => G === a.value,\n          F = a.value < 1,\n          S = e.align === \"fill\",\n          I = (G, X, U, pe, be, he) => {\n            const ye = o.value || P(he) || F || G < 1 || G > c.value,\n              q = G < 1 ? 1 : G > c.value ? c.value : G,\n              ee = {\n                disabled: ye,\n                page: q,\n                index: q - 1\n              },\n              ne = Me(U, ee, l) || pe || \"\";\n            return ie(\"li\", {\n              class: [\"page-item\", {\n                disabled: ye,\n                \"flex-fill\": S,\n                \"d-flex\": S && !ye\n              }, be]\n            },\n            // render inner content\n            ie(ye ? \"span\" : \"button\", {\n              class: [\"page-link\", {\n                \"flex-grow-1\": !ye && S\n              }],\n              \"aria-label\": X,\n              \"aria-controls\": e.ariaControls || null,\n              \"aria-disabled\": ye ? !0 : null,\n              role: \"menuitem\",\n              type: ye ? null : \"button\",\n              tabindex: ye ? null : \"-1\",\n              onClick: ue => {\n                ye || T(ue, q);\n              }\n            }, ne));\n          },\n          x = G => ie(\"li\", {\n            class: [\"page-item\", \"disabled\", \"bv-d-xs-down-none\", S ? \"flex-fill\" : \"\", e.ellipsisClass],\n            role: \"separator\",\n            key: `ellipsis-${G ? \"last\" : \"first\"}`\n          }, [ie(\"span\", {\n            class: [\"page-link\"]\n          }, Me(Zd, {}, l) || e.ellipsisText || \"...\")]),\n          z = (G, X) => {\n            const U = P(G.number) && !F,\n              pe = o.value ? null : U || F && X === 0 ? \"0\" : \"-1\",\n              be = {\n                active: U,\n                disabled: o.value,\n                page: G.number,\n                index: G.number - 1,\n                content: G.number\n              },\n              he = Me(ac, be, l) || G.number,\n              ye = ie(o.value ? \"span\" : \"button\", {\n                class: [\"page-link\", {\n                  \"flex-grow-1\": !o.value && S\n                }],\n                \"aria-controls\": e.ariaControls || null,\n                \"aria-disabled\": o.value ? !0 : null,\n                \"aria-label\": e.labelPage ? `${e.labelPage} ${G.number}` : null,\n                role: \"menuitemradio\",\n                type: o.value ? null : \"button\",\n                tabindex: pe,\n                onClick: q => {\n                  o.value || T(q, G.number);\n                }\n              }, he);\n            return ie(\"li\", {\n              class: [\"page-item\", {\n                disabled: o.value,\n                active: U,\n                \"flex-fill\": S,\n                \"d-flex\": S && !o.value\n              }, e.pageClass],\n              role: \"presentation\",\n              key: `page-${G.number}`\n            }, ye);\n          };\n        if (!r.value && !n.value) {\n          const G = I(1, e.labelFirstPage, Qd, e.firstText, e.firstClass, 1);\n          C.push(G);\n        }\n        const te = I(a.value - 1, e.labelFirstPage, lc, e.prevText, e.prevClass, 1);\n        C.push(te), n.value && w[0] !== 1 && C.push(z({\n          number: 1\n        }, 0)), B.value && C.push(x(!1)), k.value.forEach((G, X) => {\n          const U = B.value && n.value && w[0] !== 1 ? 1 : 0;\n          C.push(z(G, X + U));\n        }), V.value && C.push(x(!0)), u.value && w[w.length - 1] !== c.value && C.push(z({\n          number: c.value\n        }, -1));\n        const Q = I(a.value + 1, e.labelNextPage, tc, e.nextText, e.nextClass, c.value);\n        if (C.push(Q), !u.value && !r.value) {\n          const G = I(c.value, e.labelLastPage, ec, e.lastText, e.lastClass, c.value);\n          C.push(G);\n        }\n        return ie(\"ul\", {\n          class: [\"pagination\", _.value, p.value, h.value],\n          role: \"menubar\",\n          \"aria-disabled\": o.value,\n          \"aria-label\": e.ariaLabel || null\n        }, C);\n      };\n    }\n  }),\n  Re = /* @__PURE__ */H({\n    inheritAttrs: !1,\n    __name: \"BPlaceholder\",\n    props: {\n      tag: {\n        default: \"span\"\n      },\n      wrapperTag: {\n        default: \"span\"\n      },\n      width: {\n        default: void 0\n      },\n      cols: {\n        default: 12\n      },\n      variant: {\n        default: null\n      },\n      size: {\n        default: \"md\"\n      },\n      animation: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = i(() => t.width === void 0 ? void 0 : typeof t.width == \"number\" ? t.width.toString() : t.width.replace(\"%\", \"\")),\n        a = i(() => t.cols === void 0 ? void 0 : typeof t.cols == \"number\" ? t.cols.toString() : t.cols),\n        o = i(() => ({\n          [`col-${a.value}`]: a.value !== void 0 && l.value === void 0,\n          [`bg-${t.variant}`]: t.variant !== null,\n          [`placeholder-${t.size}`]: t.size !== \"md\"\n        })),\n        n = i(() => ({\n          [`placeholder-${t.animation}`]: t.animation !== void 0\n        })),\n        s = i(() => ({\n          width: l.value === void 0 ? void 0 : `${l.value}%`\n        }));\n      return (r, u) => (y(), D(oe(r.wrapperTag), {\n        class: R(n.value)\n      }, {\n        default: j(() => [(y(), D(oe(r.tag), ae(r.$attrs, {\n          class: [\"placeholder\", o.value],\n          style: s.value\n        }), null, 16, [\"class\", \"style\"]))]),\n        _: 1\n      }, 8, [\"class\"]));\n    }\n  }),\n  Hn = /* @__PURE__ */H({\n    __name: \"BPlaceholderButton\",\n    props: {\n      tag: {\n        default: \"div\"\n      },\n      width: {\n        default: void 0\n      },\n      cols: {\n        default: void 0\n      },\n      variant: {\n        default: \"primary\"\n      },\n      animation: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = i(() => ({\n          [`btn-${t.variant}`]: t.variant !== null\n        })),\n        a = i(() => ({\n          animation: t.animation,\n          width: t.width,\n          cols: t.cols,\n          tag: t.tag\n        }));\n      return (o, n) => (y(), D(Re, ae({\n        class: [\"btn disabled\", l.value]\n      }, a.value), null, 16, [\"class\"]));\n    }\n  }),\n  sc = /* @__PURE__ */H({\n    __name: \"BPlaceholderCard\",\n    props: {\n      noHeader: {\n        type: [String, Boolean],\n        default: !1\n      },\n      headerWidth: {\n        default: 100\n      },\n      headerVariant: {\n        default: void 0\n      },\n      headerAnimation: {\n        default: void 0\n      },\n      headerSize: {\n        default: \"md\"\n      },\n      noFooter: {\n        type: [String, Boolean],\n        default: !1\n      },\n      footerWidth: {\n        default: 100\n      },\n      footerVariant: {\n        default: void 0\n      },\n      footerAnimation: {\n        default: void 0\n      },\n      footerSize: {\n        default: \"md\"\n      },\n      animation: {\n        default: void 0\n      },\n      size: {\n        default: \"md\"\n      },\n      variant: {\n        default: void 0\n      },\n      noButton: {\n        type: [String, Boolean],\n        default: !1\n      },\n      imgBottom: {\n        type: [String, Boolean],\n        default: !1\n      },\n      imgSrc: {\n        default: void 0\n      },\n      imgBlankColor: {\n        default: \"#868e96\"\n      },\n      imgHeight: {\n        default: 100\n      },\n      noImg: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = d(() => t.noButton),\n        a = d(() => t.noHeader),\n        o = d(() => t.noFooter),\n        n = d(() => t.noImg),\n        s = i(() => ({\n          width: t.headerWidth,\n          variant: t.headerVariant,\n          animation: t.headerAnimation,\n          size: t.headerSize\n        })),\n        r = i(() => ({\n          width: t.footerWidth,\n          animation: t.footerAnimation,\n          size: l.value ? t.footerSize : void 0,\n          variant: t.footerVariant\n        })),\n        u = i(() => ({\n          animation: t.animation,\n          size: t.size,\n          variant: t.variant\n        })),\n        f = i(() => ({\n          blank: !t.imgSrc,\n          blankColor: t.imgBlankColor,\n          height: t.imgSrc ? void 0 : t.imgHeight,\n          src: t.imgSrc,\n          top: !t.imgBottom,\n          bottom: t.imgBottom\n        }));\n      return (v, p) => (y(), D(bn, {\n        \"img-bottom\": v.imgBottom\n      }, fo({\n        default: j(() => [O(v.$slots, \"default\", {}, () => [_e(Re, ae({\n          cols: \"7\"\n        }, u.value), null, 16), _e(Re, ae({\n          cols: \"4\"\n        }, u.value), null, 16), _e(Re, ae({\n          cols: \"4\"\n        }, u.value), null, 16), _e(Re, ae({\n          cols: \"6\"\n        }, u.value), null, 16), _e(Re, ae({\n          cols: \"8\"\n        }, u.value), null, 16)])]),\n        _: 2\n      }, [$(n) ? void 0 : {\n        name: \"img\",\n        fn: j(() => [O(v.$slots, \"img\", {}, () => [_e(ia, $e(Ee(f.value)), null, 16)])]),\n        key: \"0\"\n      }, $(a) ? void 0 : {\n        name: \"header\",\n        fn: j(() => [O(v.$slots, \"header\", {}, () => [_e(Re, $e(Ee(s.value)), null, 16)])]),\n        key: \"1\"\n      }, $(o) ? void 0 : {\n        name: \"footer\",\n        fn: j(() => [O(v.$slots, \"footer\", {}, () => [$(l) ? (y(), D(Re, $e(ae({\n          key: 1\n        }, r.value)), null, 16)) : (y(), D(Hn, $e(ae({\n          key: 0\n        }, r.value)), null, 16))])]),\n        key: \"2\"\n      }]), 1032, [\"img-bottom\"]));\n    }\n  }),\n  rl = /* @__PURE__ */H({\n    __name: \"BTableSimple\",\n    props: {\n      bordered: {\n        type: [String, Boolean],\n        default: !1\n      },\n      borderless: {\n        type: [String, Boolean],\n        default: !1\n      },\n      borderVariant: {\n        default: null\n      },\n      captionTop: {\n        type: [String, Boolean],\n        default: !1\n      },\n      dark: {\n        type: [String, Boolean],\n        default: !1\n      },\n      hover: {\n        type: [String, Boolean],\n        default: !1\n      },\n      responsive: {\n        type: [Boolean, String],\n        default: !1\n      },\n      stacked: {\n        type: [Boolean, String],\n        default: !1\n      },\n      striped: {\n        type: [String, Boolean],\n        default: !1\n      },\n      small: {\n        type: [String, Boolean],\n        default: !1\n      },\n      tableClass: {\n        default: void 0\n      },\n      tableVariant: {\n        default: null\n      },\n      stickyHeader: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = d(() => t.captionTop),\n        a = d(() => t.borderless),\n        o = d(() => t.bordered),\n        n = d(() => t.dark),\n        s = d(() => t.hover),\n        r = d(() => t.small),\n        u = d(() => t.striped),\n        f = d(() => t.stickyHeader),\n        v = i(() => [\"table\", \"b-table\", {\n          \"table-bordered\": o.value,\n          \"table-borderless\": a.value,\n          [`border-${t.borderVariant}`]: t.borderVariant !== null,\n          \"caption-top\": l.value,\n          \"table-dark\": n.value,\n          \"table-hover\": s.value,\n          \"b-table-stacked\": typeof t.stacked == \"boolean\" && t.stacked,\n          [`b-table-stacked-${t.stacked}`]: typeof t.stacked == \"string\",\n          \"table-striped\": u.value,\n          \"table-sm\": r.value,\n          [`table-${t.tableVariant}`]: t.tableVariant !== null\n        }, t.tableClass]),\n        p = i(() => [{\n          \"table-responsive\": t.responsive === !0,\n          [`table-responsive-${t.responsive}`]: typeof t.responsive == \"string\",\n          \"b-table-sticky-header\": f.value\n        }]);\n      return (c, g) => c.responsive ? (y(), A(\"div\", {\n        key: 1,\n        class: R(p.value)\n      }, [Y(\"table\", {\n        class: R(v.value)\n      }, [O(c.$slots, \"default\")], 2)], 2)) : (y(), A(\"table\", {\n        key: 0,\n        class: R(v.value)\n      }, [O(c.$slots, \"default\")], 2));\n    }\n  }),\n  rc = /* @__PURE__ */H({\n    __name: \"BPlaceholderTable\",\n    props: {\n      rows: {\n        default: 3\n      },\n      columns: {\n        default: 5\n      },\n      cellWidth: {\n        default: 100\n      },\n      size: {\n        default: \"md\"\n      },\n      animation: {\n        default: void 0\n      },\n      variant: {\n        default: void 0\n      },\n      headerColumns: {\n        default: void 0\n      },\n      hideHeader: {\n        type: [String, Boolean],\n        default: !1\n      },\n      headerCellWidth: {\n        default: 100\n      },\n      headerSize: {\n        default: \"md\"\n      },\n      headerAnimation: {\n        default: void 0\n      },\n      headerVariant: {\n        default: void 0\n      },\n      footerColumns: {\n        default: void 0\n      },\n      showFooter: {\n        type: [String, Boolean],\n        default: !1\n      },\n      footerCellWidth: {\n        default: 100\n      },\n      footerSize: {\n        default: \"md\"\n      },\n      footerAnimation: {\n        default: void 0\n      },\n      footerVariant: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = bt(() => t.columns, {\n          nanToZero: !0,\n          method: \"parseInt\"\n        }),\n        a = bt(() => t.rows, {\n          nanToZero: !0,\n          method: \"parseInt\"\n        }),\n        o = i(() => t.headerColumns ?? NaN),\n        n = i(() => t.footerColumns ?? NaN),\n        s = bt(o, {\n          nanToZero: !0,\n          method: \"parseInt\"\n        }),\n        r = bt(n, {\n          nanToZero: !0,\n          method: \"parseInt\"\n        }),\n        u = i(() => l.value || 5),\n        f = i(() => a.value || 3),\n        v = i(() => t.headerColumns === void 0 ? u.value : s.value),\n        p = i(() => t.footerColumns === void 0 ? u.value : r.value),\n        c = i(() => ({\n          size: t.size,\n          variant: t.variant,\n          animation: t.animation,\n          width: t.cellWidth\n        })),\n        g = i(() => ({\n          size: t.headerSize,\n          variant: t.headerVariant,\n          animation: t.headerAnimation,\n          width: t.headerCellWidth\n        })),\n        B = i(() => ({\n          size: t.footerSize,\n          variant: t.footerVariant,\n          animation: t.footerAnimation,\n          width: t.footerCellWidth\n        })),\n        m = d(() => t.hideHeader),\n        V = d(() => t.showFooter);\n      return (b, T) => (y(), D(rl, null, {\n        default: j(() => [$(m) ? J(\"\", !0) : O(b.$slots, \"thead\", {\n          key: 0\n        }, () => [Y(\"thead\", null, [Y(\"tr\", null, [(y(!0), A(fe, null, we(v.value, (_, h) => (y(), A(\"th\", {\n          key: h\n        }, [_e(Re, $e(Ee(g.value)), null, 16)]))), 128))])])]), O(b.$slots, \"default\", {}, () => [Y(\"tbody\", null, [(y(!0), A(fe, null, we(f.value, (_, h) => (y(), A(\"tr\", {\n          key: h\n        }, [(y(!0), A(fe, null, we(u.value, (k, C) => (y(), A(\"td\", {\n          key: C\n        }, [_e(Re, $e(Ee(c.value)), null, 16)]))), 128))]))), 128))])]), $(V) ? O(b.$slots, \"tfoot\", {\n          key: 1\n        }, () => [Y(\"tfoot\", null, [Y(\"tr\", null, [(y(!0), A(fe, null, we(p.value, (_, h) => (y(), A(\"th\", {\n          key: h\n        }, [_e(Re, $e(Ee(B.value)), null, 16)]))), 128))])])]) : J(\"\", !0)]),\n        _: 3\n      }));\n    }\n  }),\n  ic = /* @__PURE__ */H({\n    __name: \"BPlaceholderWrapper\",\n    props: {\n      loading: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = d(() => t.loading);\n      return (a, o) => $(l) ? O(a.$slots, \"loading\", {\n        key: 0\n      }) : O(a.$slots, \"default\", {\n        key: 1\n      });\n    }\n  }),\n  uc = [\"aria-valuenow\", \"aria-valuemax\"],\n  Rn = /* @__PURE__ */H({\n    __name: \"BProgressBar\",\n    props: {\n      animated: {\n        type: [String, Boolean],\n        default: !1\n      },\n      label: {\n        default: void 0\n      },\n      labelHtml: {\n        default: void 0\n      },\n      max: {\n        default: void 0\n      },\n      precision: {\n        default: 0\n      },\n      showProgress: {\n        type: [String, Boolean],\n        default: !1\n      },\n      showValue: {\n        type: [String, Boolean],\n        default: !1\n      },\n      striped: {\n        type: [String, Boolean],\n        default: !1\n      },\n      value: {\n        default: 0\n      },\n      variant: {\n        default: null\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = Ie($o, null),\n        a = d(() => t.animated),\n        o = d(() => t.showProgress),\n        n = d(() => t.showValue),\n        s = d(() => t.striped),\n        r = i(() => ({\n          \"progress-bar-animated\": a.value || (l == null ? void 0 : l.animated.value),\n          \"progress-bar-striped\": s.value || (l == null ? void 0 : l.striped.value) || a.value || (l == null ? void 0 : l.animated.value),\n          [`bg-${t.variant}`]: t.variant !== null\n        })),\n        u = i(() => typeof t.precision == \"number\" ? t.precision : Number.parseFloat(t.precision)),\n        f = i(() => typeof t.value == \"number\" ? t.value : Number.parseFloat(t.value)),\n        v = i(() => typeof t.max == \"number\" ? t.max : t.max === void 0 ? void 0 : Number.parseFloat(t.max)),\n        p = i(() => t.labelHtml !== void 0 ? t.labelHtml : n.value || l != null && l.showValue.value ? f.value.toFixed(u.value) : o.value || l != null && l.showProgress.value ? (f.value * 100 / (v.value || 100)).toFixed(u.value) : t.label !== void 0 ? t.label : \"\"),\n        c = i(() => l != null && l.max.value ? `${f.value * 100 / (typeof l.max.value == \"number\" ? l.max.value : Number.parseInt(l.max.value))}%` : t.max ? `${f.value * 100 / (typeof t.max == \"number\" ? t.max : Number.parseInt(t.max))}%` : typeof t.value == \"string\" ? t.value : `${t.value}%`);\n      return (g, B) => (y(), A(\"div\", {\n        class: R([\"progress-bar\", r.value]),\n        role: \"progressbar\",\n        \"aria-valuenow\": g.value,\n        \"aria-valuemin\": \"0\",\n        \"aria-valuemax\": g.max,\n        style: De({\n          width: c.value\n        })\n      }, [O(g.$slots, \"default\", {}, () => [re(Z(p.value), 1)])], 14, uc));\n    }\n  }),\n  dc = /* @__PURE__ */H({\n    __name: \"BProgress\",\n    props: {\n      variant: {\n        default: void 0\n      },\n      max: {\n        default: 100\n      },\n      height: {\n        default: void 0\n      },\n      animated: {\n        type: [String, Boolean],\n        default: !1\n      },\n      precision: {\n        default: 0\n      },\n      showProgress: {\n        type: [String, Boolean],\n        default: !1\n      },\n      showValue: {\n        type: [String, Boolean],\n        default: !1\n      },\n      striped: {\n        type: [String, Boolean],\n        default: !1\n      },\n      value: {\n        default: 0\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = d(() => t.animated),\n        a = d(() => t.showProgress),\n        o = d(() => t.showValue),\n        n = d(() => t.striped),\n        s = i(() => ({\n          animated: t.animated,\n          max: t.max,\n          precision: t.precision,\n          showProgress: t.showProgress,\n          showValue: t.showValue,\n          striped: t.striped,\n          value: t.value,\n          variant: t.variant\n        }));\n      return Ke($o, {\n        animated: l,\n        max: Be(Ae(t, \"max\")),\n        showProgress: a,\n        showValue: o,\n        striped: n\n      }), (r, u) => (y(), A(\"div\", {\n        class: \"progress\",\n        style: De({\n          height: r.height\n        })\n      }, [O(r.$slots, \"default\", {}, () => [_e(Rn, $e(Ee(s.value)), null, 16)])], 4));\n    }\n  }),\n  oo = ca(\"cols\", [\"\"], {\n    type: [String, Number],\n    default: null\n  }),\n  cc = H({\n    name: \"BRow\",\n    slots: Object,\n    props: {\n      tag: {\n        type: String,\n        default: \"div\"\n      },\n      gutterX: {\n        type: String,\n        default: null\n      },\n      gutterY: {\n        type: String,\n        default: null\n      },\n      noGutters: {\n        type: [Boolean, String],\n        default: !1\n      },\n      alignV: {\n        type: String,\n        default: null\n      },\n      alignH: {\n        type: String,\n        default: null\n      },\n      alignContent: {\n        type: String,\n        default: null\n      },\n      ...oo\n    },\n    setup(e) {\n      const t = d(() => e.noGutters),\n        l = jt(() => e.alignH),\n        a = i(() => So(e, oo, \"cols\", \"row-cols\"));\n      return {\n        computedClasses: i(() => [a.value, {\n          [`gx-${e.gutterX}`]: e.gutterX !== null,\n          [`gy-${e.gutterY}`]: e.gutterY !== null,\n          \"g-0\": t.value,\n          [`align-items-${e.alignV}`]: e.alignV !== null,\n          [l.value]: e.alignH !== null,\n          [`align-content-${e.alignContent}`]: e.alignContent !== null\n        }])\n      };\n    }\n  });\nfunction fc(e, t, l, a, o, n) {\n  return y(), D(oe(e.tag), {\n    class: R([\"row\", e.computedClasses])\n  }, {\n    default: j(() => [O(e.$slots, \"default\")]),\n    _: 3\n  }, 8, [\"class\"]);\n}\nconst vc = /* @__PURE__ */ll(cc, [[\"render\", fc]]),\n  pc = [\"TD\", \"TH\", \"TR\"],\n  mc = [\"a\", \"a *\",\n  // Include content inside links\n  \"button\", \"button *\",\n  // Include content inside buttons\n  \"input:not(.disabled):not([disabled])\", \"select:not(.disabled):not([disabled])\", \"textarea:not(.disabled):not([disabled])\", '[role=\"link\"]', '[role=\"link\"] *', '[role=\"button\"]', '[role=\"button\"] *', \"[tabindex]:not(.disabled):not([disabled])\"].join(\",\"),\n  Xt = e => {\n    if (!e || !e.target) return !1;\n    const t = e.target;\n    if (\"disabled\" in t && t.disabled || pc.indexOf(t.tagName) !== -1) return !1;\n    if (fl(\".dropdown-menu\", t)) return !0;\n    const l = t.tagName === \"LABEL\" ? t : fl(\"label\", t);\n    if (l) {\n      const a = Ga(l, \"for\"),\n        o = a ? Ts(a) : ho(\"input, select, textarea\", l);\n      if (o && !o.disabled) return !0;\n    }\n    return Bo(t, mc);\n  },\n  gc = () => {\n    const e = (f, v) => {\n        const p = [];\n        return !(f != null && f.length) && v != null && v.length ? (Object.keys(v[0]).forEach(c => p.push({\n          key: c,\n          label: il(c)\n        })), p) : (Array.isArray(f) && f.forEach(c => {\n          typeof c == \"string\" ? p.push({\n            key: c,\n            label: il(c)\n          }) : Sa(c) && c.key && typeof c.key == \"string\" && p.push({\n            ...c\n          });\n        }), p);\n      },\n      t = M([]),\n      l = (f, v, p, c) => (t.value = ea(v), \"isFilterableTable\" in c && c.isFilterableTable.value === !0 && p.filter && (t.value = n(t.value, p.filter, p.filterable)), \"isSortable\" in c && c.isSortable.value === !0 && (t.value = o(f, t.value, {\n        key: p.sortBy,\n        desc: c.sortDescBoolean.value\n      }, p.sortCompare)), t.value),\n      a = M(void 0),\n      o = (f, v, p, c) => {\n        if (!p || !p.key) return v;\n        const g = p.key;\n        return v.sort((B, m) => {\n          if (c !== void 0) return c(B, m, p.key, p.desc);\n          const V = _ => typeof _ == \"object\" ? JSON.stringify(_) : _;\n          return V(B[g]) > V(m[g]) ? p.desc ? -1 : 1 : V(m[g]) > V(B[g]) ? p.desc ? 1 : -1 : 0;\n        });\n      },\n      n = (f, v, p) => f.filter(c => Object.entries(c).filter(g => {\n        const [B, m] = g;\n        return !m || B[0] === \"_\" || p.length > 0 && !p.includes(B) ? !1 : (typeof m == \"object\" ? JSON.stringify(Object.values(m)) : typeof m == \"string\" ? m : m.toString()).toLowerCase().includes(v.toLowerCase());\n      }).length > 0);\n    return {\n      normaliseFields: e,\n      mapItems: l,\n      internalItems: t,\n      updateInternalItems: async f => {\n        try {\n          return t.value = await wa(f), t.value;\n        } catch {\n          return;\n        }\n      },\n      filterEvent: a,\n      notifyFilteredItems: () => {\n        a.value && a.value(t.value);\n      },\n      formatItem: (f, v) => {\n        const p = f[v.key];\n        return v.formatter && typeof v.formatter == \"function\" ? v.formatter(p, v.key, f) : f[v.key];\n      }\n    };\n  },\n  yc = [\"title\", \"abbr\", \"onClick\"],\n  bc = {\n    class: \"d-inline-flex flex-nowrap align-items-center gap-1\"\n  },\n  hc = {\n    key: 1\n  },\n  Bc = [\"onClick\", \"onDblclick\", \"onMouseenter\", \"onMouseleave\"],\n  Sc = {\n    key: 0,\n    class: \"b-table-stacked-label\"\n  },\n  _c = [\"colspan\"],\n  wc = [\"colspan\"],\n  $c = {\n    class: \"d-flex align-items-center justify-content-center gap-2\"\n  },\n  kc = /* @__PURE__ */Y(\"strong\", null, \"Loading...\", -1),\n  Cc = {\n    key: 1,\n    class: \"b-table-empty-slot\"\n  },\n  Tc = [\"colspan\"],\n  Vc = {\n    key: 0\n  },\n  Oc = [\"title\", \"abbr\", \"onClick\"],\n  Ac = {\n    key: 1\n  },\n  Pc = {\n    key: 2\n  },\n  Ec = {\n    key: 3\n  },\n  Fc = /* @__PURE__ */H({\n    __name: \"BTable\",\n    props: {\n      align: {\n        default: void 0\n      },\n      caption: {\n        default: void 0\n      },\n      captionTop: {\n        type: [String, Boolean],\n        default: !1\n      },\n      borderless: {\n        type: [String, Boolean],\n        default: !1\n      },\n      bordered: {\n        type: [String, Boolean],\n        default: !1\n      },\n      borderVariant: {\n        default: void 0\n      },\n      dark: {\n        type: [String, Boolean],\n        default: !1\n      },\n      fields: {\n        default: () => []\n      },\n      footClone: {\n        type: [String, Boolean],\n        default: !1\n      },\n      hover: {\n        type: [String, Boolean],\n        default: !1\n      },\n      items: {\n        default: () => []\n      },\n      provider: {\n        type: Function,\n        default: void 0\n      },\n      sortCompare: {\n        type: Function,\n        default: void 0\n      },\n      noProvider: {\n        default: void 0\n      },\n      noProviderPaging: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      noProviderSorting: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      noProviderFiltering: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      responsive: {\n        type: [Boolean, String],\n        default: !1\n      },\n      small: {\n        type: [String, Boolean],\n        default: !1\n      },\n      striped: {\n        type: [String, Boolean],\n        default: !1\n      },\n      stacked: {\n        type: [Boolean, String],\n        default: !1\n      },\n      labelStacked: {\n        type: Boolean,\n        default: !1\n      },\n      variant: {\n        default: void 0\n      },\n      sortBy: {\n        default: void 0\n      },\n      sortDesc: {\n        type: [String, Boolean],\n        default: !1\n      },\n      sortInternal: {\n        type: [String, Boolean],\n        default: !0\n      },\n      selectable: {\n        type: [String, Boolean],\n        default: !1\n      },\n      stickySelect: {\n        type: [String, Boolean],\n        default: !1\n      },\n      selectHead: {\n        type: [Boolean, String],\n        default: !0\n      },\n      selectMode: {\n        default: \"single\"\n      },\n      selectionVariant: {\n        default: \"primary\"\n      },\n      stickyHeader: {\n        type: [String, Boolean],\n        default: !1\n      },\n      busy: {\n        type: [String, Boolean],\n        default: !1\n      },\n      showEmpty: {\n        type: [String, Boolean],\n        default: !1\n      },\n      perPage: {\n        default: void 0\n      },\n      currentPage: {\n        default: 1\n      },\n      filter: {\n        default: void 0\n      },\n      filterable: {\n        default: void 0\n      },\n      emptyText: {\n        default: \"There are no records to show\"\n      },\n      emptyFilteredText: {\n        default: \"There are no records matching your request\"\n      }\n    },\n    emits: [\"headClicked\", \"rowClicked\", \"rowDblClicked\", \"rowHovered\", \"rowUnhovered\", \"rowSelected\", \"rowUnselected\", \"selection\", \"update:busy\", \"update:sortBy\", \"update:sortDesc\", \"sorted\", \"filtered\"],\n    setup(e, {\n      expose: t,\n      emit: l\n    }) {\n      const a = e,\n        o = ke(a, \"sortBy\", l),\n        n = ke(a, \"busy\", l, {\n          passive: !0\n        }),\n        s = ke(a, \"sortDesc\", l, {\n          passive: !0\n        }),\n        r = xe(),\n        u = gc(),\n        f = d(() => a.footClone),\n        v = d(s),\n        p = d(() => a.sortInternal),\n        c = d(() => a.selectable),\n        g = d(() => a.stickySelect),\n        B = d(() => a.labelStacked),\n        m = d(n),\n        V = d(() => a.showEmpty),\n        b = d(() => a.noProviderPaging),\n        T = d(() => a.noProviderSorting),\n        _ = d(() => a.noProviderFiltering);\n      u.filterEvent.value = async E => {\n        if (I.value) {\n          await ne();\n          return;\n        }\n        const W = await wa(E);\n        l(\"filtered\", W);\n      };\n      const h = M( /* @__PURE__ */new Set([])),\n        k = i(() => h.value.size > 0),\n        C = i(() => ({\n          [`align-${a.align}`]: a.align !== void 0,\n          \"b-table-selectable\": c.value,\n          [`b-table-select-${a.selectMode}`]: c.value,\n          \"b-table-selecting user-select-none\": c.value && k.value,\n          \"b-table-busy\": m.value,\n          \"b-table-sortable\": z.value,\n          \"b-table-sort-desc\": z.value && v.value === !0,\n          \"b-table-sort-asc\": z.value && v.value === !1\n        })),\n        w = i(() => ({\n          bordered: a.bordered,\n          borderless: a.borderless,\n          borderVariant: a.borderVariant,\n          captionTop: a.captionTop,\n          dark: a.dark,\n          hover: a.hover,\n          responsive: a.responsive,\n          striped: a.striped,\n          stacked: a.stacked,\n          small: a.small,\n          tableClass: C.value,\n          tableVariant: a.variant,\n          stickyHeader: a.stickyHeader\n        })),\n        P = i(() => u.normaliseFields(a.fields, a.items)),\n        F = i(() => P.value.length + (c.value ? 1 : 0)),\n        S = i(() => a.filter !== void 0 && a.filter !== \"\"),\n        I = i(() => a.provider !== void 0),\n        x = i(() => c.value && (!!a.selectHead || r.selectHead !== void 0)),\n        z = i(() => a.fields.filter(E => typeof E == \"string\" ? !1 : E.sortable).length > 0),\n        te = i(() => z.value && p.value === !0),\n        Q = i(() => {\n          const E = I.value ? u.internalItems.value : te.value ? u.mapItems(a.fields, a.items, a, {\n            isSortable: z,\n            isFilterableTable: S,\n            sortDescBoolean: v\n          }) : a.items;\n          if (I.value && !b.value) return E;\n          if (a.perPage !== void 0) {\n            const W = (a.currentPage - 1) * a.perPage,\n              ge = W + a.perPage > E.length ? E.length : W + a.perPage;\n            return E.slice(W, ge);\n          }\n          return E;\n        }),\n        G = E => typeof E == \"string\" ? ul(E) : E.label !== void 0 ? E.label : typeof E.key == \"string\" ? ul(E.key) : E.key,\n        X = (E, W, ge = !1) => {\n          const L = typeof E == \"string\" ? E : E.key;\n          l(\"headClicked\", L, E, W, ge), ye(E);\n        },\n        U = (E, W, ge) => {\n          l(\"rowClicked\", E, W, ge), ee(E, W, ge.shiftKey, ge.ctrlKey, ge.metaKey);\n        },\n        pe = (E, W, ge) => l(\"rowDblClicked\", E, W, ge),\n        be = (E, W, ge) => l(\"rowHovered\", E, W, ge),\n        he = (E, W, ge) => l(\"rowUnhovered\", E, W, ge),\n        ye = E => {\n          if (!z.value) return;\n          const W = typeof E == \"string\" ? E : E.key,\n            ge = typeof E == \"string\" ? !1 : E.sortable;\n          if (z.value === !0 && ge === !0) {\n            const L = !v.value;\n            W !== a.sortBy && (o.value = W), s.value = L, l(\"sorted\", W, L);\n          }\n        },\n        q = () => {\n          c.value && l(\"selection\", Array.from(h.value));\n        },\n        ee = (E, W, ge = !1, L = !1, me = !1) => {\n          if (c.value) {\n            if (ge && a.selectMode === \"range\" && h.value.size > 0) {\n              const ve = Array.from(h.value).pop(),\n                qt = Q.value.findIndex(At => At === ve),\n                ga = Math.min(qt, W),\n                ya = Math.max(qt, W);\n              Q.value.slice(ga, ya + 1).forEach(At => {\n                h.value.has(At) || (h.value.add(At), l(\"rowSelected\", At));\n              });\n            } else L || me ? h.value.has(E) ? (h.value.delete(E), l(\"rowUnselected\", E)) : a.selectMode === \"range\" || a.selectMode === \"multi\" ? (h.value.add(E), l(\"rowSelected\", E)) : (h.value.forEach(ve => l(\"rowUnselected\", ve)), h.value.clear(), h.value.add(E), l(\"rowSelected\", E)) : (h.value.forEach(ve => l(\"rowUnselected\", ve)), h.value.clear(), h.value.add(E), l(\"rowSelected\", E));\n            q();\n          }\n        },\n        ne = async () => {\n          if (!I.value || !a.provider || m.value) return;\n          n.value = !0;\n          const E = new Proxy({\n              currentPage: a.currentPage,\n              filter: a.filter,\n              sortBy: a.sortBy,\n              sortDesc: a.sortDesc,\n              perPage: a.perPage\n            }, {\n              get: (ge, L) => L in ge ? ge[L] : void 0,\n              set: () => (console.error(\"BTable provider context is a read-only object.\"), !0)\n            }),\n            W = a.provider(E, u.updateInternalItems);\n          if (W !== void 0) {\n            if (W instanceof Promise) try {\n              const ge = await W;\n              return Array.isArray(ge) ? await u.updateInternalItems(ge) : void 0;\n            } finally {\n              m.value && (n.value = !1);\n            }\n            try {\n              return await u.updateInternalItems(W);\n            } finally {\n              m.value && (n.value = !1);\n            }\n          }\n        },\n        ue = E => {\n          E._showDetails = !E._showDetails;\n        },\n        N = E => [E.class, E.thClass, {\n          [`table-${E.variant}`]: E.variant !== null,\n          \"b-table-sortable-column\": z.value && E.sortable,\n          \"b-table-sticky-column\": E.stickyColumn\n        }],\n        le = (E, W) => [E.class, E.tdClass, W != null && W._cellVariants && W != null && W._cellVariants[E.key] ? `table-${W == null ? void 0 : W._cellVariants[E.key]}` : void 0, {\n          [`table-${E.variant}`]: E.variant !== null,\n          \"b-table-sticky-column\": E.stickyColumn\n        }],\n        de = E => [E._rowVariant ? `table-${E._rowVariant}` : null, E._rowVariant ? `table-${E._rowVariant}` : null, c.value && h.value.has(E) ? `selected table-${a.selectionVariant}` : null],\n        Se = () => {\n          if (!c.value) return;\n          const E = h.value.size > 0 ? Array.from(h.value) : [];\n          h.value = /* @__PURE__ */new Set([...Q.value]), h.value.forEach(W => {\n            E.includes(W) || l(\"rowSelected\", W);\n          }), q();\n        },\n        Ce = () => {\n          c.value && (h.value.forEach(E => {\n            l(\"rowUnselected\", E);\n          }), h.value = /* @__PURE__ */new Set([]), q());\n        },\n        K = E => {\n          if (!c.value) return;\n          const W = Q.value[E];\n          !W || h.value.has(W) || (h.value.add(W), l(\"rowSelected\", W), q());\n        },\n        ce = E => {\n          if (!c.value) return;\n          const W = Q.value[E];\n          !W || !h.value.has(W) || (h.value.delete(W), l(\"rowUnselected\", W), q());\n        },\n        Le = async (E, W, ge) => {\n          if (W === ge) return;\n          const L = ya => a.noProvider && a.noProvider.includes(ya),\n            me = ![\"currentPage\", \"perPage\"].includes(E),\n            ve = [\"currentPage\", \"perPage\"].includes(E) && (L(\"paging\") || b.value === !0),\n            qt = [\"filter\"].includes(E) && (L(\"filtering\") || _.value === !0),\n            ga = [\"sortBy\", \"sortDesc\"].includes(E) && (L(\"sorting\") || T.value === !0);\n          ve || qt || ga || (await ne(), me && u.notifyFilteredItems());\n        };\n      return se(() => a.filter, (E, W) => {\n        E === W || I.value || E || wa(a.items).then(ge => l(\"filtered\", ge));\n      }), se(() => a.filter, (E, W) => Le(\"filter\", E, W)), se(() => a.currentPage, (E, W) => Le(\"currentPage\", E, W)), se(() => a.perPage, (E, W) => Le(\"perPage\", E, W)), se(() => a.sortBy, (E, W) => Le(\"sortBy\", E, W)), se(() => a.sortDesc, (E, W) => Le(\"sortDesc\", E, W)), qe(() => {\n        I.value && ne();\n      }), t({\n        selectAllRows: Se,\n        clearSelected: Ce,\n        selectRow: K,\n        unselectRow: ce,\n        refresh: ne\n      }), (E, W) => (y(), D(rl, $e(Ee(w.value)), {\n        default: j(() => {\n          var ge;\n          return [Y(\"thead\", null, [E.$slots[\"thead-top\"] ? O(E.$slots, \"thead-top\", {\n            key: 0\n          }) : J(\"\", !0), Y(\"tr\", null, [x.value ? (y(), A(\"th\", {\n            key: 0,\n            class: R([\"b-table-selection-column\", {\n              \"b-table-sticky-column\": $(g)\n            }])\n          }, [O(E.$slots, \"select-head\", {}, () => [re(Z(typeof E.selectHead == \"boolean\" ? \"Selected\" : E.selectHead), 1)])], 2)) : J(\"\", !0), (y(!0), A(fe, null, we(P.value, L => (y(), A(\"th\", ae({\n            key: L.key,\n            scope: \"col\",\n            class: N(L),\n            title: L.headerTitle,\n            abbr: L.headerAbbr,\n            style: L.thStyle\n          }, L.thAttr, {\n            onClick: me => X(L, me)\n          }), [Y(\"div\", bc, [O(E.$slots, \"sort-icon\", {\n            field: L,\n            sortBy: E.sortBy,\n            selected: L.key === E.sortBy,\n            isDesc: $(v),\n            direction: $(v) ? \"desc\" : \"asc\"\n          }, () => [z.value && L.sortable ? (y(), A(\"span\", {\n            key: 0,\n            class: R([\"b-table-sort-icon\", {\n              sorted: L.key === E.sortBy,\n              [`sorted-${$(v) ? \"desc\" : \"asc\"}`]: L.key === E.sortBy\n            }])\n          }, null, 2)) : J(\"\", !0)]), Y(\"div\", null, [E.$slots[\"head(\" + L.key + \")\"] || E.$slots[\"head()\"] ? O(E.$slots, E.$slots[\"head(\" + L.key + \")\"] ? \"head(\" + L.key + \")\" : \"head()\", {\n            key: 0,\n            label: L.label,\n            column: L.key,\n            field: L,\n            isFoot: !1,\n            selectAllRows: Se,\n            clearSelected: Ce\n          }) : (y(), A(fe, {\n            key: 1\n          }, [re(Z(G(L)), 1)], 64))])])], 16, yc))), 128))]), E.$slots[\"thead-sub\"] ? (y(), A(\"tr\", hc, [(y(!0), A(fe, null, we(P.value, L => (y(), A(\"td\", {\n            key: L.key,\n            scope: \"col\",\n            class: R([L.class, L.thClass, L.variant ? `table-${L.variant}` : \"\"])\n          }, [E.$slots[\"thead-sub\"] ? O(E.$slots, \"thead-sub\", ae({\n            key: 0,\n            items: P.value\n          }, L)) : (y(), A(fe, {\n            key: 1\n          }, [re(Z(L.label), 1)], 64))], 2))), 128))])) : J(\"\", !0)]), Y(\"tbody\", null, [(y(!0), A(fe, null, we(Q.value, (L, me) => (y(), A(fe, {\n            key: me\n          }, [Y(\"tr\", {\n            class: R(de(L)),\n            onClick: ve => !$(Xt)(ve) && U(L, me, ve),\n            onDblclick: ve => !$(Xt)(ve) && pe(L, me, ve),\n            onMouseenter: ve => !$(Xt)(ve) && be(L, me, ve),\n            onMouseleave: ve => !$(Xt)(ve) && he(L, me, ve)\n          }, [x.value ? (y(), A(\"td\", {\n            key: 0,\n            class: R([\"b-table-selection-column\", {\n              \"b-table-sticky-column\": $(g)\n            }])\n          }, [O(E.$slots, \"select-cell\", {}, () => [Y(\"span\", {\n            class: R(h.value.has(L) ? \"text-primary\" : \"\")\n          }, \"ð¹\", 2)])], 2)) : J(\"\", !0), (y(!0), A(fe, null, we(P.value, ve => (y(), A(\"td\", ae({\n            key: ve.key\n          }, ve.tdAttr, {\n            class: le(ve, L)\n          }), [E.stacked && $(B) ? (y(), A(\"label\", Sc, Z(G(ve)), 1)) : J(\"\", !0), E.$slots[\"cell(\" + ve.key + \")\"] || E.$slots[\"cell()\"] ? O(E.$slots, E.$slots[\"cell(\" + ve.key + \")\"] ? \"cell(\" + ve.key + \")\" : \"cell()\", {\n            key: 1,\n            value: L[ve.key],\n            index: me,\n            item: L,\n            field: ve,\n            items: E.items,\n            toggleDetails: () => ue(L),\n            detailsShowing: L._showDetails\n          }) : (y(), A(fe, {\n            key: 2\n          }, [re(Z($(u).formatItem(L, ve)), 1)], 64))], 16))), 128))], 42, Bc), L._showDetails === !0 && E.$slots[\"row-details\"] ? (y(), A(\"tr\", {\n            key: 0,\n            class: R(de(L))\n          }, [Y(\"td\", {\n            colspan: F.value\n          }, [O(E.$slots, \"row-details\", {\n            item: L,\n            toggleDetails: () => ue(L)\n          })], 8, _c)], 2)) : J(\"\", !0)], 64))), 128)), $(m) ? (y(), A(\"tr\", {\n            key: 0,\n            class: R([\"b-table-busy-slot\", {\n              \"b-table-static-busy\": Q.value.length === 0\n            }])\n          }, [Y(\"td\", {\n            colspan: F.value\n          }, [O(E.$slots, \"table-busy\", {}, () => [Y(\"div\", $c, [_e(ma, {\n            class: \"align-middle\"\n          }), kc])])], 8, wc)], 2)) : J(\"\", !0), $(V) && Q.value.length === 0 ? (y(), A(\"tr\", Cc, [Y(\"td\", {\n            colspan: F.value\n          }, [O(E.$slots, \"empty\", {\n            items: Q.value,\n            filtered: S.value\n          }, () => [re(Z(S.value ? E.emptyFilteredText : E.emptyText), 1)])], 8, Tc)])) : J(\"\", !0)]), $(f) ? (y(), A(\"tfoot\", Vc, [Y(\"tr\", null, [(y(!0), A(fe, null, we(P.value, L => (y(), A(\"th\", ae({\n            key: L.key\n          }, L.thAttr, {\n            scope: \"col\",\n            class: [L.class, L.thClass, L.variant ? `table-${L.variant}` : \"\"],\n            title: L.headerTitle,\n            abbr: L.headerAbbr,\n            style: L.thStyle,\n            onClick: me => X(L, me, !0)\n          }), Z(L.label), 17, Oc))), 128))])])) : E.$slots[\"custom-foot\"] ? (y(), A(\"tfoot\", Ac, [O(E.$slots, \"custom-foot\", {\n            fields: P.value,\n            items: E.items,\n            columns: (ge = P.value) == null ? void 0 : ge.length\n          })])) : J(\"\", !0), E.$slots[\"table-caption\"] ? (y(), A(\"caption\", Pc, [O(E.$slots, \"table-caption\")])) : E.caption ? (y(), A(\"caption\", Ec, Z(E.caption), 1)) : J(\"\", !0)];\n        }),\n        _: 3\n      }, 16));\n    }\n  }),\n  Ic = /* @__PURE__ */H({\n    __name: \"BTbody\",\n    props: {\n      variant: {\n        default: null\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = i(() => ({\n          [`thead-${t.variant}`]: t.variant !== null\n        }));\n      return (a, o) => (y(), A(\"tbody\", {\n        class: R(l.value)\n      }, [O(a.$slots, \"default\")], 2));\n    }\n  }),\n  xc = [\"scope\", \"colspan\", \"rowspan\", \"data-label\"],\n  Lc = {\n    key: 0\n  },\n  Nc = /* @__PURE__ */H({\n    __name: \"BTd\",\n    props: {\n      colspan: {\n        default: void 0\n      },\n      rowspan: {\n        default: void 0\n      },\n      stackedHeading: {\n        default: void 0\n      },\n      stickyColumn: {\n        type: [String, Boolean],\n        default: !1\n      },\n      variant: {\n        default: null\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = d(() => t.stickyColumn),\n        a = i(() => ({\n          [`table-${t.variant}`]: t.variant !== null,\n          \"b-table-sticky-column\": l.value,\n          \"table-b-table-default\": l.value && t.variant === null\n        })),\n        o = i(() => t.colspan ? \"colspan\" : t.rowspan ? \"rowspan\" : \"col\");\n      return (n, s) => (y(), A(\"td\", {\n        scope: o.value,\n        class: R(a.value),\n        colspan: n.colspan,\n        rowspan: n.rowspan,\n        \"data-label\": n.stackedHeading\n      }, [n.stackedHeading ? (y(), A(\"div\", Lc, [O(n.$slots, \"default\")])) : O(n.$slots, \"default\", {\n        key: 1\n      })], 10, xc));\n    }\n  }),\n  zc = /* @__PURE__ */H({\n    __name: \"BTfoot\",\n    props: {\n      variant: {\n        default: null\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = i(() => ({\n          [`table-${t.variant}`]: t.variant !== null\n        }));\n      return (a, o) => (y(), A(\"tfoot\", {\n        class: R(l.value)\n      }, [O(a.$slots, \"default\")], 2));\n    }\n  }),\n  Hc = [\"scope\", \"colspan\", \"rowspan\", \"data-label\"],\n  Rc = {\n    key: 0\n  },\n  Mc = /* @__PURE__ */H({\n    __name: \"BTh\",\n    props: {\n      colspan: {\n        default: void 0\n      },\n      rowspan: {\n        default: void 0\n      },\n      stackedHeading: {\n        default: void 0\n      },\n      stickyColumn: {\n        type: [String, Boolean],\n        default: !1\n      },\n      variant: {\n        default: null\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = d(() => t.stickyColumn),\n        a = i(() => ({\n          [`table-${t.variant}`]: t.variant !== null,\n          \"b-table-sticky-column\": l.value,\n          \"table-b-table-default\": l.value && t.variant === null\n        })),\n        o = i(() => t.colspan ? \"colspan\" : t.rowspan ? \"rowspan\" : \"col\");\n      return (n, s) => (y(), A(\"th\", {\n        scope: o.value,\n        class: R(a.value),\n        colspan: n.colspan,\n        rowspan: n.rowspan,\n        \"data-label\": n.stackedHeading\n      }, [n.stackedHeading !== void 0 ? (y(), A(\"div\", Rc, [O(n.$slots, \"default\")])) : O(n.$slots, \"default\", {\n        key: 1\n      })], 10, Hc));\n    }\n  }),\n  Dc = /* @__PURE__ */H({\n    __name: \"BThead\",\n    props: {\n      variant: {\n        default: null\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = i(() => ({\n          [`table-${t.variant}`]: t.variant !== null\n        }));\n      return (a, o) => (y(), A(\"thead\", {\n        class: R(l.value)\n      }, [O(a.$slots, \"default\")], 2));\n    }\n  }),\n  jc = /* @__PURE__ */H({\n    __name: \"BTr\",\n    props: {\n      variant: {\n        default: null\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = i(() => ({\n          [`table-${t.variant}`]: t.variant !== null\n        }));\n      return (a, o) => (y(), A(\"tr\", {\n        class: R(l.value)\n      }, [O(a.$slots, \"default\")], 2));\n    }\n  }),\n  qc = /* @__PURE__ */H({\n    __name: \"BTab\",\n    props: {\n      id: {\n        default: void 0\n      },\n      title: {\n        default: void 0\n      },\n      active: {\n        type: [String, Boolean],\n        default: !1\n      },\n      buttonId: {\n        default: void 0\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      lazy: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      lazyOnce: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      noBody: {\n        type: [Boolean, String],\n        default: !1\n      },\n      tag: {\n        default: \"div\"\n      },\n      titleItemClass: {\n        default: void 0\n      },\n      titleLinkAttributes: {\n        default: void 0\n      },\n      titleLinkClass: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = e,\n        l = Ie(wo, null),\n        a = d(() => t.active),\n        o = d(() => t.disabled),\n        n = d(i(() => t.lazyOnce !== void 0 ? t.lazyOnce : t.lazy)),\n        s = M(!1),\n        r = i(() => !!(l != null && l.lazy.value || n.value)),\n        u = i(() => t.lazyOnce !== void 0),\n        f = i(() => a.value && !o.value),\n        v = i(() => {\n          const g = r.value && u.value && s.value;\n          return f.value || !r.value || g;\n        }),\n        p = M(a.value);\n      se(a, g => {\n        setTimeout(() => {\n          p.value = g;\n        }, 0);\n      });\n      const c = i(() => ({\n        active: a.value,\n        show: p.value,\n        \"card-body\": (l == null ? void 0 : l.card.value) && t.noBody === !1\n      }));\n      return se(v, g => {\n        g && !s.value && (s.value = !0);\n      }), (g, B) => (y(), D(oe(g.tag), {\n        id: g.id,\n        class: R([\"tab-pane\", c.value]),\n        role: \"tabpanel\",\n        \"aria-labelledby\": \"profile-tab\"\n      }, {\n        default: j(() => [v.value ? O(g.$slots, \"default\", {\n          key: 0\n        }) : J(\"\", !0)]),\n        _: 3\n      }, 8, [\"id\", \"class\"]));\n    }\n  }),\n  Gc = [\"id\", \"data-bs-target\", \"aria-controls\", \"aria-selected\", \"onClick\"],\n  Wc = /* @__PURE__ */H({\n    __name: \"BTabs\",\n    props: {\n      activeNavItemClass: {\n        default: void 0\n      },\n      activeTabClass: {\n        default: void 0\n      },\n      align: {\n        default: void 0\n      },\n      contentClass: {\n        default: void 0\n      },\n      card: {\n        type: [String, Boolean],\n        default: !1\n      },\n      end: {\n        type: [String, Boolean],\n        default: !1\n      },\n      fill: {\n        type: [String, Boolean],\n        default: !1\n      },\n      id: {\n        default: void 0\n      },\n      justified: {\n        type: [String, Boolean],\n        default: !1\n      },\n      lazy: {\n        type: [String, Boolean],\n        default: !1\n      },\n      navClass: {\n        default: void 0\n      },\n      navWrapperClass: {\n        default: void 0\n      },\n      noFade: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noNavStyle: {\n        type: [String, Boolean],\n        default: !1\n      },\n      pills: {\n        type: [String, Boolean],\n        default: !1\n      },\n      small: {\n        type: [String, Boolean],\n        default: !1\n      },\n      tag: {\n        default: \"div\"\n      },\n      vertical: {\n        type: [String, Boolean],\n        default: !1\n      },\n      modelValue: {\n        default: -1\n      }\n    },\n    emits: [\"update:modelValue\", \"activate-tab\", \"click\"],\n    setup(e, {\n      emit: t\n    }) {\n      const l = e,\n        a = ke(l, \"modelValue\", t),\n        o = xe(),\n        n = d(() => l.card),\n        s = d(() => l.end),\n        r = d(() => l.fill),\n        u = d(() => l.justified),\n        f = d(() => l.lazy),\n        v = d(() => l.noFade),\n        p = d(() => l.noNavStyle),\n        c = d(() => l.pills),\n        g = d(() => l.small),\n        B = d(() => l.vertical),\n        m = M(a.value),\n        V = M(\"\"),\n        b = i({\n          get: () => m.value,\n          set: S => {\n            m.value = S, _.value.length > 0 && S >= 0 && S < _.value.length ? V.value = _.value[S].buttonId : V.value = \"\", a.value = S;\n          }\n        }),\n        T = M([]);\n      se(() => {\n        var S;\n        return (S = o.default) == null ? void 0 : S.call(o);\n      }, () => {\n        T.value = o.default === void 0 ? [] : $a(o.default, \"BTab\").map((S, I) => {\n          S.props || (S.props = {});\n          const x = S.props[\"button-id\"] || lt(\"tab\"),\n            z = S.props.id || lt(),\n            te = S.props[\"title-item-class\"],\n            Q = S.props[\"title-link-attributes\"];\n          return {\n            buttonId: x,\n            contentId: z,\n            disabled: S.props.disabled === \"\" || S.props.disabled === !0,\n            target: `#${z}`,\n            title: S.props.title,\n            titleItemClass: te,\n            titleLinkAttributes: Q,\n            onClick: S.props.onClick,\n            tab: S,\n            tabComponent: () => $a(o.default, \"BTab\")[I]\n          };\n        });\n      }, {\n        immediate: !0\n      });\n      const _ = i(() => T.value.map((S, I) => {\n          const {\n            tab: x\n          } = S;\n          x.props || (x.props = {});\n          const z = b.value > -1 ? I === b.value : x.props.active === \"\";\n          return {\n            ...S,\n            active: z,\n            navItemClasses: [{\n              active: z,\n              disabled: x.props.disabled === \"\" || x.props.disabled === !0\n            }, z && l.activeNavItemClass ? l.activeNavItemClass : null, x.props[\"title-link-class\"]],\n            tabClasses: [{\n              fade: !v.value\n            }, z && l.activeTabClass ? l.activeTabClass : null]\n          };\n        })),\n        h = i(() => !(_ != null && _.value && _.value.length > 0)),\n        k = i(() => ({\n          \"d-flex\": B.value,\n          \"align-items-start\": B.value\n        })),\n        C = jt(() => l.align),\n        w = i(() => ({\n          \"nav-pills\": c.value,\n          \"flex-column me-3\": B.value,\n          [C.value]: l.align !== void 0,\n          \"nav-fill\": r.value,\n          \"card-header-tabs\": n.value,\n          \"nav-justified\": u.value,\n          \"nav-tabs\": !p.value && !c.value,\n          small: g.value\n        })),\n        P = S => {\n          let I = !1;\n          if (S !== void 0 && S > -1 && S < _.value.length && !_.value[S].disabled && (b.value < 0 || _.value[S].buttonId !== V.value)) {\n            const x = new Je(\"activate-tab\", {\n              cancelable: !0\n            });\n            t(\"activate-tab\", S, b.value, x), x.defaultPrevented || (b.value = S, I = !0);\n          }\n          return !I && a.value !== b.value && (a.value = b.value), I;\n        },\n        F = (S, I) => {\n          var x;\n          P(I), I >= 0 && !_.value[I].disabled && (x = _.value[I]) != null && x.onClick && typeof _.value[I].onClick == \"function\" && _.value[I].onClick(S);\n        };\n      return P(m.value), se(a, (S, I) => {\n        if (S === I) return;\n        if (S = Math.max(S, -1), I = Math.max(I, -1), _.value.length <= 0) {\n          b.value = -1;\n          return;\n        }\n        const x = S > I;\n        let z = S;\n        const te = _.value.length - 1;\n        for (; z >= 0 && z <= te && _.value[z].disabled;) z += x ? 1 : -1;\n        if (z < 0) {\n          P(0);\n          return;\n        }\n        if (z >= _.value.length) {\n          P(_.value.length - 1);\n          return;\n        }\n        P(z);\n      }), se(_, () => {\n        let S = _.value.map(I => I.active && !I.disabled).lastIndexOf(!0);\n        S < 0 && (b.value >= _.value.length ? S = _.value.map(I => !I.disabled).lastIndexOf(!0) : _.value[b.value] && !_.value[b.value].disabled && (S = b.value)), S < 0 && (S = _.value.map(I => !I.disabled).indexOf(!0)), _.value.forEach((I, x) => {\n          I.active = x === S;\n        }), P(S);\n      }), qe(() => {\n        if (b.value < 0 && _.value.length > 0 && !_.value.some(S => S.active)) {\n          const S = _.value.map(I => !I.disabled).indexOf(!0);\n          P(S >= 0 ? S : -1);\n        }\n      }), Ke(wo, {\n        lazy: f,\n        card: n\n      }), (S, I) => (y(), D(oe(S.tag), {\n        id: S.id,\n        class: R([\"tabs\", k.value])\n      }, {\n        default: j(() => [$(s) ? (y(), A(\"div\", {\n          key: 0,\n          class: R([\"tab-content\", S.contentClass])\n        }, [(y(!0), A(fe, null, we(_.value, ({\n          tabComponent: x,\n          contentId: z,\n          tabClasses: te,\n          active: Q\n        }, G) => (y(), D(oe(x()), {\n          id: z,\n          key: G,\n          class: R(te),\n          active: Q\n        }, null, 8, [\"id\", \"class\", \"active\"]))), 128)), h.value ? (y(), A(\"div\", {\n          key: \"bv-empty-tab\",\n          class: R([\"tab-pane active\", {\n            \"card-body\": $(n)\n          }])\n        }, [O(S.$slots, \"empty\")], 2)) : J(\"\", !0)], 2)) : J(\"\", !0), Y(\"div\", {\n          class: R([S.navWrapperClass, {\n            \"card-header\": $(n),\n            \"ms-auto\": S.vertical && $(s)\n          }])\n        }, [Y(\"ul\", {\n          class: R([\"nav\", [w.value, S.navClass]]),\n          role: \"tablist\"\n        }, [O(S.$slots, \"tabs-start\"), (y(!0), A(fe, null, we(_.value, ({\n          tab: x,\n          buttonId: z,\n          contentId: te,\n          navItemClasses: Q,\n          active: G,\n          target: X\n        }, U) => {\n          var pe, be, he;\n          return y(), A(\"li\", {\n            key: U,\n            class: R([\"nav-item\", (pe = x == null ? void 0 : x.props) == null ? void 0 : pe[\"title-item-class\"]]),\n            role: \"presentation\"\n          }, [Y(\"button\", ae({\n            id: z,\n            class: [\"nav-link\", Q],\n            \"data-bs-toggle\": \"tab\",\n            \"data-bs-target\": X,\n            role: \"tab\",\n            \"aria-controls\": te,\n            \"aria-selected\": G\n          }, (be = x == null ? void 0 : x.props) == null ? void 0 : be[\"title-link-attributes\"], {\n            onClick: ut(ye => F(ye, U), [\"stop\", \"prevent\"])\n          }), [x.children && x.children.title ? (y(), D(oe(x.children.title), {\n            key: 0\n          })) : (y(), A(fe, {\n            key: 1\n          }, [re(Z((he = x == null ? void 0 : x.props) == null ? void 0 : he.title), 1)], 64))], 16, Gc)], 2);\n        }), 128)), O(S.$slots, \"tabs-end\")], 2)], 2), $(s) ? J(\"\", !0) : (y(), A(\"div\", {\n          key: 1,\n          class: R([\"tab-content\", S.contentClass])\n        }, [(y(!0), A(fe, null, we(_.value, ({\n          tabComponent: x,\n          contentId: z,\n          tabClasses: te,\n          active: Q\n        }, G) => (y(), D(oe(x()), {\n          id: z,\n          key: G,\n          class: R(te),\n          active: Q\n        }, null, 8, [\"id\", \"class\", \"active\"]))), 128)), h.value ? (y(), A(\"div\", {\n          key: \"bv-empty-tab\",\n          class: R([\"tab-pane active\", {\n            \"card-body\": $(n)\n          }])\n        }, [O(S.$slots, \"empty\")], 2)) : J(\"\", !0)], 2))]),\n        _: 3\n      }, 8, [\"id\", \"class\"]));\n    }\n  }),\n  Uc = /* @__PURE__ */H({\n    __name: \"BTooltip\",\n    setup(e, {\n      expose: t\n    }) {\n      var a, o, n;\n      const l = M(null);\n      return t({\n        hide: (a = l.value) == null ? void 0 : a.hideFn,\n        show: (o = l.value) == null ? void 0 : o.show,\n        toggle: (n = l.value) == null ? void 0 : n.toggle\n      }), (s, r) => (y(), D(tl, {\n        ref_key: \"popover\",\n        ref: l,\n        tooltip: \"\"\n      }, fo({\n        _: 2\n      }, [we(s.$slots, (u, f) => ({\n        name: f,\n        fn: j(v => [O(s.$slots, f, $e(Ee(v)))])\n      }))]), 1536));\n    }\n  }),\n  no = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n    __proto__: null,\n    BAccordion: ni,\n    BAccordionItem: ui,\n    BAlert: pi,\n    BAvatar: bi,\n    BAvatarGroup: hi,\n    BBadge: Bi,\n    BBreadcrumb: wi,\n    BBreadcrumbItem: cn,\n    BButton: kt,\n    BButtonGroup: $i,\n    BButtonToolbar: Ci,\n    BCard: bn,\n    BCardBody: gn,\n    BCardFooter: yn,\n    BCardGroup: Oi,\n    BCardHeader: vn,\n    BCardImg: ia,\n    BCardSubtitle: mn,\n    BCardText: Ai,\n    BCardTitle: pn,\n    BCarousel: zi,\n    BCarouselSlide: ji,\n    BCloseButton: Ot,\n    BCol: Pt,\n    BCollapse: dn,\n    BContainer: Yi,\n    BDropdown: wn,\n    BDropdownDivider: eu,\n    BDropdownForm: lu,\n    BDropdownGroup: su,\n    BDropdownHeader: iu,\n    BDropdownItem: uu,\n    BDropdownItemButton: cu,\n    BDropdownText: pu,\n    BForm: $n,\n    BFormCheckbox: kn,\n    BFormCheckboxGroup: $u,\n    BFormFile: Tu,\n    BFormFloatingLabel: bu,\n    BFormGroup: xu,\n    BFormInput: Nu,\n    BFormInvalidFeedback: Ea,\n    BFormRadio: Tn,\n    BFormRadioGroup: ju,\n    BFormRow: Zt,\n    BFormSelect: Uu,\n    BFormSelectOption: ol,\n    BFormSelectOptionGroup: Vn,\n    BFormSpinButton: Zu,\n    BFormTag: Fn,\n    BFormTags: vd,\n    BFormText: Fa,\n    BFormTextarea: md,\n    BFormValidFeedback: Ia,\n    BImg: al,\n    BInputGroup: _d,\n    BInputGroupAddon: nl,\n    BInputGroupAppend: wd,\n    BInputGroupPrepend: $d,\n    BInputGroupText: In,\n    BLink: Qe,\n    BListGroup: kd,\n    BListGroupItem: Cd,\n    BModal: Ad,\n    BNav: Pd,\n    BNavForm: Ed,\n    BNavItem: Id,\n    BNavItemDropdown: Ld,\n    BNavText: zd,\n    BNavbar: Hd,\n    BNavbarBrand: Rd,\n    BNavbarNav: Md,\n    BNavbarToggle: Ud,\n    BOffcanvas: Yd,\n    BOverlay: Ln,\n    BPagination: nc,\n    BPlaceholder: Re,\n    BPlaceholderButton: Hn,\n    BPlaceholderCard: sc,\n    BPlaceholderTable: rc,\n    BPlaceholderWrapper: ic,\n    BPopover: tl,\n    BProgress: dc,\n    BProgressBar: Rn,\n    BRow: vc,\n    BSpinner: ma,\n    BTab: qc,\n    BTable: Fc,\n    BTableSimple: rl,\n    BTabs: Wc,\n    BTbody: Ic,\n    BTd: Nc,\n    BTfoot: zc,\n    BTh: Mc,\n    BThead: Dc,\n    BToast: _n,\n    BToastContainer: Pa,\n    BToastPlugin: Sn,\n    BToaster: Pa,\n    BTooltip: Uc,\n    BTr: jc,\n    BTransition: Vt\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  }));\nconst Yc = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n    __proto__: null,\n    useBreadcrumb: Qo,\n    useColorMode: Xr\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  })),\n  Jc = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n    __proto__: null,\n    BvCarouselEvent: vo,\n    BvEvent: Je,\n    BvTriggerableEvent: Mt\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  })),\n  Zc = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n    __proto__: null\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  })),\n  Qc = {\n    install(e, t = {\n      components: !0,\n      directives: !0\n    }) {\n      const l = typeof t.components == \"boolean\" || typeof t.components > \"u\" ? {\n          all: !0\n        } : t.components,\n        a = Object.keys(no);\n      zl(l, a).forEach(s => {\n        const r = no[s];\n        e.component(s, r);\n      });\n      const o = typeof (t == null ? void 0 : t.directives) == \"boolean\" || typeof t.directives > \"u\" ? {\n          all: !0\n        } : t == null ? void 0 : t.directives,\n        n = Object.keys(to);\n      zl(o, n).forEach(s => {\n        const r = s.toLowerCase().startsWith(\"v\") ? s.slice(1) : s,\n          u = to[s];\n        e.directive(r, u);\n      }), t != null && t.BToast && e.use(Sn, t);\n    }\n  };\nexport { ni as BAccordion, ui as BAccordionItem, pi as BAlert, bi as BAvatar, hi as BAvatarGroup, Bi as BBadge, wi as BBreadcrumb, cn as BBreadcrumbItem, kt as BButton, $i as BButtonGroup, Ci as BButtonToolbar, bn as BCard, gn as BCardBody, yn as BCardFooter, Oi as BCardGroup, vn as BCardHeader, ia as BCardImg, mn as BCardSubtitle, Ai as BCardText, pn as BCardTitle, zi as BCarousel, ji as BCarouselSlide, Ot as BCloseButton, Pt as BCol, dn as BCollapse, Yi as BContainer, wn as BDropdown, eu as BDropdownDivider, lu as BDropdownForm, su as BDropdownGroup, iu as BDropdownHeader, uu as BDropdownItem, cu as BDropdownItemButton, pu as BDropdownText, $n as BForm, kn as BFormCheckbox, $u as BFormCheckboxGroup, Tu as BFormFile, bu as BFormFloatingLabel, xu as BFormGroup, Nu as BFormInput, Ea as BFormInvalidFeedback, Tn as BFormRadio, ju as BFormRadioGroup, Zt as BFormRow, Uu as BFormSelect, ol as BFormSelectOption, Vn as BFormSelectOptionGroup, Zu as BFormSpinButton, Fn as BFormTag, vd as BFormTags, Fa as BFormText, md as BFormTextarea, Ia as BFormValidFeedback, al as BImg, _d as BInputGroup, nl as BInputGroupAddon, wd as BInputGroupAppend, $d as BInputGroupPrepend, In as BInputGroupText, Qe as BLink, kd as BListGroup, Cd as BListGroupItem, Ad as BModal, Pd as BNav, Ed as BNavForm, Id as BNavItem, Ld as BNavItemDropdown, zd as BNavText, Hd as BNavbar, Rd as BNavbarBrand, Md as BNavbarNav, Ud as BNavbarToggle, Yd as BOffcanvas, Ln as BOverlay, nc as BPagination, Re as BPlaceholder, Hn as BPlaceholderButton, sc as BPlaceholderCard, rc as BPlaceholderTable, ic as BPlaceholderWrapper, tl as BPopover, dc as BProgress, Rn as BProgressBar, vc as BRow, ma as BSpinner, qc as BTab, Fc as BTable, rl as BTableSimple, Wc as BTabs, Ic as BTbody, Nc as BTd, zc as BTfoot, Mc as BTh, Dc as BThead, _n as BToast, Pa as BToastContainer, Sn as BToastPlugin, Pa as BToaster, Uc as BTooltip, jc as BTr, Vt as BTransition, Qc as BootstrapVueNext, vo as BvCarouselEvent, Je as BvEvent, Mt as BvTriggerableEvent, no as Components, Yc as Composables, to as Directives, Zc as Types, Jc as Utils, Qc as default, Qo as useBreadcrumb, Xr as useColorMode, Bn as useToast, Dd as vBColorMode, Na as vBModal, qd as vBPopover, Na as vBToggle, Gd as vBTooltip };","map":{"version":3,"mappings":"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","names":["input","resolveBooleanish","BvEvent","constructor","eventType","eventInit","__publicField","TypeError","name","arguments","length","Object","assign","Defaults","cancelable","defaultPrevented","_defaultPrevented","prop","preventDefault","_preventDefault","setter","componentId","nativeEvent","relatedTarget","target","BvTriggerableEvent","trigger","BvCarouselEvent","from","direction","to","isObject","obj","isNumeric","value","test","String","isPlainObject","prototype","toString","call","RX_UNDERSCORE","RX_LOWER_UPPER","RX_START_SPACE_WORD","RX_FIRST_START_SPACE_WORD","RX_SPACE_SPLIT","RX_HASH","RX_HASH_ID","RX_STRIP_LOCALE_MODS","RX_REGEXP_REPLACE","RX_SPACES","val","spaces","Array","isArray","JSON","stringify","startCase","str","replace","_","$1","$2","toUpperCase","titleCase","upperFirst","trim","charAt","slice","escapeRegExp","escapeRegExpChars","escapeChar","cssEscape","firstCharCode","charCodeAt","split","reduce","result","char","index","charCode","HAS_WINDOW_SUPPORT","window","HAS_DOCUMENT_SUPPORT","document","HAS_ELEMENT_SUPPORT","Element","HAS_NAVIGATOR_SUPPORT","navigator","IS_BROWSER","WINDOW","DOCUMENT","passiveEventSupported","options","passive","HAS_PASSIVE_EVENT_SUPPORT","ELEMENT_PROTO","matchesEl","matches","msMatchesSelector","webkitMatchesSelector","isElement","el","nodeType","Node","ELEMENT_NODE","getBCR","getBoundingClientRect","getActiveElement","excludes","activeElement","some","isActiveElement","attemptFocus","focus","e","console","error","getStyle","getAttribute","isVisible","bcr","height","width","isEmptySlot","select","selector","root","querySelector","selectAll","querySelectorAll","getAttr","attr","getById","id","getElementById","setAttr","removeAttr","removeAttribute","isTag","tag","toLowerCase","requestAF","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","msRequestAnimationFrame","oRequestAnimationFrame","cb","setTimeout","closestEl","closest","sel","parentElement","parentNode","includeRoot","getTransitionDelay","element","getComputedStyle","transitionDelay","style","transitionDuration","transitionDelayMs","Number","transitionDurationMs","getBreakpointProps","prefix","breakpoints","definition","concat","props","breakpoint","create","getClasses$1","els","propPrefix","classPrefix","keys","arr","filter","join","getId","suffix","Math","random","isLink","href","normalizeSlot","scope","$slots","i","names","slot","toInteger","defaultValue","NaN","isInteger","stringToInteger","integer","parseInt","isNaN","toFloat","float","parseFloat","omit","objToPluck","keysToPluck","key","includes","cloneDeep","source","map","item","Date","getTime","getOwnPropertyNames","o","getOwnPropertyDescriptor","getPrototypeOf","cloneDeepAsync","Promise","resolve","suffixPropName","pluckProps","memo","resolveAriaInvalid","ariaInvalid","state","carouselInjectionKey","Symbol","tabsInjectionKey","progressInjectionKey","listGroupInjectionKey","avatarGroupInjectionKey","accordionInjectionKey","checkboxGroupKey","radioGroupKey","collapseInjectionKey","dropdownInjectionKey","navbarInjectionKey","getSlotElements","filterBy","type","children","push","child","__name","t","n","r","a","reference","l","floating","s","c","x","f","y","m","u","g","d","p","placement","strategy","middleware","platform","Boolean","isRTL","getElementRects","fn","h","data","w","reset","v","initialPlacement","middlewareData","rects","elements","top","right","bottom","left","boundary","rootBoundary","elementContext","altBoundary","padding","getClippingRect","contextElement","getDocumentElement","b","getOffsetParent","A","getScale","R","convertOffsetParentRelativeRectToViewportRelativeRect","rect","offsetParent","min","max","getDimensions","P","E","T","D","L","k","O","B","C","H","S","F","M","V","W","centerOffset","main","cross","start","end","crossAxis","alignment","allowedPlacements","autoAlignment","autoPlacement","overflows","sort","every","mainAxis","fallbackPlacements","fallbackStrategy","fallbackAxisSideDirection","flipAlignment","flip","referenceHiddenOffsets","referenceHidden","escapedOffsets","escaped","getClientRects","find","alignmentAxis","limiter","ownerDocument","defaultView","nodeName","HTMLElement","ShadowRoot","overflow","overflowX","overflowY","display","transform","perspective","backdropFilter","willChange","contain","CSS","supports","round","offsetWidth","offsetHeight","fallback","isFinite","visualViewport","offsetLeft","offsetTop","frameElement","clientLeft","paddingLeft","clientTop","paddingTop","documentElement","scrollLeft","scrollTop","pageXOffset","pageYOffset","assignedSlot","host","body","clientWidth","clientHeight","scrollWidth","scrollHeight","position","get","set","_c","z","ancestorScroll","ancestorResize","elementResize","animationFrame","forEach","addEventListener","ResizeObserver","observe","removeEventListener","disconnect","cancelAnimationFrame","Map","unwrapElement","_$el","$el","arrow","args","unref","arrow$1","getDPR","devicePixelRatio","roundByDPR","dpr","useFloating","whileElementsMountedOption","whileElementsMounted","openOption","computed","_unref","open","middlewareOption","placementOption","_unref2","strategyOption","_unref3","transformOption","_unref4","referenceElement","floatingElement","ref","shallowRef","isPositioned","floatingStyles","initialStyles","xVal","yVal","whileElementsMountedCleanup","update","computePosition","then","cleanup","attach","flush","watch","getCurrentScope","onScopeDispose","shallowReadonly","uriAttributes","Set","ARIA_ATTRIBUTE_PATTERN","SAFE_URL_PATTERN","DATA_URL_PATTERN","allowedAttribute","attribute","allowedAttributeList","attributeName","has","nodeValue","attributeRegex","RegExp","regex","DefaultAllowlist","area","br","col","code","div","em","hr","h1","h2","h3","h4","h5","h6","img","li","ol","pre","small","span","sub","sup","strong","ul","sanitizeHtml","unsafeHtml","allowList","sanitizeFunction","createdDocument","DOMParser","parseFromString","elementName","remove","attributeList","attributes","allowedAttributes","innerHTML","__defProp$b","defineProperty","__defProps$8","defineProperties","__getOwnPropDescs$8","getOwnPropertyDescriptors","__getOwnPropSymbols$d","getOwnPropertySymbols","__hasOwnProp$d","hasOwnProperty","__propIsEnum$d","propertyIsEnumerable","__defNormalProp$b","enumerable","configurable","writable","__spreadValues$b","__spreadProps$8","computedEager","_a","readonly","tryOnScopeDispose","createGlobalState","stateFactory","initialized","effectScope","run","createSharedComposable","composable","subscribers","dispose","stop","toValue","isClient","isDef","noop","isIOS","getIsIOS","userAgent","createFilterWrapper","wrapper","reject","apply","thisArg","catch","bypassFilter","invoke","pausableFilter","extendFilter","isActive","pause","resume","eventFilter","toRef","toRef$1","customRef","tryOnMounted","sync","getCurrentInstance","onMounted","nextTick","useCounter","initialValue","count","inc","delta","dec","useIntervalFn","interval","immediate","immediateCallback","timer","clean","clearInterval","intervalValue","setInterval","isRef","stopWatch","useToNumber","method","radix","nanToZero","resolved","__getOwnPropSymbols$8","__hasOwnProp$8","__propIsEnum$8","__objRest$5","exclude","indexOf","watchWithFilter","watchOptions","__defProp$2","__defProps$2","__getOwnPropDescs$2","__getOwnPropSymbols$2","__hasOwnProp$2","__propIsEnum$2","__defNormalProp$2","__spreadValues$2","__spreadProps$2","__objRest$1","watchPausable","unrefElement","elRef","plain","defaultWindow","useEventListener","events","listeners","cleanups","register","event","listener","options2","flatMap","_iOSWorkaround","onClickOutside","handler","ignore","capture","detectIframe","shouldListen","shouldIgnore","target2","composedPath","detail","tagName","contains","useMounted","isMounted","useSupported","callback","useMediaQuery","query","isSupported","matchMedia","mediaQuery","removeListener","addListener","cloneFnJSON","parse","_global","globalThis","global","self","globalKey","handlers","getHandlers","getSSRHandler","guessSerializerType","rawInit","__defProp$l","__getOwnPropSymbols$o","__hasOwnProp$o","__propIsEnum$o","__defNormalProp$l","__spreadValues$l","StorageSerializers","boolean","read","write","object","number","any","string","entries","date","toISOString","customStorageEventName","useStorage","defaults","storage","deep","listenToStorageChanges","writeDefaults","mergeDefaults","shallow","onError","_a2","localStorage","serializer","pauseWatch","resumeWatch","pausableWatch","updateFromCustomEvent","removeItem","serialized","oldValue","getItem","setItem","dispatchEvent","CustomEvent","newValue","storageArea","rawValue","usePreferredDark","__defProp$k","__getOwnPropSymbols$n","__hasOwnProp$n","__propIsEnum$n","__defNormalProp$k","__spreadValues$k","useColorMode","storageKey","storageRef","emitAuto","disableTransition","modes","auto","light","dark","preferredDark","system","store","updateHTMLAttrs","selector2","attribute2","createElement","styleString","appendChild","createTextNode","head","current","values","classList","add","setAttribute","opacity","removeChild","defaultOnChanged","mode","onChanged","useFocus","innerFocused","targetElement","focused","_b","blur","BuiltinExtractors","page","pageX","pageY","client","clientX","clientY","screen","screenX","screenY","movement","Touch","movementX","movementY","useMouse","touch","resetOnTouchEnds","sourceType","extractor","mouseHandler","touchHandler","touches","mouseHandlerWrapper","touchHandlerWrapper","useMouseInElement","handleOutside","targetRef","elementX","elementY","elementPositionX","elementPositionY","elementHeight","elementWidth","isOutside","elX","elY","checkOverflowScroll","ele","parent","rawEvent","_target","useScrollLock","initialState","isLocked","stopTouchMoveListener","initialOverflow","lock","unlock","useSwipe","threshold","onSwipe","onSwipeEnd","onSwipeStart","coordsStart","reactive","coordsEnd","diffX","diffY","abs","isThresholdExceeded","isSwiping","getTouchEventCoords","updateCoordsStart","updateCoordsEnd","listenerOptions","isPassiveEventSupported","checkPassiveEventSupport","onTouchEnd","stops","lengthX","lengthY","supportsPassive","optionsBlock","useVModel","emit","clone","eventName","shouldEmit","vm","_emit","$emit","bind","proxy","cloneFn","getValue","triggerEmit","defineComponent","slots","default","skip","setup","attrs","Teleport","useAlignment","align","useBooleanish","useBreadcrumb","items","opts","persist","useCountdown","intervalOpts","resolvedLength","resolvedInterval","isPaused","intervalsPassed","amountOfIntervals","ceil","restart","watchEffect","myPause","myResume","getClasses","resolvedItems","button","inline","switch","size","getInputClasses","getLabelClasses","btn","buttonVariant","getGroupAttr","required","getGroupClasses","validated","buttons","stacked","useFormInput","inputValue","neverFormatted","computedId","useId","autofocusBoolean","autofocus","disabledBoolean","disabled","lazyBoolean","lazy","lazyFormatterBoolean","lazyFormatter","numberBoolean","plaintext","stateBoolean","trimBoolean","_formatValue","evt","force","formatter","_getModelValue","handleAutofocus","modelValue","onActivated","computedAriaInvalid","onInput","formattedValue","nextModel","onChange","onBlur","_getNested","path","paths","splice","_normalizeOption","option","componentName","valueField","text","textField","html","htmlField","disabledField","optionsField","label","labelField","normalizeOptions","MODAL_OPEN_CLASS_NAME","useSharedModalCounter","toggle","useModalManager","modalOpen","useSafeScrollLock","isOpen","bodyScroll","bodyScrollingValue","inverseBodyScrollingValue","bodyRef","modelVal","bodyVal","useStateClass","resolvedValue","Qr","ei","ti","tl","modelValueBoolean","showState","showStateInternal","show","hideFn","Event","clickBoolean","click","manualBoolean","manual","noShiftBoolean","noShift","noFlipBoolean","noFlip","noFadeBoolean","noFade","noAutoCloseBoolean","noAutoClose","hideBoolean","hide","realtimeBoolean","realtime","inlineBoolean","tooltipBoolean","tooltip","isHtml","hidden","targetTrigger","placeholder","cleanElementProp","getElement","idElement","sanitizedTitle","title","sanitizedContent","content","isAutoPlacement","startsWith","floatingMiddleware","offset","offsetMiddleware","off","shift","hideMiddleware","inlineMiddleware","arrowMiddleware","placementRef","autoUpdate","arrowStyle","variant","fade","customClass","resolveBootstrapPlacement","triggerIsOutside","buildTriggerableEvent","delay","__expose","elem","nextElementSibling","unbind","onBeforeUnmount","resolveFloatingPlacement","alignCenter","alignEnd","_placement","resolveActiveStatus","active","resolveContent","missingBindingValue","resolveDirectiveProps","binding","modifiers","insertBefore","nextSibling","$__app","createApp","render","BPopover","$__state","mount","$__element","unmount","parseActiveImports","all","others","valuesCopy","merge","oi","ni","flushBoolean","freeBoolean","free","computedClasses","openItem","setOpenItem","toggleBoolean","horizontalBoolean","horizontal","isNavBoolean","isNav","visibleBoolean","visible","isCollapsing","collapsing","closing","close","toggleFn","reveal","newval","provide","shown","parentData","inject","appearBoolean","appear","fadeProperties","NO_FADE_PROPS","enterActiveClass","enterToClass","leaveActiveClass","leaveToClass","enterFromClass","leaveFromClass","FADE_PROPS","baseProperties","css","computedAttrs","transProps","appearActiveClass","appearToClass","whiteBoolean","white","useSlots","smallBoolean","hasLabelSlot","BLINK_PROPS","activeClass","append","rel","routerComponentName","routerTag","Qe","useAttrs","activeBoolean","iconBoolean","icon","navbarData","closeCollapse","instance","appContext","app","component","routerName","computedHref","toFallback","hash","opacityHover","underlineVariant","underlineOffset","underlineOffsetHover","underlineOpacity","underlineOpacityHover","routerAttr","class","tabindex","computedLinkClasses","clicked","stopImmediatePropagation","pressedValue","blockBoolean","block","pillBoolean","pill","pressedBoolean","pressed","squaredBoolean","squared","loadingBoolean","loading","isToggle","isButton","computedLink","isBLink","nonStandardTag","autocomplete","role","computedTag","BLink","stopPropagation","dismissibleBoolean","dismissible","fadeBoolean","immediateBoolean","showOnPauseBoolean","showOnPause","noHoverPauseBoolean","noHoverPause","hasCloseSlot","countdownLength","remainingMs","isAlertVisible","closeAttrs","closeVariant","closeClicked","onMouseEnter","computeSize","calcValue","bi","SIZES","FONT_SIZE_SCALE","BADGE_FONT_SIZE_SCALE","badgeLeftBoolean","badgeLeft","badgeTopBoolean","badgeTop","buttonBoolean","squareBoolean","square","hasDefaultSlot","hasBadgeSlot","badge","showBadge","computedSize","computedVariant","computedRounded","rounded","buttonType","ariaLabel","badgeClasses","badgeVariant","badgeText","badgeTextClasses","computeContrastVariant","textClasses","textVariant","badgeStyle","badgeOffset","fontSize","textFontStyle","marginStyle","overlapScale","marginLeft","marginRight","computedStyle","colorVariant","onImgError","computeOverlap","overlap","paddingStyle","paddingRight","textIndicatorBoolean","textIndicator","dotIndicatorBoolean","dotIndicator","computedLinkProps","computedAriaCurrent","ariaCurrent","breadcrumb","breadcrumbItemObjects","localItems","activeDefined","idx","verticalBoolean","vertical","justifyBoolean","justify","BLANK_TEMPLATE","al","blankBoolean","blank","centerBoolean","center","fluidBoolean","fluid","fluidGrowBoolean","fluidGrow","startBoolean","endBoolean","thumbnailBoolean","thumbnail","computedSrcset","srcset","computedSizes","sizes","computedDimentions","parser","computedBlankImgSrc","makeBlankImgSrc","blankColor","src","alt","color","encodeURIComponent","bottomBoolean","topBoolean","baseClass","bgVariant","borderVariant","coomputedClasses","overlayBoolean","overlay","hasTitleSlot","hasSubtitleSlot","subtitle","bodyTextVariant","bodyBgVariant","imgBottomBoolean","imgBottom","imgEndBoolean","imgEnd","imgStartBoolean","imgStart","noBodyBoolean","noBody","hasHeaderSlot","header","hasFooterSlot","footer","headerAttrs","headerBgVariant","headerBorderVariant","headerHtml","headerTag","headerTextVariant","bodyAttrs","bodyTag","subtitleTag","subtitleTextVariant","titleTag","footerAttrs","footerBgVariant","footerBorderVariant","footerHtml","footerTag","footerTextVariant","imgAttr","imgSrc","imgAlt","imgHeight","imgWidth","imgTop","columnsBoolean","columns","deckBoolean","deck","cardTypeClass","keyboardBoolean","keyboard","rideReverseBoolean","rideReverse","controlsBoolean","controls","indicatorsBoolean","indicators","noTouchBoolean","noTouch","noWrapBoolean","noWrap","touchThresholdNumber","touchThreshold","isTransitioning","rideStarted","previousModelValue","rideResolved","isBooleanish","ride","enterClasses","leaveClasses","prev","next","isRiding","slides","buildBvCarouselEvent","goToValue","onKeydown","onMouseLeave","resumeRiding","onBeforeLeave","onAfterLeave","background","hasText","textHtml","hasCaption","caption","captionHtml","hasContent","computedContentClasses","contentVisibleUp","breakpointCol","breakpointOffset","breakpointOrder","_sfc_main$16","cols","order","alignSelf","properties","colBoolean","ll","_cache","$props","defaultToastOptions","autoHide","noCloseButton","pos","ToastInstance","isReactive","toasts","toast","forDeletion","isRoot","topts","info","danger","warning","success","ToastController","useToast","vms","getOrCreateViewModel","rootInstance","container","getVM","injectkey","fetchKey","getKey","controller","vm_id","local_vm","vm_instance","BToastPlugin","install","BToast","SLOT_NAME_TOAST_TITLE","MIN_DURATION","_sfc_main$15","components","bodyClass","headerClass","animation","isStatus","solid","static","toastClass","emits","isStatusBoolean","autoHideBoolean","noCloseButtonBoolean","isHiding","localShow","classes","dismissStarted","resumeDismiss","clearDismissTimer","dismissTimer","clearTimeout","computedDuration","onPause","now","passed","onUnPause","startDismissTimer","OnBeforeEnter","OnAfterEnter","OnBeforeLeave","OnAfterLeave","onUnmounted","onLinkClick","makeToast","$headerContent","$title","BCloseButton","onClick","$innertoast","$body","onmouseenter","onmouseleave","BTransition","onAfterEnter","onBeforeEnter","Pa","toastPositions","positionClass","handleDestroy","_sfc_main$13","gutterX","gutterY","expose","toastInstance","subContainers","containerPositions","BToaster","methods","Ji","Zi","wn","darkBoolean","dropupBoolean","dropup","dropendBoolean","dropend","dropstartBoolean","dropstart","splitBoolean","noCaretBoolean","noCaret","splitDisabledBoolean","splitDisabled","computedOffset","offsetToNumber","splitButton","referencePlacement","floatingPlacement","floatingOffset","localOffset","buttonClasses","splitClass","toggleClass","dropdownMenuClasses","menuClass","buttonAttr","splitHref","splitTo","onButtonClick","currentModelValue","onSplitClick","autoClose","onClickInside","headerId","headerRole","headerVariant","linkClass","componentAttrs","collapseData","dropdownData","buttonClass","floatingBoolean","novalidateBoolean","novalidate","validatedBoolean","submitted","forceShowBoolean","forceShow","computedShow","ariaLive","computedAriaAtomic","indeterminateBoolean","indeterminate","plainBoolean","buttonGroupBoolean","buttonGroup","switchBoolean","requiredBoolean","localValue","updateValue","uncheckedValue","computedRequired","isButtonGroup","classesObject","inputClasses","labelClasses","computedName","buttonsBoolean","stackedBoolean","switchesBoolean","switches","form","ind","directoryBoolean","directory","multipleBoolean","multiple","noDropBoolean","noDrop","noTraverse","stateClass","computedAccept","accept","computedCapture","files","onDrop","INPUTS","INPUT_SELECTOR","LEGEND_INTERACTIVE_ELEMENTS","SLOT_NAME_LABEL","SLOT_NAME_INVALID_FEEDBACK","SLOT_NAME_VALID_FEEDBACK","SLOT_NAME_DESCRIPTION","SLOT_NAME_DEFAULT","_sfc_main$N","BCol","BFormInvalidFeedback","BFormRow","BFormText","BFormValidFeedback","contentCols","contentColsLg","contentColsMd","contentColsSm","contentColsXl","description","feedbackAriaLive","invalidFeedback","labelAlign","labelAlignLg","labelAlignMd","labelAlignSm","labelAlignXl","labelClass","labelCols","labelColsLg","labelColsMd","labelColsSm","labelColsXl","labelFor","labelSize","labelSrOnly","validFeedback","labelSrOnlyBoolean","ariaDescribedby","breakPoints","getAlignClasses","propValue","getColProps","updateAriaDescribedby","$input","newIds","oldIds","ids","contentColProps","labelAlignClasses","labelColProps","isHorizontal","onLegendClick","inputs","isFieldset","$label","labelContent","labelId","labelTag","for","renderProps","tabIndex","$invalidFeedback","invalidFeedbackContent","invalidFeedbackId","$validFeedback","validFeedbackContent","validFeedbackId","$description","descriptionContent","descriptionId","contentBlocks","$content","rowProps","Lu","Nu","readonlyBoolean","plaintextBoolean","isHighlighted","isColor","isRange","formOptions","computedSelectSize","selectSize","RTL_LANGS","locale","isLocaleRTL","locale1","parts","locale2","parseEventOptions","eventOn","eventOff","eventOnOff","on","eventParams","stopEvent","propagation","immediatePropagation","CODE_DOWN","CODE_END","CODE_HOME","CODE_PAGEDOWN","CODE_PAGEUP","CODE_UP","DEFAULT_MIN","DEFAULT_MAX","DEFAULT_STEP","DEFAULT_REPEAT_DELAY","DEFAULT_REPEAT_INTERVAL","DEFAULT_REPEAT_THRESHOLD","DEFAULT_REPEAT_MULTIPLIER","KEY_CODES","_sfc_main$G","ariaControls","labelIncrement","labelDecrement","formatterFn","Function","repeatDelay","repeatInterval","repeatStepMultiplier","repeatThreshold","step","wrap","hasFocus","spinId","emitChange","lvalue","$_autoRepeatTimer","$_keyIsDown","computedStep","computedMin","computedMax","floor","computedDelay","computedInterval","computedThreshold","computedStepMultiplier","computedPrecision","computedMultiplier","pow","valueAsFixed","toFixed","computedLocale","Intl","NumberFormat","locales","resolvedOptions","computedRTL","defaultFormatter","precision","useGrouping","minimumIntegerDigits","minimumFractionDigits","maximumFractionDigits","notation","format","computedFormatter","lang","hasValue","computedSpinAttrs","dir","stepValue","multiplier","stepUp","stepDown","altKey","ctrlKey","metaKey","resetTimers","handleStepRepeat","onKeyup","stepper","$_autoDelayTimer","isMouseEvent","setMouseup","onMouseup","makeButton","IconCmp","keyRef","shortcut","btnDisabled","slotName","scale","onmousedown","ontouchstart","$icon","$increment","xmlns","fill","viewBox","$decrement","$hidden","$spin","onkeydown","onkeyup","Qu","Fn","noRemoveBoolean","noRemove","tagText","taglabelId","addOnChangeBoolean","addOnChange","noAddOnEnterBoolean","noAddOnEnter","noOuterFocusBoolean","noOuterFocus","noTagRemoveBoolean","noTagRemove","removeOnDeleteBoolean","removeOnDelete","tagPillsBoolean","tagPills","_inputId","inputId","tags","shouldRemoveOnDelete","lastRemovedTag","validTags","invalidTags","duplicateTags","isDuplicate","isInvalid","tagValidator","isLimitReached","limit","disableAddButton","slotAttrs","addButtonText","addButtonVariant","addTag","duplicateTagText","inputAttrs","inputHandlers","keydown","change","inputType","invalidTagText","limitTagsText","removeTag","separator","tagClass","tagRemoveLabel","tagVariant","newVal","onFocus","separatorRegExp","newTags","newTag","tagIndex","noResizeBoolean","noResize","computedStyles","resize","hasAppend","appendHtml","hasPrepend","prepend","prependHtml","isTextBoolean","isText","numberedBoolean","numbered","actionBoolean","action","link","tagComputed","isAction","localAttrs","busyBoolean","busy","cancelDisabledBoolean","cancelDisabled","centeredBoolean","centered","hideBackdropBoolean","hideBackdrop","hideFooterBoolean","hideFooter","hideHeaderBoolean","hideHeader","hideHeaderCloseBoolean","hideHeaderClose","noCloseOnBackdropBoolean","noCloseOnBackdrop","noCloseOnEscBoolean","noCloseOnEsc","autoFocusBoolean","autoFocus","okDisabledBoolean","okDisabled","okOnlyBoolean","okOnly","scrollableBoolean","scrollable","titleSrOnlyBoolean","titleSrOnly","teleportDisabledBoolean","teleportDisabled","bodyScrollingBoolean","bodyScrolling","okButton","cancelButton","closeButton","lazyLoadCompleted","modalFocus","autoFocusButton","okButtonFocus","cancelButtonFocus","closeButtonFocus","modalClasses","modalClass","lazyShowing","hasHeaderCloseSlot","modalDialogClasses","dialogClass","fullscreen","bodyClasses","headerClasses","footerClasses","footerClass","titleClasses","titleClass","disableCancel","disableOk","showFn","pickFocusItem","onLeave","cardHeaderBoolean","cardHeader","fillBoolean","justifiedBoolean","justified","pillsBoolean","pills","tabsBoolean","tabs","underlineBoolean","underline","linkProps","dropdownValue","usableProps","printBoolean","print","computedRole","computedNavbarExpand","toggleable","containerClass","sticky","fixed","setTheme","BColorMode","mounted","updated","getTargets","arg","targets","targetId","checkVisibility","targetIds","vBToggle","__toggle","unmounted","beforeUnmount","BTooltip","positionStyles","fixedBoolean","noSpinnerBoolean","noSpinner","noCenterBoolean","noCenter","showBoolean","spinnerSmallBoolean","spinnerSmall","bgColor","computedAriaBusy","spinnerAttrs","spinnerType","spinnerVariant","overlayStyles","zIndex","overlayClasses","blurClasses","blurStyles","backgroundColor","spinWrapperStyles","backdropBoolean","backdrop","noHeaderCloseBoolean","noHeaderClose","noHeaderBoolean","noHeader","noFocusBoolean","noFocus","showBackdrop","DEFAULT_LIMIT","DEFAULT_PER_PAGE","DEFAULT_TOTAL_ROWS","ELLIPSIS_THRESHOLD","SLOT_NAME_ELLIPSIS_TEXT","SLOT_NAME_FIRST_TEXT","SLOT_NAME_LAST_TEXT","SLOT_NAME_NEXT_TEXT","SLOT_NAME_PAGE","SLOT_NAME_PREV_TEXT","sanitizePerPage","sanitizeTotalRows","sanitizeCurrentPage","numberOfPages","_sfc_main$j","ellipsisClass","ellipsisText","firstClass","firstNumber","firstText","hideEllipsis","hideGotoEndButtons","labelFirstPage","labelLastPage","labelNextPage","labelPage","labelPrevPage","lastClass","lastNumber","lastText","nextClass","nextText","pageClass","perPage","prevClass","prevText","totalRows","firstNumberBoolean","hideEllipsisBoolean","hideGotoEndButtonsBoolean","lastNumberBoolean","justifyAlign","startNumber","lStartNumber","numberOfLinks","showFirstDots","rShowDots","pagesLeft","showLastDots","paginationWindowEnd","lastPageNumber","pagination","pageSize","pageClick","pageNumber","clickEvent","btnSize","styleClass","calculatedValue","pageNumbers","pages","isActivePage","noCurrentPage","makeEndBtn","linkTo","btnSlot","btnText","btnClass","pageTest","isDisabled","btnContent","makeEllipsis","isLast","makePageButton","inner","gotoFirstPageButton","previousButton","nextButton","gotoLastPageButton","Re","widthString","colsString","wrapperClasses","noButtonBoolean","noButton","noFooterBoolean","noFooter","noImgBoolean","noImg","headerWidth","headerAnimation","headerSize","footerWidth","footerAnimation","footerSize","footerVariant","defaultAttrs","imgAttrs","imgBlankColor","captionTopBoolean","captionTop","borderlessBoolean","borderless","borderedBoolean","bordered","hoverBoolean","hover","stripedBoolean","striped","stickyHeaderBoolean","stickyHeader","tableVariant","tableClass","responsiveClasses","responsive","columnsToNumber","rowsToNumber","rows","computedHeaderColumns","headerColumns","computedFooterColumns","footerColumns","headerColumnsNumber","footerColumnsNumber","columnsNumber","rowsNumber","computedHeaderColumnsLength","computedFooterColumnsLength","placeholderAttrs","cellWidth","headerCellWidth","footerCellWidth","showFooterBoolean","showFooter","animatedBoolean","animated","showProgressBoolean","showProgress","showValueBoolean","showValue","numberPrecision","numberValue","numberMax","computedLabel","labelHtml","computedWidth","rowColsProps","_sfc_main$a","noGutters","alignV","alignH","alignContent","noGuttersBoolean","rowColsClasses","$setup","TABLE_TAG_NAMES","EVENT_FILTER","filterEvent","useItemHelper","origFields","fields","internalItems","mapItems","flags","isFilterableTable","filterItems","filterable","isSortable","sortItems","sortBy","desc","sortDescBoolean","sortCompare","sorter","sortKey","ob","realVal","normaliseFields","updateInternalItems","notifyFilteredItems","formatItem","yc","bc","hc","Bc","Sc","sortByModel","busyModel","sortDescModel","itemHelper","footCloneBoolean","footClone","sortInternalBoolean","sortInternal","selectableBoolean","selectable","stickySelectBoolean","stickySelect","labelStackedBoolean","labelStacked","showEmptyBoolean","showEmpty","noProviderPagingBoolean","noProviderPaging","noProviderSortingBoolean","noProviderSorting","noProviderFilteringBoolean","noProviderFiltering","usesProvider","callItemsProvider","selectedItems","isSelecting","tableClasses","selectMode","containerAttrs","computedFields","computedFieldsTotal","provider","addSelectableCell","selectHead","field","sortable","requireItemsMapping","computedItems","startIndex","currentPage","endIndex","getFieldHeadLabel","headerClicked","isFooter","fieldKey","handleFieldSorting","onRowClick","row","handleRowSelection","shiftKey","onRowDblClick","onRowMouseEnter","onRowMouseLeave","fieldSortable","sortDesc","notifySelectionEvent","shiftClicked","ctrlClicked","metaClicked","lastSelectedItem","pop","lastSelectedIndex","findIndex","selectStartIndex","selectEndIndex","delete","clear","context","Proxy","response","toggleRowDetails","tr","_showDetails","getFieldColumnClasses","thClass","stickyColumn","getFieldRowClasses","tdClass","_cellVariants","getRowClasses","_rowVariant","selectionVariant","selectAllRows","unselectableItems","clearSelected","selectRow","unselectRow","providerPropsWatch","oldVal","noProvider","notifyFiltered","noProvideWhenPaging","inNoProvider","noProvideWhenFiltering","noProvideWhenSorting","oldFilter","refresh","stickyColumnBoolean","colspan","rowspan","lazyOnce","lazyRenderCompleted","computedLazy","computedLazyOnce","computedActive","showSlot","hasLazyRenderedOnce","card","cardBoolean","noNavStyleBoolean","noNavStyle","_tabIndex","_currentTabButton","buttonId","tabsInternal","tab","contentId","titleItemClass","titleLinkAttributes","tabComponent","navItemClasses","activeNavItemClass","tabClasses","activeTabClass","navTabsClasses","activateTab","tabEvent","handleClick","goForward","maxIdx","activeTabIndex","lastIndexOf","firstTab","plugin","directives","selectedComponents","componentKeys","Components","selectedDirectives","directiveKeys","Directives","directive","parsedName"],"sources":["../src/utils/booleanish.ts","../src/utils/classes/BvEvent.ts","../src/utils/classes/BvTriggerableEvent.ts","../src/utils/classes/BvCarouselEvent.ts","../src/utils/inspect.ts","../src/constants/regex.ts","../src/utils/stringUtils.ts","../src/utils/cssEscape.ts","../src/constants/env.ts","../src/utils/env.ts","../src/utils/dom.ts","../src/utils/getBreakpointProps.ts","../src/utils/getClasses.ts","../src/utils/getId.ts","../src/utils/isLink.ts","../src/utils/normalizeSlot.ts","../src/utils/number.ts","../src/utils/object.ts","../src/utils/props.ts","../src/utils/resolveAriaInvalid.ts","../src/utils/keys.ts","../src/utils/getSlotElements.ts","../../../node_modules/.pnpm/@floating-ui+core@1.3.1/node_modules/@floating-ui/core/dist/floating-ui.core.browser.min.mjs","../../../node_modules/.pnpm/@floating-ui+dom@1.2.9/node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.min.mjs","../../../node_modules/.pnpm/@floating-ui+vue@1.0.1_vue@3.3.4/node_modules/@floating-ui/vue/dist/floating-ui.vue.esm.js","../src/utils/sanitizer.ts","../../../node_modules/.pnpm/@vueuse+shared@10.2.0_vue@3.3.4/node_modules/@vueuse/shared/index.mjs","../../../node_modules/.pnpm/@vueuse+core@10.2.0_vue@3.3.4/node_modules/@vueuse/core/index.mjs","../src/components/RenderComponentOrSkip.vue","../src/composables/useAlignment.ts","../src/composables/useBooleanish.ts","../src/composables/useBreadcrumb.ts","../src/composables/useColorMode.ts","../src/composables/useCountdown.ts","../src/composables/useFormCheck.ts","../src/composables/useFormInput.ts","../src/composables/useFormSelect.ts","../src/composables/useId.ts","../src/composables/useModalManager.ts","../src/composables/useSafeScrollLock.ts","../src/composables/useStateClass.ts","../src/components/BPopover.vue","../src/utils/floatingUi.ts","../src/utils/parseActiveImports.ts","../src/components/BAccordion/BAccordion.vue","../src/components/BCollapse.vue","../src/components/BAccordion/BAccordionItem.vue","../src/components/BTransition/BTransition.vue","../src/components/BButton/BCloseButton.vue","../src/components/BSpinner.vue","../src/components/BLink/BLink.vue","../src/components/BButton/BButton.vue","../src/components/BAlert/BAlert.vue","../src/components/BAvatar/BAvatar.vue","../src/components/BAvatar/BAvatarGroup.vue","../src/components/BBadge/BBadge.vue","../src/components/BBreadcrumb/BBreadcrumbItem.vue","../src/components/BBreadcrumb/BBreadcrumb.vue","../src/components/BButton/BButtonGroup.vue","../src/components/BButton/BButtonToolbar.vue","../src/components/BImg.vue","../src/components/BCard/BCardImg.vue","../src/components/BCard/BCardHeadFoot.vue","../src/components/BCard/BCardSubtitle.vue","../src/components/BCard/BCardBody.vue","../src/components/BCard/BCard.vue","../src/components/BCard/BCardGroup.vue","../src/components/BCarousel/BCarousel.vue","../src/components/BCarousel/BCarouselSlide.vue","../src/components/BCol.vue","../src/components/BToast/plugin.ts","../src/components/BToast/BToast.vue","../src/components/BToast/BToaster.vue","../src/components/BContainer.vue","../src/components/BDropdown/BDropdown.vue","../src/components/BDropdown/BDropdownGroup.vue","../src/components/BDropdown/BDropdownItem.vue","../src/components/BDropdown/BDropdownItemButton.vue","../src/components/BForm/BForm.vue","../src/components/BForm/BFormInvalidFeedback.vue","../src/components/BForm/BFormText.vue","../src/components/BForm/BFormValidFeedback.vue","../src/components/BFormCheckbox/BFormCheckbox.vue","../src/components/BFormCheckbox/BFormCheckboxGroup.vue","../src/components/BFormFile/BFormFile.vue","../src/components/BFormGroup/BFormGroup.vue","../src/components/BFormInput/BFormInput.vue","../src/components/BFormRadio/BFormRadio.vue","../src/components/BFormRadio/BFormRadioGroup.vue","../src/components/BFormSelect/BFormSelectOption.vue","../src/components/BFormSelect/BFormSelectOptionGroup.vue","../src/components/BFormSelect/BFormSelect.vue","../src/utils/locale.ts","../src/utils/event.ts","../src/constants/codes.ts","../src/components/BFormSpinButton/BFormSpinButton.vue","../src/components/BFormTags/BFormTag.vue","../src/components/BFormTags/BFormTags.vue","../src/components/BFormTextarea/BFormTextarea.vue","../src/components/BInputGroup/BInputGroup.vue","../src/components/BInputGroup/BInputGroupAddon.vue","../src/components/BListGroup/BListGroup.vue","../src/components/BListGroup/BListGroupItem.vue","../src/components/BModal.vue","../src/components/BNav/BNav.vue","../src/components/BNav/BNavForm.vue","../src/components/BNav/BNavItem.vue","../src/components/BNav/BNavItemDropdown.vue","../src/components/BNavbar/BNavbar.vue","../src/components/BNavbar/BNavbarBrand.vue","../src/components/BNavbar/BNavbarNav.vue","../src/directives/BColorMode.ts","../src/directives/BToggle.ts","../src/directives/BPopover.ts","../src/directives/BTooltip.ts","../src/components/BNavbar/BNavbarToggle.vue","../src/components/BOverlay/BOverlay.vue","../src/components/BOffcanvas/BOffcanvas.vue","../src/components/BPagination/BPagination.vue","../src/components/BPlaceholder/BPlaceholder.vue","../src/components/BPlaceholder/BPlaceholderButton.vue","../src/components/BPlaceholder/BPlaceholderCard.vue","../src/components/BTable/BTableSimple.vue","../src/components/BPlaceholder/BPlaceholderTable.vue","../src/components/BPlaceholder/BPlaceholderWrapper.vue","../src/components/BProgress/BProgressBar.vue","../src/components/BProgress/BProgress.vue","../src/components/BRow.vue","../src/components/BTable/helpers/filter-event.ts","../src/components/BTable/itemHelper.ts","../src/components/BTable/BTable.vue","../src/components/BTable/BTbody.vue","../src/components/BTable/BTd.vue","../src/components/BTable/BTfoot.vue","../src/components/BTable/BTh.vue","../src/components/BTable/BThead.vue","../src/components/BTable/BTr.vue","../src/components/BTabs/BTab.vue","../src/components/BTabs/BTabs.vue","../src/components/BTooltip.vue","../src/BootstrapVue.ts"],"sourcesContent":["import type {Booleanish} from '../types'\n\n/**\n * Type predicate function to check if the input is Booleanish type\n *\n * @param  {unknown} input\n * @returns inputisBooleanish\n */\nexport const isBooleanish = (input: unknown): input is Booleanish =>\n  typeof input === 'boolean' || input === '' || input === 'true' || input === 'false'\n\n/**\n * Converts a Booleanish type to boolean\n *\n * @param {Booleanish} input\n * @returns\n */\nexport const resolveBooleanish = (input: Booleanish): boolean =>\n  typeof input === 'boolean' ? input : input === '' || input === 'true' ? true : false\n","/**\n * Items that are omitted from the BvEventInit constructor arg\n */\nexport type BvEventConstructorOmittables = 'eventType' | 'defaultPrevented'\n\nexport default class BvEvent {\n  readonly cancelable: boolean = true\n  readonly componentId: string | null = null\n  private _defaultPrevented = false\n  readonly eventType: string = ''\n  readonly nativeEvent: string | null = null\n  private _preventDefault: () => void\n  readonly relatedTarget: EventTarget | null = null\n  readonly target: EventTarget | null = null\n  // Readable by everyone,\n  // But only overwritten by inherrited constructors\n  public get defaultPrevented() {\n    return this._defaultPrevented\n  }\n  protected set defaultPrevented(prop) {\n    this._defaultPrevented = prop\n  }\n  // I think this is right\n  // We want to be able to have it callable to everyone,\n  // But only overwritten by inherrited constructors\n  public get preventDefault() {\n    return this._preventDefault\n  }\n  // This may not be correct, because it doesn't get correct type inferences in children\n  // Ex overwrite this.preventDefault = () => true is valid. Could be a TS issue\n  protected set preventDefault(setter: () => void) {\n    this._preventDefault = setter\n  }\n\n  constructor(\n    eventType: string,\n    eventInit: Partial<Omit<BvEvent, BvEventConstructorOmittables>> = {}\n  ) {\n    if (!eventType) {\n      throw new TypeError(\n        `Failed to construct '${this.constructor.name}'. 1 argument required, ${arguments.length} given.`\n      )\n    }\n\n    // Merge defaults first, the eventInit, and the type last\n    // so, it can't be overwritten\n    Object.assign(this, BvEvent.Defaults, eventInit, {eventType})\n\n    this._preventDefault = function _preventDefault() {\n      if (this.cancelable) {\n        this.defaultPrevented = true\n      }\n    }\n  }\n\n  static get Defaults() {\n    return {\n      cancelable: true,\n      componentId: null,\n      eventType: '',\n      nativeEvent: null,\n      relatedTarget: null,\n      target: null,\n    }\n  }\n}\n","import BvEvent, {type BvEventConstructorOmittables} from './BvEvent'\n\nexport default class BvTriggerableEvent extends BvEvent {\n  readonly trigger: string | null = null\n\n  constructor(\n    eventType: string,\n    eventInit: Partial<Omit<BvTriggerableEvent, BvEventConstructorOmittables>> = {}\n  ) {\n    super(eventType, eventInit)\n\n    // Merge defaults first, the eventInit, and the type last\n    // so, it can't be overwritten\n    Object.assign(this, BvEvent.Defaults, eventInit, {eventType})\n  }\n\n  static get Defaults() {\n    return {\n      ...super.Defaults,\n      trigger: null,\n    }\n  }\n}\n","import BvEvent, {type BvEventConstructorOmittables} from './BvEvent'\n\nexport default class BvCarouselEvent extends BvEvent {\n  readonly from: number\n  readonly to: number\n  readonly direction: 'left' | 'right'\n\n  constructor(\n    eventType: string,\n    eventInit: Partial<Omit<BvEvent, BvEventConstructorOmittables>> & {\n      from: number\n      to: number\n      direction: 'left' | 'right'\n    }\n  ) {\n    super(eventType, eventInit)\n    Object.assign(this, BvEvent.Defaults, eventInit, {eventType})\n    const {from, direction, to} = eventInit\n    this.from = from\n    this.to = to\n    this.direction = direction\n  }\n\n  static get Defaults() {\n    return {\n      ...super.Defaults,\n    }\n  }\n}\n","export const isObject = (obj: unknown): obj is Record<PropertyKey, unknown> =>\n  obj !== null && typeof obj === 'object'\n\nexport const isNumeric = (value: unknown): boolean => /^[0-9]*\\.?[0-9]+$/.test(String(value))\n\nexport const isPlainObject = (obj: unknown): obj is Record<PropertyKey, unknown> =>\n  Object.prototype.toString.call(obj) === '[object Object]'\n","export const RX_UNDERSCORE = /_/g\nexport const RX_LOWER_UPPER = /([a-z])([A-Z])/g\nexport const RX_START_SPACE_WORD = /(\\s|^)(\\w)/g\nexport const RX_FIRST_START_SPACE_WORD = /(\\s|^)(\\w)/\nexport const RX_SPACE_SPLIT = /\\s+/\nexport const RX_HASH = /^#/\nexport const RX_HASH_ID = /^#[A-Za-z]+[\\w\\-:.]*$/\n\nexport const RX_STRIP_LOCALE_MODS = /-u-.+/\nexport const RX_REGEXP_REPLACE = /[-/\\\\^$*+?.()|[\\]{}]/g\nexport const RX_SPACES = /[\\s\\uFEFF\\xA0]+/g\n","import {isPlainObject} from './inspect'\nimport {\n  RX_FIRST_START_SPACE_WORD,\n  RX_LOWER_UPPER,\n  RX_REGEXP_REPLACE,\n  RX_SPACES,\n  RX_START_SPACE_WORD,\n  RX_UNDERSCORE,\n} from '../constants/regex'\n\n/**\n * Convert a value to a string that can be rendered `undefined`/`null` will be converted to `''` Plain objects and arrays will be JSON stringified\n *\n * @param val\n * @param spaces\n * @returns\n */\nexport const toString = (val: unknown, spaces = 2): string =>\n  typeof val === 'string'\n    ? val\n    : val === undefined || val === null\n    ? ''\n    : Array.isArray(val) || (isPlainObject(val) && val.toString === Object.prototype.toString)\n    ? JSON.stringify(val, null, spaces)\n    : String(val)\n\n/**\n * @param str\n * @returns\n */\nexport const startCase = (str: string): string =>\n  str\n    .replace(RX_UNDERSCORE, ' ')\n    .replace(RX_LOWER_UPPER, (_, $1, $2) => `${$1} ${$2}`)\n    .replace(RX_FIRST_START_SPACE_WORD, (_, $1, $2) => $1 + $2.toUpperCase())\n\n/**\n * @param str\n * @returns\n */\nexport const titleCase = (str: string): string =>\n  str\n    .replace(RX_UNDERSCORE, ' ')\n    .replace(RX_LOWER_UPPER, (_, $1, $2) => `${$1} ${$2}`)\n    .replace(RX_START_SPACE_WORD, (_, $1, $2) => $1 + $2.toUpperCase())\n\n/**\n * Uppercases the first letter of a string and returns a new string\n *\n * @param str\n * @returns\n */\nexport const upperFirst = (str: string): string => {\n  const trim = str.trim()\n  return trim.charAt(0).toUpperCase() + trim.slice(1)\n}\n\n/**\n * Escapes a string for RegExp usage.\n *\n * @param str\n * @returns\n */\nexport const escapeRegExp = (str: string): string => str.replace(RX_REGEXP_REPLACE, '\\\\$&')\n\n/**\n * Escapes special chars in string and replaces\n * contiguous spaces with a whitespace match\n *\n * @param str\n * @returns\n */\nexport const escapeRegExpChars = (str: string): string =>\n  escapeRegExp(str).replace(RX_SPACES, '\\\\s')\n","import {toString} from './stringUtils'\n\nconst escapeChar = (value: string) => `\\\\${value}`\n\n/**\n * The `cssEscape()` util is based on this `CSS.escape()` polyfill: https://github.com/mathiasbynens/CSS.escape\n *\n * @param {unknown} value\n */\nexport default (value: unknown): string => {\n  const val = toString(value)\n\n  const {length} = val\n  const firstCharCode = val.charCodeAt(0)\n\n  return val.split('').reduce((result: string, char: string, index: number) => {\n    const charCode = val.charCodeAt(index)\n\n    // If the character is NULL (U+0000), use (U+FFFD) as replacement\n    if (charCode === 0x0000) {\n      return `${result}\\uFFFD`\n    }\n\n    // If the character ...\n    if (\n      // ... is U+007F OR\n      charCode === 0x007f ||\n      // ... is in the range [\\1-\\1F] (U+0001 to U+001F) OR ...\n      (charCode >= 0x0001 && charCode <= 0x001f) ||\n      // ... is the first character and is in the range [0-9] (U+0030 to U+0039) OR ...\n      (index === 0 && charCode >= 0x0030 && charCode <= 0x0039) ||\n      // ... is the second character and is in the range [0-9] (U+0030 to U+0039)\n      // and the first character is a `-` (U+002D) ...\n      (index === 1 && charCode >= 0x0030 && charCode <= 0x0039 && firstCharCode === 0x002d)\n    ) {\n      // ... https://drafts.csswg.org/cssom/#escape-a-character-as-code-point\n      return result + escapeChar(`${charCode.toString(16)} `)\n    }\n\n    // If the character ...\n    if (\n      // ... is the first character AND ...\n      index === 0 &&\n      // ... is a `-` (U+002D) AND ...\n      charCode === 0x002d &&\n      // ... there is no second character ...\n      length === 1\n    ) {\n      // ... use the escaped character\n      return result + escapeChar(char)\n    }\n\n    // If the character ...\n    if (\n      // ... is greater than or equal to U+0080 OR ...\n      charCode >= 0x0080 ||\n      // ... is `-` (U+002D) OR ...\n      charCode === 0x002d ||\n      // ... is `_` (U+005F) OR ...\n      charCode === 0x005f ||\n      // ... is in the range [0-9] (U+0030 to U+0039) OR ...\n      (charCode >= 0x0030 && charCode <= 0x0039) ||\n      // ... is in the range [A-Z] (U+0041 to U+005A) OR ...\n      (charCode >= 0x0041 && charCode <= 0x005a) ||\n      // ... is in the range [a-z] (U+0061 to U+007A) ...\n      (charCode >= 0x0061 && charCode <= 0x007a)\n    ) {\n      // ... use the character itself\n      return result + char\n    }\n\n    // Otherwise use the escaped character\n    // See: https://drafts.csswg.org/cssom/#escape-a-character\n    return result + escapeChar(char)\n  }, '')\n}\n","export const HAS_WINDOW_SUPPORT = typeof window !== 'undefined'\nexport const HAS_DOCUMENT_SUPPORT = typeof document !== 'undefined'\nexport const HAS_ELEMENT_SUPPORT = typeof Element !== 'undefined'\nexport const HAS_NAVIGATOR_SUPPORT = typeof navigator !== 'undefined'\nexport const HAS_PROMISE_SUPPORT = typeof Promise !== 'undefined'\n\nexport const IS_BROWSER = HAS_WINDOW_SUPPORT && HAS_DOCUMENT_SUPPORT && HAS_NAVIGATOR_SUPPORT\n\nexport const WINDOW = HAS_WINDOW_SUPPORT ? window : ({} as Record<string, any>)\nexport const DOCUMENT = HAS_DOCUMENT_SUPPORT ? document : ({} as Record<string, any>)\n\n// Determine if the browser supports the option passive for events\nexport const HAS_PASSIVE_EVENT_SUPPORT = (() => {\n  let passiveEventSupported = false\n  if (IS_BROWSER) {\n    try {\n      const options = {\n        // This function will be called when the browser\n        // attempts to access the passive property\n        get passive() {\n          passiveEventSupported = true\n          return passiveEventSupported\n        },\n      }\n      WINDOW.addEventListener('test', options, options)\n      WINDOW.removeEventListener('test', options, options)\n    } catch {\n      passiveEventSupported = false\n    }\n  }\n  return passiveEventSupported\n})()\n","export const HAS_WINDOW_SUPPORT = typeof window !== 'undefined'\nexport const HAS_DOCUMENT_SUPPORT = typeof document !== 'undefined'\nexport const HAS_NAVIGATOR_SUPPORT = typeof navigator !== 'undefined'\nexport const IS_BROWSER = HAS_WINDOW_SUPPORT && HAS_DOCUMENT_SUPPORT && HAS_NAVIGATOR_SUPPORT\nexport const WINDOW = HAS_WINDOW_SUPPORT ? window : {}\n\n// Determine if the browser supports the option passive for events\nexport const HAS_PASSIVE_EVENT_SUPPORT = (() => {\n  let passiveEventSupported = false\n  if (IS_BROWSER) {\n    try {\n      const options = {\n        // This function will be called when the browser\n        // attempts to access the passive property\n        get passive() {\n          passiveEventSupported = true\n          // eslint-disable-next-line no-useless-return\n          return\n        },\n      }\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      WINDOW.addEventListener('test', options, options)\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      WINDOW.removeEventListener('test', options, options)\n    } catch {\n      passiveEventSupported = false\n    }\n  }\n  return passiveEventSupported\n})()\n","import type {Slot} from 'vue'\nimport {DOCUMENT, HAS_ELEMENT_SUPPORT} from '../constants/env'\nimport type {AnimationFrame} from '../types/safeTypes'\nimport {HAS_WINDOW_SUPPORT} from './env'\nimport {toString} from './stringUtils'\n\nconst ELEMENT_PROTO = HAS_ELEMENT_SUPPORT ? Element.prototype : undefined\n\n/**\n * @link https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill\n */\nexport const matchesEl =\n  ELEMENT_PROTO?.matches ||\n  (ELEMENT_PROTO as any)?.msMatchesSelector ||\n  ELEMENT_PROTO?.webkitMatchesSelector\n\nexport const isElement = (el: HTMLElement | Element): boolean =>\n  !!(el && el.nodeType === Node.ELEMENT_NODE)\n\nexport const getBCR = (el: HTMLElement) => (isElement(el) ? el.getBoundingClientRect() : null)\n\nexport const getActiveElement = (excludes = []): Element | null => {\n  const {activeElement} = document\n  return activeElement && !excludes.some((el: HTMLElement) => el === activeElement)\n    ? activeElement\n    : null\n}\n\nexport const isActiveElement = (el: HTMLElement): boolean =>\n  isElement(el) && el === getActiveElement()\n\nexport const attemptFocus = (el: HTMLElement, options = {}): boolean => {\n  try {\n    el.focus(options)\n  } catch (e) {\n    // eslint-disable-next-line no-console\n    console.error(e)\n  }\n  return isActiveElement(el)\n}\n\n/**\n * Attempt to blur an element, and return `true` if successful\n *\n * @param el\n * @returns\n */\nexport const attemptBlur = (el: HTMLElement): boolean => {\n  try {\n    el.blur()\n  } catch (e) {\n    // eslint-disable-next-line no-console\n    console.error(e)\n  }\n  return !isActiveElement(el)\n}\n\nexport const getStyle = (el: HTMLElement, prop: string) =>\n  prop && isElement(el) ? el.getAttribute(prop) || null : null\n\nexport const contains = (parent: Node, child: Node): boolean => parent.contains(child)\n\nexport const isVisible = (el: HTMLElement): boolean => {\n  //if (!isElement(el) || !el.parentNode || !contains(DOCUMENT.body, el)) {\n  // Note this can fail for shadow dom elements since they\n  // are not a direct descendant of document.body\n  //return false\n  //}\n  if (getStyle(el, 'display') === 'none') {\n    // We do this check to help with vue-test-utils when using v-show\n    return false\n  }\n  // All browsers support getBoundingClientRect(), except JSDOM as it returns all 0's for values :(\n  // So any tests that need isVisible will fail in JSDOM\n  // Except when we override the getBCR prototype in some tests\n  const bcr = getBCR(el)\n  return !!(bcr && bcr.height > 0 && bcr.width > 0)\n}\n\nexport const isEmptySlot = (el: Slot | undefined): boolean => (el?.() ?? []).length === 0\n\n/**\n * Select a single element, returns `null` if not found\n *\n * @param selector\n * @param root\n * @returns\n */\nexport const select = (selector: any, root: any) =>\n  (isElement(root) ? root : DOCUMENT).querySelector(selector) || null\n\nexport const selectAll = (selector: any, root: any) =>\n  Array.from([(isElement(root) ? root : DOCUMENT).querySelectorAll(selector)])\n\nexport const getAttr = (el: HTMLElement | Element, attr: string): string | null =>\n  attr && isElement(el) ? el.getAttribute(attr) : null\n\n/**\n * Get an element given an ID\n */\nexport const getById = (id: string) =>\n  DOCUMENT.getElementById(/^#/.test(id) ? id.slice(1) : id) || null\n\nexport const setAttr = (el: HTMLElement, attr: string, value: string): void => {\n  if (attr && isElement(el)) {\n    el.setAttribute(attr, value)\n  }\n}\n\n/**\n * Remove an attribute from an element\n *\n * @param el\n * @param attr\n */\nexport const removeAttr = (el: HTMLElement, attr: string): void => {\n  if (attr && isElement(el)) {\n    el.removeAttribute(attr)\n  }\n}\n\nexport const isTag = (tag: any, name: any): boolean =>\n  toString(tag).toLowerCase() === toString(name).toLowerCase()\n\nexport const requestAF: AnimationFrame = HAS_WINDOW_SUPPORT\n  ? window.requestAnimationFrame ||\n    window.webkitRequestAnimationFrame ||\n    window.mozRequestAnimationFrame ||\n    window.msRequestAnimationFrame ||\n    window.oRequestAnimationFrame ||\n    // Fallback, but not a true polyfill\n    // Only needed for Opera Mini\n    ((cb) => setTimeout(cb, 16))\n  : (cb) => setTimeout(cb, 0)\n\nexport const matches = (el: Element, selector: string) =>\n  isElement(el) ? matchesEl.call(el, selector) : false\n\n/**\n * @link https://developer.mozilla.org/en-US/docs/Web/API/Element/closest\n */\n/* eslint-disable @typescript-eslint/no-this-alias */\nexport const closestEl =\n  ELEMENT_PROTO?.closest ||\n  function (this: Element, sel: string) {\n    let el = this\n    if (!el) return null\n    do {\n      // Use our \"patched\" matches function\n      if (matches(el, sel)) {\n        return el\n      }\n      el = el.parentElement || (el.parentNode as any)\n    } while (el !== null && el.nodeType === Node.ELEMENT_NODE)\n    return null\n  }\n\n/**\n * Finds closest element matching selector. Returns `null` if not found\n *\n * @param selector\n * @param root\n * @param includeRoot\n */\nexport const closest = (selector: string, root: Element, includeRoot = false) => {\n  if (!isElement(root)) {\n    return null\n  }\n  const el = closestEl.call(root, selector)\n  // Native closest behaviour when `includeRoot` is truthy,\n  // else emulate jQuery closest and return `null` if match is\n  // the passed in root element when `includeRoot` is falsey\n  return includeRoot ? el : el === root ? null : el\n}\n\nexport const getTransitionDelay = (element: HTMLElement) => {\n  const style = window.getComputedStyle(element)\n  // if multiple durations are defined, we take the first\n  const transitionDelay = style.transitionDelay.split(',')[0] || ''\n  const transitionDuration = style.transitionDuration.split(',')[0] || ''\n  const transitionDelayMs = Number(transitionDelay.slice(0, -1)) * 1000\n  const transitionDurationMs = Number(transitionDuration.slice(0, -1)) * 1000\n  return transitionDelayMs + transitionDurationMs\n}\n","type PropDefinition = {\n  type: any[]\n  default: any\n}\n\nexport interface ComponentProps {\n  [key: string]: PropDefinition\n}\n\nexport default (\n  prefix: string,\n  breakpoints: string[],\n  definition: PropDefinition\n): ComponentProps =>\n  breakpoints.concat(['sm', 'md', 'lg', 'xl', 'xxl']).reduce((props, breakpoint) => {\n    props[\n      !prefix ? breakpoint : `${prefix}${breakpoint.charAt(0).toUpperCase() + breakpoint.slice(1)}`\n    ] = definition\n    return props\n  }, Object.create(null))\n","export interface ComponentProps {\n  [key: string]: {type: any[]; default: any}\n}\n\nexport default (\n  props: Record<PropertyKey, unknown>,\n  els: ComponentProps,\n  propPrefix: string,\n  classPrefix = propPrefix\n): string[] =>\n  Object.keys(els).reduce((arr: string[], prop) => {\n    if (!props[prop]) return arr\n\n    arr.push(\n      [classPrefix, prop.replace(propPrefix, ''), props[prop]]\n        .filter((e) => e && typeof e !== 'boolean')\n        .join('-')\n        .toLowerCase()\n    )\n\n    return arr\n  }, [])\n","export default (suffix = ''): string =>\n  `__BVID__${Math.random().toString().slice(2, 8)}___BV_${suffix}__`\n","import type {RouteLocationRaw} from 'vue-router'\n\nexport default (props: {href?: string; to?: RouteLocationRaw}): boolean =>\n  !!(props.href || props.to)\n","import type {Slots, VNode} from 'vue'\n\nexport default (name: string, scope = {}, $slots: Slots = {}): VNode => {\n  // Ensure names is an array\n  const names = [name]\n  let slot\n  for (let i = 0; i < names.length && !slot; i++) {\n    const name = names[i]\n    slot = $slots[name]\n  }\n  // Note: in Vue 3.x, slots have been unified. No more scoped slots and all slots are exposed as functions\n  return (slot && typeof slot === 'function' ? slot(scope) : slot) as unknown as VNode\n}\n","/**\n * Validates a number is an integer. If not return NaN\n *\n * @param value\n * @param defaultValue\n * @returns\n */\nexport const toInteger = (value: number, defaultValue = NaN): number =>\n  Number.isInteger(value) ? value : defaultValue\n\n/**\n * @param value\n * @param defaultValue\n * @returns\n */\nexport const stringToInteger = (value: string, defaultValue = NaN): number => {\n  const integer = Number.parseInt(value, 10)\n  return Number.isNaN(integer) ? defaultValue : integer\n}\n\n/**\n * Validates a number is a float. If not return NaN\n *\n * @param value\n * @param defaultValue\n * @returns\n */\nexport const toFloat = (value: number | string, defaultValue = NaN): number => {\n  const float = Number.parseFloat(value.toString())\n  return Number.isNaN(float) ? defaultValue : float\n}\n","/**\n * Removes properties from an object, based on the values in an array, and returns the new object.\n * Equivalent to an object version of TS Omit<>\n *\n * @param {Record<PropertyKey, unknown>} objToPluck\n * @param {ReadonlyArray<PropertyKey>} keysToPluck\n * @returns\n */\nexport const omit = <A extends Record<PropertyKey, unknown>, B extends ReadonlyArray<PropertyKey>>(\n  objToPluck: A,\n  keysToPluck: B\n): Omit<A, B[number]> =>\n  Object.keys(objToPluck)\n    .filter((key) => !keysToPluck.includes(key))\n    .reduce((result, key) => ({...result, [key]: objToPluck[key]}), {} as Omit<A, B[number]>)\n\n/**\n * Deeply clones an item\n *\n * @param {T} source\n * @returns\n */\nexport const cloneDeep = <T>(source: T): T =>\n  Array.isArray(source)\n    ? source.map((item) => cloneDeep(item))\n    : source instanceof Date\n    ? new Date(source.getTime())\n    : source && typeof source === 'object'\n    ? Object.getOwnPropertyNames(source).reduce((o, prop) => {\n        Object.defineProperty(o, prop, Object.getOwnPropertyDescriptor(source, prop) ?? {})\n        o[prop] = cloneDeep((source as unknown as {[key: string]: unknown})[prop])\n        return o\n      }, Object.create(Object.getPrototypeOf(source)))\n    : source\n\nexport const cloneDeepAsync = <T>(source: T): Promise<T> =>\n  new Promise((resolve) => resolve(cloneDeep(source)))\n","// Suffix can be a falsey value so nothing is appended to string\n// (helps when looping over props & some shouldn't change)\n\nimport {upperFirst} from './stringUtils'\n\n/**\n * Use data last parameters to allow for currying\n *\n * @param suffix\n * @param value\n * @returns\n */\nexport const suffixPropName = (suffix: string, value: string): string =>\n  value + (suffix ? upperFirst(suffix) : '')\n\n/**\n * Given an array of properties or an object of property keys, plucks all the values off the target object, returning a new object that has props that reference the original prop values.\n * An object equivelent to TS Pick<>\n *\n * @param {ReadonlyArray<PropertyKey> | Record<PropertyKey, unknown>} keysToPluck\n * @param {Record<PropertyKey, unknown>} objToPluck\n * @returns\n */\nexport const pluckProps = <\n  A extends Record<PropertyKey, unknown>,\n  B extends ReadonlyArray<PropertyKey> | Record<PropertyKey, unknown>\n>(\n  objToPluck: A,\n  keysToPluck: B\n): B extends readonly PropertyKey[] ? Pick<A, B[number]> : Pick<A, keyof B> =>\n  (Array.isArray(keysToPluck) ? keysToPluck.slice() : Object.keys(keysToPluck)).reduce(\n    (memo, prop) => {\n      memo[prop] = objToPluck[prop]\n      return memo\n    },\n    {}\n  )\n","import type {AriaInvalid} from '../types'\n\n/**\n * Resolves the aria-invalid and state props to a basic aria-invalid attribute\n *\n * @param {AriaInvalid} ariaInvalid `Truthy` values, and more specific `'grammar' | 'spelling'` values have higher priority than 'state' param, `Falsy` values have lower priority than 'state'\n * @param {boolean} state If the prop state is `false`, it will render the aria-invalid attribute to be `'true'`, as the value would be considered invalid\n * @returns Truthy > Grammar | Spelling > State > Falsy\n */\nexport default (\n  ariaInvalid?: AriaInvalid,\n  state?: boolean | null\n): Exclude<AriaInvalid, ''> | undefined =>\n  ariaInvalid === true || ariaInvalid === 'true' || ariaInvalid === ''\n    ? 'true'\n    : ariaInvalid === 'grammar' || ariaInvalid === 'spelling'\n    ? ariaInvalid\n    : state === false\n    ? 'true'\n    : ariaInvalid === false || ariaInvalid === 'false'\n    ? 'false'\n    : undefined\n","import type {InjectionKey, Ref} from 'vue'\nimport type {ButtonVariant, ColorVariant, Size} from '../types'\n\n// BCarousel\nexport const carouselInjectionKey: InjectionKey<{\n  background: Readonly<Ref<string | undefined>>\n  width: Readonly<Ref<string | undefined>>\n  height: Readonly<Ref<string | undefined>>\n}> = Symbol('carousel')\n\n// BTabs\nexport const tabsInjectionKey: InjectionKey<{\n  lazy: Readonly<Ref<boolean>>\n  card: Readonly<Ref<boolean>>\n}> = Symbol('tabs')\n\n// BProgress\nexport const progressInjectionKey: InjectionKey<{\n  animated: Readonly<Ref<boolean>>\n  max: Readonly<Ref<number | string>>\n  showProgress: Readonly<Ref<boolean>>\n  showValue: Readonly<Ref<boolean>>\n  striped: Readonly<Ref<boolean>>\n}> = Symbol('progress')\n\n// BListGroup\nexport const listGroupInjectionKey: InjectionKey<{\n  numbered: Readonly<Ref<boolean>>\n}> = Symbol('listGroup')\n\n// BAvatarGroup\nexport const avatarGroupInjectionKey: InjectionKey<{\n  overlapScale: Readonly<Ref<number>>\n  size: Readonly<Ref<Size | string | undefined>>\n  square: Readonly<Ref<boolean>>\n  rounded: Readonly<Ref<boolean | string>>\n  variant: Readonly<Ref<ColorVariant | null>>\n}> = Symbol('avatarGroup')\n\n// BAccordion\nexport const accordionInjectionKey: InjectionKey<{\n  openItem: Readonly<Ref<string | undefined>>\n  free: Readonly<Ref<boolean>>\n  setOpenItem: (id: string) => void\n}> = Symbol('accordion')\n\n// BFormCheckboxGroup\nexport const checkboxGroupKey: InjectionKey<{\n  set: (\n    payload: unknown[] | Set<unknown> | boolean | string | Record<string, unknown> | number | null\n  ) => void\n  remove: (\n    payload: unknown[] | Set<unknown> | boolean | string | Record<string, unknown> | number | null\n  ) => void\n  modelValue: Readonly<\n    Ref<(unknown[] | Set<unknown> | boolean | string | Record<string, unknown> | number | null)[]>\n  >\n  switch: Readonly<Ref<boolean>>\n  buttonVariant: Readonly<Ref<ButtonVariant | null>>\n  form: Readonly<Ref<string | undefined>>\n  name: Readonly<Ref<string>>\n  state: Readonly<Ref<boolean | undefined | null>>\n  plain: Readonly<Ref<boolean>>\n  size: Readonly<Ref<Size>>\n  inline: Readonly<Ref<boolean>>\n  required: Readonly<Ref<boolean>>\n  buttons: Readonly<Ref<boolean>>\n  disabled: Readonly<Ref<boolean>>\n}> = Symbol('checkboxGroup')\n\nexport const radioGroupKey: InjectionKey<{\n  set: (value: string | boolean | unknown[] | Record<string, unknown> | number | null) => void\n  modelValue: Readonly<Ref<string | boolean | unknown[] | Record<string, unknown> | number | null>>\n  buttonVariant: Readonly<Ref<ButtonVariant | null>>\n  form: Readonly<Ref<string | undefined>>\n  name: Readonly<Ref<string>>\n  buttons: Readonly<Ref<boolean>>\n  state: Readonly<Ref<boolean | undefined | null>>\n  plain: Readonly<Ref<boolean>>\n  size: Readonly<Ref<Size>>\n  inline: Readonly<Ref<boolean>>\n  required: Readonly<Ref<boolean>>\n  disabled: Readonly<Ref<boolean>>\n}> = Symbol('radioGroup')\n\n// Collapse\nexport const collapseInjectionKey: InjectionKey<{\n  id?: Readonly<Ref<string>>\n  readonly close?: () => void\n  readonly open?: () => void\n  readonly toggle?: () => void\n  visible?: Readonly<Ref<boolean>>\n  isNav?: Readonly<Ref<boolean>>\n}> = Symbol('collapse')\n\nexport const dropdownInjectionKey: InjectionKey<{\n  id?: Readonly<Ref<string>>\n  readonly close?: () => void\n  readonly open?: () => void\n  readonly toggle?: () => void\n  visible?: Readonly<Ref<boolean>>\n  isNav?: Readonly<Ref<boolean>>\n}> = Symbol('collapse')\n\nexport const navbarInjectionKey: InjectionKey<{\n  tag?: Readonly<Ref<string>>\n}> = Symbol('navbar')\n","import type {Slot, VNode} from 'vue'\n\nexport default (slot: Slot | undefined, filterBy: string): VNode[] =>\n  (slot?.() ?? [])\n    .reduce((arr: VNode[], slot: VNode) => {\n      if (typeof slot.type === 'symbol') {\n        arr = arr.concat(slot.children as unknown as VNode)\n      } else {\n        arr.push(slot)\n      }\n      return arr\n    }, [])\n    .filter((child) => (child.type as {__name: string} | undefined)?.__name === filterBy)\n","function t(t){return t.split(\"-\")[1]}function e(t){return\"y\"===t?\"height\":\"width\"}function n(t){return t.split(\"-\")[0]}function o(t){return[\"top\",\"bottom\"].includes(n(t))?\"x\":\"y\"}function i(i,r,a){let{reference:l,floating:s}=i;const c=l.x+l.width/2-s.width/2,f=l.y+l.height/2-s.height/2,m=o(r),u=e(m),g=l[u]/2-s[u]/2,d=\"x\"===m;let p;switch(n(r)){case\"top\":p={x:c,y:l.y-s.height};break;case\"bottom\":p={x:c,y:l.y+l.height};break;case\"right\":p={x:l.x+l.width,y:f};break;case\"left\":p={x:l.x-s.width,y:f};break;default:p={x:l.x,y:l.y}}switch(t(r)){case\"start\":p[m]-=g*(a&&d?-1:1);break;case\"end\":p[m]+=g*(a&&d?-1:1)}return p}const r=async(t,e,n)=>{const{placement:o=\"bottom\",strategy:r=\"absolute\",middleware:a=[],platform:l}=n,s=a.filter(Boolean),c=await(null==l.isRTL?void 0:l.isRTL(e));let f=await l.getElementRects({reference:t,floating:e,strategy:r}),{x:m,y:u}=i(f,o,c),g=o,d={},p=0;for(let n=0;n<s.length;n++){const{name:a,fn:h}=s[n],{x:y,y:x,data:w,reset:v}=await h({x:m,y:u,initialPlacement:o,placement:g,strategy:r,middlewareData:d,rects:f,platform:l,elements:{reference:t,floating:e}});m=null!=y?y:m,u=null!=x?x:u,d={...d,[a]:{...d[a],...w}},v&&p<=50&&(p++,\"object\"==typeof v&&(v.placement&&(g=v.placement),v.rects&&(f=!0===v.rects?await l.getElementRects({reference:t,floating:e,strategy:r}):v.rects),({x:m,y:u}=i(f,g,c))),n=-1)}return{x:m,y:u,placement:g,strategy:r,middlewareData:d}};function a(t,e){return\"function\"==typeof t?t(e):t}function l(t){return\"number\"!=typeof t?function(t){return{top:0,right:0,bottom:0,left:0,...t}}(t):{top:t,right:t,bottom:t,left:t}}function s(t){return{...t,top:t.y,left:t.x,right:t.x+t.width,bottom:t.y+t.height}}async function c(t,e){var n;void 0===e&&(e={});const{x:o,y:i,platform:r,rects:c,elements:f,strategy:m}=t,{boundary:u=\"clippingAncestors\",rootBoundary:g=\"viewport\",elementContext:d=\"floating\",altBoundary:p=!1,padding:h=0}=a(e,t),y=l(h),x=f[p?\"floating\"===d?\"reference\":\"floating\":d],w=s(await r.getClippingRect({element:null==(n=await(null==r.isElement?void 0:r.isElement(x)))||n?x:x.contextElement||await(null==r.getDocumentElement?void 0:r.getDocumentElement(f.floating)),boundary:u,rootBoundary:g,strategy:m})),v=\"floating\"===d?{...c.floating,x:o,y:i}:c.reference,b=await(null==r.getOffsetParent?void 0:r.getOffsetParent(f.floating)),A=await(null==r.isElement?void 0:r.isElement(b))&&await(null==r.getScale?void 0:r.getScale(b))||{x:1,y:1},R=s(r.convertOffsetParentRelativeRectToViewportRelativeRect?await r.convertOffsetParentRelativeRectToViewportRelativeRect({rect:v,offsetParent:b,strategy:m}):v);return{top:(w.top-R.top+y.top)/A.y,bottom:(R.bottom-w.bottom+y.bottom)/A.y,left:(w.left-R.left+y.left)/A.x,right:(R.right-w.right+y.right)/A.x}}const f=Math.min,m=Math.max;function u(t,e,n){return m(t,f(e,n))}const g=n=>({name:\"arrow\",options:n,async fn(i){const{x:r,y:s,placement:c,rects:m,platform:g,elements:d}=i,{element:p,padding:h=0}=a(n,i)||{};if(null==p)return{};const y=l(h),x={x:r,y:s},w=o(c),v=e(w),b=await g.getDimensions(p),A=\"y\"===w,R=A?\"top\":\"left\",P=A?\"bottom\":\"right\",E=A?\"clientHeight\":\"clientWidth\",T=m.reference[v]+m.reference[w]-x[w]-m.floating[v],D=x[w]-m.reference[w],L=await(null==g.getOffsetParent?void 0:g.getOffsetParent(p));let k=L?L[E]:0;k&&await(null==g.isElement?void 0:g.isElement(L))||(k=d.floating[E]||m.floating[v]);const O=T/2-D/2,B=k/2-b[v]/2-1,C=f(y[R],B),H=f(y[P],B),S=C,F=k-b[v]-H,M=k/2-b[v]/2+O,V=u(S,M,F),W=null!=t(c)&&M!=V&&m.reference[v]/2-(M<S?C:H)-b[v]/2<0?M<S?S-M:F-M:0;return{[w]:x[w]-W,data:{[w]:V,centerOffset:M-V+W}}}}),d=[\"top\",\"right\",\"bottom\",\"left\"],p=d.reduce(((t,e)=>t.concat(e,e+\"-start\",e+\"-end\")),[]),h={left:\"right\",right:\"left\",bottom:\"top\",top:\"bottom\"};function y(t){return t.replace(/left|right|bottom|top/g,(t=>h[t]))}function x(n,i,r){void 0===r&&(r=!1);const a=t(n),l=o(n),s=e(l);let c=\"x\"===l?a===(r?\"end\":\"start\")?\"right\":\"left\":\"start\"===a?\"bottom\":\"top\";return i.reference[s]>i.floating[s]&&(c=y(c)),{main:c,cross:y(c)}}const w={start:\"end\",end:\"start\"};function v(t){return t.replace(/start|end/g,(t=>w[t]))}const b=function(e){return void 0===e&&(e={}),{name:\"autoPlacement\",options:e,async fn(o){var i,r,l;const{rects:s,middlewareData:f,placement:m,platform:u,elements:g}=o,{crossAxis:d=!1,alignment:h,allowedPlacements:y=p,autoAlignment:w=!0,...b}=a(e,o),A=void 0!==h||y===p?function(e,o,i){return(e?[...i.filter((n=>t(n)===e)),...i.filter((n=>t(n)!==e))]:i.filter((t=>n(t)===t))).filter((n=>!e||t(n)===e||!!o&&v(n)!==n))}(h||null,w,y):y,R=await c(o,b),P=(null==(i=f.autoPlacement)?void 0:i.index)||0,E=A[P];if(null==E)return{};const{main:T,cross:D}=x(E,s,await(null==u.isRTL?void 0:u.isRTL(g.floating)));if(m!==E)return{reset:{placement:A[0]}};const L=[R[n(E)],R[T],R[D]],k=[...(null==(r=f.autoPlacement)?void 0:r.overflows)||[],{placement:E,overflows:L}],O=A[P+1];if(O)return{data:{index:P+1,overflows:k},reset:{placement:O}};const B=k.map((e=>{const n=t(e.placement);return[e.placement,n&&d?e.overflows.slice(0,2).reduce(((t,e)=>t+e),0):e.overflows[0],e.overflows]})).sort(((t,e)=>t[1]-e[1])),C=(null==(l=B.filter((e=>e[2].slice(0,t(e[0])?2:3).every((t=>t<=0))))[0])?void 0:l[0])||B[0][0];return C!==m?{data:{index:P+1,overflows:k},reset:{placement:C}}:{}}}};const A=function(e){return void 0===e&&(e={}),{name:\"flip\",options:e,async fn(o){var i;const{placement:r,middlewareData:l,rects:s,initialPlacement:f,platform:m,elements:u}=o,{mainAxis:g=!0,crossAxis:d=!0,fallbackPlacements:p,fallbackStrategy:h=\"bestFit\",fallbackAxisSideDirection:w=\"none\",flipAlignment:b=!0,...A}=a(e,o),R=n(r),P=n(f)===f,E=await(null==m.isRTL?void 0:m.isRTL(u.floating)),T=p||(P||!b?[y(f)]:function(t){const e=y(t);return[v(t),e,v(e)]}(f));p||\"none\"===w||T.push(...function(e,o,i,r){const a=t(e);let l=function(t,e,n){const o=[\"left\",\"right\"],i=[\"right\",\"left\"],r=[\"top\",\"bottom\"],a=[\"bottom\",\"top\"];switch(t){case\"top\":case\"bottom\":return n?e?i:o:e?o:i;case\"left\":case\"right\":return e?r:a;default:return[]}}(n(e),\"start\"===i,r);return a&&(l=l.map((t=>t+\"-\"+a)),o&&(l=l.concat(l.map(v)))),l}(f,b,w,E));const D=[f,...T],L=await c(o,A),k=[];let O=(null==(i=l.flip)?void 0:i.overflows)||[];if(g&&k.push(L[R]),d){const{main:t,cross:e}=x(r,s,E);k.push(L[t],L[e])}if(O=[...O,{placement:r,overflows:k}],!k.every((t=>t<=0))){var B,C;const t=((null==(B=l.flip)?void 0:B.index)||0)+1,e=D[t];if(e)return{data:{index:t,overflows:O},reset:{placement:e}};let n=null==(C=O.filter((t=>t.overflows[0]<=0)).sort(((t,e)=>t.overflows[1]-e.overflows[1]))[0])?void 0:C.placement;if(!n)switch(h){case\"bestFit\":{var H;const t=null==(H=O.map((t=>[t.placement,t.overflows.filter((t=>t>0)).reduce(((t,e)=>t+e),0)])).sort(((t,e)=>t[1]-e[1]))[0])?void 0:H[0];t&&(n=t);break}case\"initialPlacement\":n=f}if(r!==n)return{reset:{placement:n}}}return{}}}};function R(t,e){return{top:t.top-e.height,right:t.right-e.width,bottom:t.bottom-e.height,left:t.left-e.width}}function P(t){return d.some((e=>t[e]>=0))}const E=function(t){return void 0===t&&(t={}),{name:\"hide\",options:t,async fn(e){const{rects:n}=e,{strategy:o=\"referenceHidden\",...i}=a(t,e);switch(o){case\"referenceHidden\":{const t=R(await c(e,{...i,elementContext:\"reference\"}),n.reference);return{data:{referenceHiddenOffsets:t,referenceHidden:P(t)}}}case\"escaped\":{const t=R(await c(e,{...i,altBoundary:!0}),n.floating);return{data:{escapedOffsets:t,escaped:P(t)}}}default:return{}}}}};function T(t){const e=f(...t.map((t=>t.left))),n=f(...t.map((t=>t.top)));return{x:e,y:n,width:m(...t.map((t=>t.right)))-e,height:m(...t.map((t=>t.bottom)))-n}}const D=function(t){return void 0===t&&(t={}),{name:\"inline\",options:t,async fn(e){const{placement:i,elements:r,rects:c,platform:u,strategy:g}=e,{padding:d=2,x:p,y:h}=a(t,e),y=Array.from(await(null==u.getClientRects?void 0:u.getClientRects(r.reference))||[]),x=function(t){const e=t.slice().sort(((t,e)=>t.y-e.y)),n=[];let o=null;for(let t=0;t<e.length;t++){const i=e[t];!o||i.y-o.y>o.height/2?n.push([i]):n[n.length-1].push(i),o=i}return n.map((t=>s(T(t))))}(y),w=s(T(y)),v=l(d);const b=await u.getElementRects({reference:{getBoundingClientRect:function(){if(2===x.length&&x[0].left>x[1].right&&null!=p&&null!=h)return x.find((t=>p>t.left-v.left&&p<t.right+v.right&&h>t.top-v.top&&h<t.bottom+v.bottom))||w;if(x.length>=2){if(\"x\"===o(i)){const t=x[0],e=x[x.length-1],o=\"top\"===n(i),r=t.top,a=e.bottom,l=o?t.left:e.left,s=o?t.right:e.right;return{top:r,bottom:a,left:l,right:s,width:s-l,height:a-r,x:l,y:r}}const t=\"left\"===n(i),e=m(...x.map((t=>t.right))),r=f(...x.map((t=>t.left))),a=x.filter((n=>t?n.left===r:n.right===e)),l=a[0].top,s=a[a.length-1].bottom;return{top:l,bottom:s,left:r,right:e,width:e-r,height:s-l,x:r,y:l}}return w}},floating:r.floating,strategy:g});return c.reference.x!==b.reference.x||c.reference.y!==b.reference.y||c.reference.width!==b.reference.width||c.reference.height!==b.reference.height?{reset:{rects:b}}:{}}}};const L=function(e){return void 0===e&&(e=0),{name:\"offset\",options:e,async fn(i){const{x:r,y:l}=i,s=await async function(e,i){const{placement:r,platform:l,elements:s}=e,c=await(null==l.isRTL?void 0:l.isRTL(s.floating)),f=n(r),m=t(r),u=\"x\"===o(r),g=[\"left\",\"top\"].includes(f)?-1:1,d=c&&u?-1:1,p=a(i,e);let{mainAxis:h,crossAxis:y,alignmentAxis:x}=\"number\"==typeof p?{mainAxis:p,crossAxis:0,alignmentAxis:null}:{mainAxis:0,crossAxis:0,alignmentAxis:null,...p};return m&&\"number\"==typeof x&&(y=\"end\"===m?-1*x:x),u?{x:y*d,y:h*g}:{x:h*g,y:y*d}}(i,e);return{x:r+s.x,y:l+s.y,data:s}}}};function k(t){return\"x\"===t?\"y\":\"x\"}const O=function(t){return void 0===t&&(t={}),{name:\"shift\",options:t,async fn(e){const{x:i,y:r,placement:l}=e,{mainAxis:s=!0,crossAxis:f=!1,limiter:m={fn:t=>{let{x:e,y:n}=t;return{x:e,y:n}}},...g}=a(t,e),d={x:i,y:r},p=await c(e,g),h=o(n(l)),y=k(h);let x=d[h],w=d[y];if(s){const t=\"y\"===h?\"bottom\":\"right\";x=u(x+p[\"y\"===h?\"top\":\"left\"],x,x-p[t])}if(f){const t=\"y\"===y?\"bottom\":\"right\";w=u(w+p[\"y\"===y?\"top\":\"left\"],w,w-p[t])}const v=m.fn({...e,[h]:x,[y]:w});return{...v,data:{x:v.x-i,y:v.y-r}}}}},B=function(t){return void 0===t&&(t={}),{options:t,fn(e){const{x:i,y:r,placement:l,rects:s,middlewareData:c}=e,{offset:f=0,mainAxis:m=!0,crossAxis:u=!0}=a(t,e),g={x:i,y:r},d=o(l),p=k(d);let h=g[d],y=g[p];const x=a(f,e),w=\"number\"==typeof x?{mainAxis:x,crossAxis:0}:{mainAxis:0,crossAxis:0,...x};if(m){const t=\"y\"===d?\"height\":\"width\",e=s.reference[d]-s.floating[t]+w.mainAxis,n=s.reference[d]+s.reference[t]-w.mainAxis;h<e?h=e:h>n&&(h=n)}if(u){var v,b;const t=\"y\"===d?\"width\":\"height\",e=[\"top\",\"left\"].includes(n(l)),o=s.reference[p]-s.floating[t]+(e&&(null==(v=c.offset)?void 0:v[p])||0)+(e?0:w.crossAxis),i=s.reference[p]+s.reference[t]+(e?0:(null==(b=c.offset)?void 0:b[p])||0)-(e?w.crossAxis:0);y<o?y=o:y>i&&(y=i)}return{[d]:h,[p]:y}}}},C=function(e){return void 0===e&&(e={}),{name:\"size\",options:e,async fn(i){const{placement:r,rects:l,platform:s,elements:u}=i,{apply:g=(()=>{}),...d}=a(e,i),p=await c(i,d),h=n(r),y=t(r),x=\"x\"===o(r),{width:w,height:v}=l.floating;let b,A;\"top\"===h||\"bottom\"===h?(b=h,A=y===(await(null==s.isRTL?void 0:s.isRTL(u.floating))?\"start\":\"end\")?\"left\":\"right\"):(A=h,b=\"end\"===y?\"top\":\"bottom\");const R=v-p[b],P=w-p[A],E=!i.middlewareData.shift;let T=R,D=P;if(x){const t=w-p.left-p.right;D=y||E?f(P,t):t}else{const t=v-p.top-p.bottom;T=y||E?f(R,t):t}if(E&&!y){const t=m(p.left,0),e=m(p.right,0),n=m(p.top,0),o=m(p.bottom,0);x?D=w-2*(0!==t||0!==e?t+e:m(p.left,p.right)):T=v-2*(0!==n||0!==o?n+o:m(p.top,p.bottom))}await g({...i,availableWidth:D,availableHeight:T});const L=await s.getDimensions(u.floating);return w!==L.width||v!==L.height?{reset:{rects:!0}}:{}}}};export{g as arrow,b as autoPlacement,r as computePosition,c as detectOverflow,A as flip,E as hide,D as inline,B as limitShift,L as offset,s as rectToClientRect,O as shift,C as size};\n","import{rectToClientRect as t,computePosition as e}from\"@floating-ui/core\";export{arrow,autoPlacement,detectOverflow,flip,hide,inline,limitShift,offset,shift,size}from\"@floating-ui/core\";function n(t){var e;return(null==(e=t.ownerDocument)?void 0:e.defaultView)||window}function o(t){return n(t).getComputedStyle(t)}function i(t){return t instanceof n(t).Node}function r(t){return i(t)?(t.nodeName||\"\").toLowerCase():\"\"}function l(t){return t instanceof n(t).HTMLElement}function c(t){return t instanceof n(t).Element}function s(t){if(\"undefined\"==typeof ShadowRoot)return!1;return t instanceof n(t).ShadowRoot||t instanceof ShadowRoot}function f(t){const{overflow:e,overflowX:n,overflowY:i,display:r}=o(t);return/auto|scroll|overlay|hidden|clip/.test(e+i+n)&&![\"inline\",\"contents\"].includes(r)}function u(t){return[\"table\",\"td\",\"th\"].includes(r(t))}function a(t){const e=d(),n=o(t);return\"none\"!==n.transform||\"none\"!==n.perspective||!e&&!!n.backdropFilter&&\"none\"!==n.backdropFilter||!e&&!!n.filter&&\"none\"!==n.filter||[\"transform\",\"perspective\",\"filter\"].some((t=>(n.willChange||\"\").includes(t)))||[\"paint\",\"layout\",\"strict\",\"content\"].some((t=>(n.contain||\"\").includes(t)))}function d(){return!(\"undefined\"==typeof CSS||!CSS.supports)&&CSS.supports(\"-webkit-backdrop-filter\",\"none\")}function h(t){return[\"html\",\"body\",\"#document\"].includes(r(t))}const p=Math.min,m=Math.max,g=Math.round;function y(t){const e=o(t);let n=parseFloat(e.width)||0,i=parseFloat(e.height)||0;const r=l(t),c=r?t.offsetWidth:n,s=r?t.offsetHeight:i,f=g(n)!==c||g(i)!==s;return f&&(n=c,i=s),{width:n,height:i,fallback:f}}function x(t){return c(t)?t:t.contextElement}const w={x:1,y:1};function v(t){const e=x(t);if(!l(e))return w;const n=e.getBoundingClientRect(),{width:o,height:i,fallback:r}=y(e);let c=(r?g(n.width):n.width)/o,s=(r?g(n.height):n.height)/i;return c&&Number.isFinite(c)||(c=1),s&&Number.isFinite(s)||(s=1),{x:c,y:s}}const b={x:0,y:0};function L(t,e,o){var i,r;if(void 0===e&&(e=!0),!d())return b;const l=t?n(t):window;return!o||e&&o!==l?b:{x:(null==(i=l.visualViewport)?void 0:i.offsetLeft)||0,y:(null==(r=l.visualViewport)?void 0:r.offsetTop)||0}}function E(e,o,i,r){void 0===o&&(o=!1),void 0===i&&(i=!1);const l=e.getBoundingClientRect(),s=x(e);let f=w;o&&(r?c(r)&&(f=v(r)):f=v(e));const u=L(s,i,r);let a=(l.left+u.x)/f.x,d=(l.top+u.y)/f.y,h=l.width/f.x,p=l.height/f.y;if(s){const t=n(s),e=r&&c(r)?n(r):r;let o=t.frameElement;for(;o&&r&&e!==t;){const t=v(o),e=o.getBoundingClientRect(),i=getComputedStyle(o);e.x+=(o.clientLeft+parseFloat(i.paddingLeft))*t.x,e.y+=(o.clientTop+parseFloat(i.paddingTop))*t.y,a*=t.x,d*=t.y,h*=t.x,p*=t.y,a+=e.x,d+=e.y,o=n(o).frameElement}}return t({width:h,height:p,x:a,y:d})}function R(t){return((i(t)?t.ownerDocument:t.document)||window.document).documentElement}function T(t){return c(t)?{scrollLeft:t.scrollLeft,scrollTop:t.scrollTop}:{scrollLeft:t.pageXOffset,scrollTop:t.pageYOffset}}function S(t){return E(R(t)).left+T(t).scrollLeft}function C(t){if(\"html\"===r(t))return t;const e=t.assignedSlot||t.parentNode||s(t)&&t.host||R(t);return s(e)?e.host:e}function F(t){const e=C(t);return h(e)?e.ownerDocument.body:l(e)&&f(e)?e:F(e)}function W(t,e){var o;void 0===e&&(e=[]);const i=F(t),r=i===(null==(o=t.ownerDocument)?void 0:o.body),l=n(i);return r?e.concat(l,l.visualViewport||[],f(i)?i:[]):e.concat(i,W(i))}function D(e,i,r){let s;if(\"viewport\"===i)s=function(t,e){const o=n(t),i=R(t),r=o.visualViewport;let l=i.clientWidth,c=i.clientHeight,s=0,f=0;if(r){l=r.width,c=r.height;const t=d();(!t||t&&\"fixed\"===e)&&(s=r.offsetLeft,f=r.offsetTop)}return{width:l,height:c,x:s,y:f}}(e,r);else if(\"document\"===i)s=function(t){const e=R(t),n=T(t),i=t.ownerDocument.body,r=m(e.scrollWidth,e.clientWidth,i.scrollWidth,i.clientWidth),l=m(e.scrollHeight,e.clientHeight,i.scrollHeight,i.clientHeight);let c=-n.scrollLeft+S(t);const s=-n.scrollTop;return\"rtl\"===o(i).direction&&(c+=m(e.clientWidth,i.clientWidth)-r),{width:r,height:l,x:c,y:s}}(R(e));else if(c(i))s=function(t,e){const n=E(t,!0,\"fixed\"===e),o=n.top+t.clientTop,i=n.left+t.clientLeft,r=l(t)?v(t):{x:1,y:1};return{width:t.clientWidth*r.x,height:t.clientHeight*r.y,x:i*r.x,y:o*r.y}}(i,r);else{const t=L(e);s={...i,x:i.x-t.x,y:i.y-t.y}}return t(s)}function H(t,e){const n=C(t);return!(n===e||!c(n)||h(n))&&(\"fixed\"===o(n).position||H(n,e))}function O(t,e){return l(t)&&\"fixed\"!==o(t).position?e?e(t):t.offsetParent:null}function P(t,e){const i=n(t);if(!l(t))return i;let c=O(t,e);for(;c&&u(c)&&\"static\"===o(c).position;)c=O(c,e);return c&&(\"html\"===r(c)||\"body\"===r(c)&&\"static\"===o(c).position&&!a(c))?i:c||function(t){let e=C(t);for(;l(e)&&!h(e);){if(a(e))return e;e=C(e)}return null}(t)||i}function V(t,e,n){const o=l(e),i=R(e),c=\"fixed\"===n,s=E(t,!0,c,e);let u={scrollLeft:0,scrollTop:0};const a={x:0,y:0};if(o||!o&&!c)if((\"body\"!==r(e)||f(i))&&(u=T(e)),l(e)){const t=E(e,!0,c,e);a.x=t.x+e.clientLeft,a.y=t.y+e.clientTop}else i&&(a.x=S(i));return{x:s.left+u.scrollLeft-a.x,y:s.top+u.scrollTop-a.y,width:s.width,height:s.height}}const k={getClippingRect:function(t){let{element:e,boundary:n,rootBoundary:i,strategy:l}=t;const s=\"clippingAncestors\"===n?function(t,e){const n=e.get(t);if(n)return n;let i=W(t).filter((t=>c(t)&&\"body\"!==r(t))),l=null;const s=\"fixed\"===o(t).position;let u=s?C(t):t;for(;c(u)&&!h(u);){const e=o(u),n=a(u);n||\"fixed\"!==e.position||(l=null),(s?!n&&!l:!n&&\"static\"===e.position&&l&&[\"absolute\",\"fixed\"].includes(l.position)||f(u)&&!n&&H(t,u))?i=i.filter((t=>t!==u)):l=e,u=C(u)}return e.set(t,i),i}(e,this._c):[].concat(n),u=[...s,i],d=u[0],g=u.reduce(((t,n)=>{const o=D(e,n,l);return t.top=m(o.top,t.top),t.right=p(o.right,t.right),t.bottom=p(o.bottom,t.bottom),t.left=m(o.left,t.left),t}),D(e,d,l));return{width:g.right-g.left,height:g.bottom-g.top,x:g.left,y:g.top}},convertOffsetParentRelativeRectToViewportRelativeRect:function(t){let{rect:e,offsetParent:n,strategy:o}=t;const i=l(n),c=R(n);if(n===c)return e;let s={scrollLeft:0,scrollTop:0},u={x:1,y:1};const a={x:0,y:0};if((i||!i&&\"fixed\"!==o)&&((\"body\"!==r(n)||f(c))&&(s=T(n)),l(n))){const t=E(n);u=v(n),a.x=t.x+n.clientLeft,a.y=t.y+n.clientTop}return{width:e.width*u.x,height:e.height*u.y,x:e.x*u.x-s.scrollLeft*u.x+a.x,y:e.y*u.y-s.scrollTop*u.y+a.y}},isElement:c,getDimensions:function(t){return y(t)},getOffsetParent:P,getDocumentElement:R,getScale:v,async getElementRects(t){let{reference:e,floating:n,strategy:o}=t;const i=this.getOffsetParent||P,r=this.getDimensions;return{reference:V(e,await i(n),o),floating:{x:0,y:0,...await r(n)}}},getClientRects:t=>Array.from(t.getClientRects()),isRTL:t=>\"rtl\"===o(t).direction};function z(t,e,n,o){void 0===o&&(o={});const{ancestorScroll:i=!0,ancestorResize:r=!0,elementResize:l=!0,animationFrame:s=!1}=o,f=i||r?[...c(t)?W(t):t.contextElement?W(t.contextElement):[],...W(e)]:[];f.forEach((t=>{const e=!c(t)&&t.toString().includes(\"V\");!i||s&&!e||t.addEventListener(\"scroll\",n,{passive:!0}),r&&t.addEventListener(\"resize\",n)}));let u,a=null;l&&(a=new ResizeObserver((()=>{n()})),c(t)&&!s&&a.observe(t),c(t)||!t.contextElement||s||a.observe(t.contextElement),a.observe(e));let d=s?E(t):null;return s&&function e(){const o=E(t);!d||o.x===d.x&&o.y===d.y&&o.width===d.width&&o.height===d.height||n();d=o,u=requestAnimationFrame(e)}(),n(),()=>{var t;f.forEach((t=>{i&&t.removeEventListener(\"scroll\",n),r&&t.removeEventListener(\"resize\",n)})),null==(t=a)||t.disconnect(),a=null,s&&cancelAnimationFrame(u)}}const M=(t,n,o)=>{const i=new Map,r={platform:k,...o},l={...r.platform,_c:i};return e(t,n,{...r,platform:l})};export{z as autoUpdate,M as computePosition,W as getOverflowAncestors,k as platform};\n","import { arrow as arrow$1, computePosition } from '@floating-ui/dom';\nexport * from '@floating-ui/dom';\nimport { unref, computed, ref, shallowRef, watch, getCurrentScope, onScopeDispose, shallowReadonly } from 'vue-demi';\n\nfunction unwrapElement(element) {\n  var _$el;\n  return (_$el = element == null ? void 0 : element.$el) != null ? _$el : element;\n}\n\n/**\n * Positions an inner element of the floating element such that it is centered to the reference element.\n * @param options The arrow options.\n * @see https://floating-ui.com/docs/arrow\n */\nfunction arrow(options) {\n  return {\n    name: 'arrow',\n    options,\n    fn(args) {\n      const element = unwrapElement(unref(options.element));\n      if (element == null) {\n        return {};\n      }\n      return arrow$1({\n        element,\n        padding: options.padding\n      }).fn(args);\n    }\n  };\n}\n\nfunction getDPR(element) {\n  if (typeof window === 'undefined') {\n    return 1;\n  }\n  const win = element.ownerDocument.defaultView || window;\n  return win.devicePixelRatio || 1;\n}\n\nfunction roundByDPR(element, value) {\n  const dpr = getDPR(element);\n  return Math.round(value * dpr) / dpr;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element next to a reference element when it is given a certain CSS positioning strategy.\n * @param reference The reference template ref.\n * @param floating The floating template ref.\n * @param options The floating options.\n * @see https://floating-ui.com/docs/vue\n */\nfunction useFloating(reference, floating, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const whileElementsMountedOption = options.whileElementsMounted;\n  const openOption = computed(() => {\n    var _unref;\n    return (_unref = unref(options.open)) != null ? _unref : true;\n  });\n  const middlewareOption = computed(() => unref(options.middleware));\n  const placementOption = computed(() => {\n    var _unref2;\n    return (_unref2 = unref(options.placement)) != null ? _unref2 : 'bottom';\n  });\n  const strategyOption = computed(() => {\n    var _unref3;\n    return (_unref3 = unref(options.strategy)) != null ? _unref3 : 'absolute';\n  });\n  const transformOption = computed(() => {\n    var _unref4;\n    return (_unref4 = unref(options.transform)) != null ? _unref4 : true;\n  });\n  const referenceElement = computed(() => unwrapElement(reference.value));\n  const floatingElement = computed(() => unwrapElement(floating.value));\n  const x = ref(0);\n  const y = ref(0);\n  const strategy = ref(strategyOption.value);\n  const placement = ref(placementOption.value);\n  const middlewareData = shallowRef({});\n  const isPositioned = ref(false);\n  const floatingStyles = computed(() => {\n    const initialStyles = {\n      position: strategy.value,\n      left: '0',\n      top: '0'\n    };\n    if (!floatingElement.value) {\n      return initialStyles;\n    }\n    const xVal = roundByDPR(floatingElement.value, x.value);\n    const yVal = roundByDPR(floatingElement.value, y.value);\n    if (transformOption.value) {\n      return {\n        ...initialStyles,\n        transform: \"translate(\" + xVal + \"px, \" + yVal + \"px)\",\n        ...(getDPR(floatingElement.value) >= 1.5 && {\n          willChange: 'transform'\n        })\n      };\n    }\n    return {\n      position: strategy.value,\n      left: xVal + \"px\",\n      top: yVal + \"px\"\n    };\n  });\n  let whileElementsMountedCleanup;\n  function update() {\n    if (referenceElement.value == null || floatingElement.value == null) {\n      return;\n    }\n    computePosition(referenceElement.value, floatingElement.value, {\n      middleware: middlewareOption.value,\n      placement: placementOption.value,\n      strategy: strategyOption.value\n    }).then(position => {\n      x.value = position.x;\n      y.value = position.y;\n      strategy.value = position.strategy;\n      placement.value = position.placement;\n      middlewareData.value = position.middlewareData;\n      isPositioned.value = true;\n    });\n  }\n  function cleanup() {\n    if (typeof whileElementsMountedCleanup === 'function') {\n      whileElementsMountedCleanup();\n      whileElementsMountedCleanup = undefined;\n    }\n  }\n  function attach() {\n    cleanup();\n    if (whileElementsMountedOption === undefined) {\n      update();\n      return;\n    }\n    if (referenceElement.value != null && floatingElement.value != null) {\n      whileElementsMountedCleanup = whileElementsMountedOption(referenceElement.value, floatingElement.value, update);\n      return;\n    }\n  }\n  function reset() {\n    if (!openOption.value) {\n      isPositioned.value = false;\n    }\n  }\n  watch([middlewareOption, placementOption, strategyOption], update, {\n    flush: 'sync'\n  });\n  watch([referenceElement, floatingElement], attach, {\n    flush: 'sync'\n  });\n  watch(openOption, reset, {\n    flush: 'sync'\n  });\n  if (getCurrentScope()) {\n    onScopeDispose(cleanup);\n  }\n  return {\n    x: shallowReadonly(x),\n    y: shallowReadonly(y),\n    strategy: shallowReadonly(strategy),\n    placement: shallowReadonly(placement),\n    middlewareData: shallowReadonly(middlewareData),\n    isPositioned: shallowReadonly(isPositioned),\n    floatingStyles,\n    update\n  };\n}\n\nexport { arrow, useFloating };\n","/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.2.3): util/sanitizer.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nconst uriAttributes = new Set([\n  'background',\n  'cite',\n  'href',\n  'itemtype',\n  'longdesc',\n  'poster',\n  'src',\n  'xlink:href',\n])\n\nconst ARIA_ATTRIBUTE_PATTERN = /^aria-[\\w-]*$/i\n\n/**\n * A pattern that recognizes a commonly useful subset of URLs that are safe.\n *\n * Shout-out to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts\n */\nconst SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i\n\n/**\n * A pattern that matches safe data URLs. Only matches image, video and audio types.\n *\n * Shout-out to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts\n */\nconst DATA_URL_PATTERN =\n  /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[\\d+/a-z]+=*$/i\n\nconst allowedAttribute = (attribute: Attr, allowedAttributeList: (string | RegExp)[]) => {\n  const attributeName = attribute.nodeName.toLowerCase()\n\n  if (allowedAttributeList.includes(attributeName)) {\n    if (uriAttributes.has(attributeName)) {\n      return Boolean(\n        SAFE_URL_PATTERN.test(attribute.nodeValue || '') ||\n          DATA_URL_PATTERN.test(attribute.nodeValue || '')\n      )\n    }\n\n    return true\n  }\n\n  // Check if a regular expression validates the attribute.\n  return allowedAttributeList\n    .filter((attributeRegex: any) => attributeRegex instanceof RegExp)\n    .some((regex: any) => regex.test(attributeName))\n}\n\nexport const DefaultAllowlist = {\n  // Global attributes allowed on any supplied element below.\n  '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],\n  'a': ['target', 'href', 'title', 'rel'],\n  'area': [],\n  'b': [],\n  'br': [],\n  'col': [],\n  'code': [],\n  'div': [],\n  'em': [],\n  'hr': [],\n  'h1': [],\n  'h2': [],\n  'h3': [],\n  'h4': [],\n  'h5': [],\n  'h6': [],\n  'i': [],\n  'img': ['src', 'srcset', 'alt', 'title', 'width', 'height'],\n  'li': [],\n  'ol': [],\n  'p': [],\n  'pre': [],\n  's': [],\n  'small': [],\n  'span': [],\n  'sub': [],\n  'sup': [],\n  'strong': [],\n  'u': [],\n  'ul': [],\n}\n\nexport const sanitizeHtml = (\n  unsafeHtml: string,\n  allowList: Record<string, (string | RegExp)[]>,\n  sanitizeFunction?: (unsafeHtml: string) => string\n) => {\n  if (!unsafeHtml.length) {\n    return unsafeHtml\n  }\n\n  if (sanitizeFunction && typeof sanitizeFunction === 'function') {\n    return sanitizeFunction(unsafeHtml)\n  }\n\n  const domParser = new window.DOMParser()\n  const createdDocument = domParser.parseFromString(unsafeHtml, 'text/html')\n  const elements: NodeListOf<Element> = createdDocument.body.querySelectorAll('*')\n\n  for (const element of elements) {\n    const elementName = element.nodeName.toLowerCase()\n\n    if (!Object.keys(allowList).includes(elementName)) {\n      element.remove()\n\n      continue\n    }\n\n    const attributeList = element.attributes\n    const allowedAttributes = [...(allowList['*'] || []), ...(allowList[elementName] || [])]\n\n    for (const attribute of attributeList) {\n      if (!allowedAttribute(attribute, allowedAttributes)) {\n        element.removeAttribute(attribute.nodeName)\n      }\n    }\n  }\n\n  return createdDocument.body.innerHTML\n}\n","import { shallowRef, watchEffect, readonly, ref, watch, customRef, getCurrentScope, onScopeDispose, effectScope, provide, inject, isVue3, version, isRef, unref, computed, reactive, toRefs as toRefs$1, toRef as toRef$1, isVue2, set as set$1, getCurrentInstance, onBeforeMount, nextTick, onBeforeUnmount, onMounted, onUnmounted, isReactive } from 'vue-demi';\n\nvar __defProp$b = Object.defineProperty;\nvar __defProps$8 = Object.defineProperties;\nvar __getOwnPropDescs$8 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$d = Object.getOwnPropertySymbols;\nvar __hasOwnProp$d = Object.prototype.hasOwnProperty;\nvar __propIsEnum$d = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$b(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$b = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$d.call(b, prop))\n      __defNormalProp$b(a, prop, b[prop]);\n  if (__getOwnPropSymbols$d)\n    for (var prop of __getOwnPropSymbols$d(b)) {\n      if (__propIsEnum$d.call(b, prop))\n        __defNormalProp$b(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$8 = (a, b) => __defProps$8(a, __getOwnPropDescs$8(b));\nfunction computedEager(fn, options) {\n  var _a;\n  const result = shallowRef();\n  watchEffect(() => {\n    result.value = fn();\n  }, __spreadProps$8(__spreadValues$b({}, options), {\n    flush: (_a = options == null ? void 0 : options.flush) != null ? _a : \"sync\"\n  }));\n  return readonly(result);\n}\n\nfunction computedWithControl(source, fn) {\n  let v = void 0;\n  let track;\n  let trigger;\n  const dirty = ref(true);\n  const update = () => {\n    dirty.value = true;\n    trigger();\n  };\n  watch(source, update, { flush: \"sync\" });\n  const get = typeof fn === \"function\" ? fn : fn.get;\n  const set = typeof fn === \"function\" ? void 0 : fn.set;\n  const result = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        if (dirty.value) {\n          v = get();\n          dirty.value = false;\n        }\n        track();\n        return v;\n      },\n      set(v2) {\n        set == null ? void 0 : set(v2);\n      }\n    };\n  });\n  if (Object.isExtensible(result))\n    result.trigger = update;\n  return result;\n}\n\nfunction tryOnScopeDispose(fn) {\n  if (getCurrentScope()) {\n    onScopeDispose(fn);\n    return true;\n  }\n  return false;\n}\n\nfunction createEventHook() {\n  const fns = /* @__PURE__ */ new Set();\n  const off = (fn) => {\n    fns.delete(fn);\n  };\n  const on = (fn) => {\n    fns.add(fn);\n    const offFn = () => off(fn);\n    tryOnScopeDispose(offFn);\n    return {\n      off: offFn\n    };\n  };\n  const trigger = (param) => {\n    return Promise.all(Array.from(fns).map((fn) => fn(param)));\n  };\n  return {\n    on,\n    off,\n    trigger\n  };\n}\n\nfunction createGlobalState(stateFactory) {\n  let initialized = false;\n  let state;\n  const scope = effectScope(true);\n  return (...args) => {\n    if (!initialized) {\n      state = scope.run(() => stateFactory(...args));\n      initialized = true;\n    }\n    return state;\n  };\n}\n\nfunction createInjectionState(composable) {\n  const key = Symbol(\"InjectionState\");\n  const useProvidingState = (...args) => {\n    const state = composable(...args);\n    provide(key, state);\n    return state;\n  };\n  const useInjectedState = () => inject(key);\n  return [useProvidingState, useInjectedState];\n}\n\nfunction createSharedComposable(composable) {\n  let subscribers = 0;\n  let state;\n  let scope;\n  const dispose = () => {\n    subscribers -= 1;\n    if (scope && subscribers <= 0) {\n      scope.stop();\n      state = void 0;\n      scope = void 0;\n    }\n  };\n  return (...args) => {\n    subscribers += 1;\n    if (!state) {\n      scope = effectScope(true);\n      state = scope.run(() => composable(...args));\n    }\n    tryOnScopeDispose(dispose);\n    return state;\n  };\n}\n\nfunction extendRef(ref, extend, { enumerable = false, unwrap = true } = {}) {\n  if (!isVue3 && !version.startsWith(\"2.7.\")) {\n    if (process.env.NODE_ENV !== \"production\")\n      throw new Error(\"[VueUse] extendRef only works in Vue 2.7 or above.\");\n    return;\n  }\n  for (const [key, value] of Object.entries(extend)) {\n    if (key === \"value\")\n      continue;\n    if (isRef(value) && unwrap) {\n      Object.defineProperty(ref, key, {\n        get() {\n          return value.value;\n        },\n        set(v) {\n          value.value = v;\n        },\n        enumerable\n      });\n    } else {\n      Object.defineProperty(ref, key, { value, enumerable });\n    }\n  }\n  return ref;\n}\n\nfunction get(obj, key) {\n  if (key == null)\n    return unref(obj);\n  return unref(obj)[key];\n}\n\nfunction isDefined(v) {\n  return unref(v) != null;\n}\n\nvar __defProp$a = Object.defineProperty;\nvar __getOwnPropSymbols$c = Object.getOwnPropertySymbols;\nvar __hasOwnProp$c = Object.prototype.hasOwnProperty;\nvar __propIsEnum$c = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$a = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$c.call(b, prop))\n      __defNormalProp$a(a, prop, b[prop]);\n  if (__getOwnPropSymbols$c)\n    for (var prop of __getOwnPropSymbols$c(b)) {\n      if (__propIsEnum$c.call(b, prop))\n        __defNormalProp$a(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction makeDestructurable(obj, arr) {\n  if (typeof Symbol !== \"undefined\") {\n    const clone = __spreadValues$a({}, obj);\n    Object.defineProperty(clone, Symbol.iterator, {\n      enumerable: false,\n      value() {\n        let index = 0;\n        return {\n          next: () => ({\n            value: arr[index++],\n            done: index > arr.length\n          })\n        };\n      }\n    });\n    return clone;\n  } else {\n    return Object.assign([...arr], obj);\n  }\n}\n\nfunction toValue(r) {\n  return typeof r === \"function\" ? r() : unref(r);\n}\nconst resolveUnref = toValue;\n\nfunction reactify(fn, options) {\n  const unrefFn = (options == null ? void 0 : options.computedGetter) === false ? unref : toValue;\n  return function(...args) {\n    return computed(() => fn.apply(this, args.map((i) => unrefFn(i))));\n  };\n}\n\nfunction reactifyObject(obj, optionsOrKeys = {}) {\n  let keys = [];\n  let options;\n  if (Array.isArray(optionsOrKeys)) {\n    keys = optionsOrKeys;\n  } else {\n    options = optionsOrKeys;\n    const { includeOwnProperties = true } = optionsOrKeys;\n    keys.push(...Object.keys(obj));\n    if (includeOwnProperties)\n      keys.push(...Object.getOwnPropertyNames(obj));\n  }\n  return Object.fromEntries(\n    keys.map((key) => {\n      const value = obj[key];\n      return [\n        key,\n        typeof value === \"function\" ? reactify(value.bind(obj), options) : value\n      ];\n    })\n  );\n}\n\nfunction toReactive(objectRef) {\n  if (!isRef(objectRef))\n    return reactive(objectRef);\n  const proxy = new Proxy({}, {\n    get(_, p, receiver) {\n      return unref(Reflect.get(objectRef.value, p, receiver));\n    },\n    set(_, p, value) {\n      if (isRef(objectRef.value[p]) && !isRef(value))\n        objectRef.value[p].value = value;\n      else\n        objectRef.value[p] = value;\n      return true;\n    },\n    deleteProperty(_, p) {\n      return Reflect.deleteProperty(objectRef.value, p);\n    },\n    has(_, p) {\n      return Reflect.has(objectRef.value, p);\n    },\n    ownKeys() {\n      return Object.keys(objectRef.value);\n    },\n    getOwnPropertyDescriptor() {\n      return {\n        enumerable: true,\n        configurable: true\n      };\n    }\n  });\n  return reactive(proxy);\n}\n\nfunction reactiveComputed(fn) {\n  return toReactive(computed(fn));\n}\n\nfunction reactiveOmit(obj, ...keys) {\n  const flatKeys = keys.flat();\n  const predicate = flatKeys[0];\n  return reactiveComputed(\n    () => typeof predicate === \"function\" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v]) => !predicate(toValue(v), k))) : Object.fromEntries(Object.entries(toRefs$1(obj)).filter((e) => !flatKeys.includes(e[0])))\n  );\n}\n\nconst isClient = typeof window !== \"undefined\";\nconst isDef = (val) => typeof val !== \"undefined\";\nconst notNullish = (val) => val != null;\nconst assert = (condition, ...infos) => {\n  if (!condition)\n    console.warn(...infos);\n};\nconst toString = Object.prototype.toString;\nconst isObject = (val) => toString.call(val) === \"[object Object]\";\nconst now = () => Date.now();\nconst timestamp = () => +Date.now();\nconst clamp = (n, min, max) => Math.min(max, Math.max(min, n));\nconst noop = () => {\n};\nconst rand = (min, max) => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\nconst hasOwn = (val, key) => Object.prototype.hasOwnProperty.call(val, key);\nconst isIOS = /* @__PURE__ */ getIsIOS();\nfunction getIsIOS() {\n  var _a;\n  return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /* @__PURE__ */ /iP(ad|hone|od)/.test(window.navigator.userAgent);\n}\n\nfunction createFilterWrapper(filter, fn) {\n  function wrapper(...args) {\n    return new Promise((resolve, reject) => {\n      Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);\n    });\n  }\n  return wrapper;\n}\nconst bypassFilter = (invoke) => {\n  return invoke();\n};\nfunction debounceFilter(ms, options = {}) {\n  let timer;\n  let maxTimer;\n  let lastRejector = noop;\n  const _clearTimeout = (timer2) => {\n    clearTimeout(timer2);\n    lastRejector();\n    lastRejector = noop;\n  };\n  const filter = (invoke) => {\n    const duration = toValue(ms);\n    const maxDuration = toValue(options.maxWait);\n    if (timer)\n      _clearTimeout(timer);\n    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {\n      if (maxTimer) {\n        _clearTimeout(maxTimer);\n        maxTimer = null;\n      }\n      return Promise.resolve(invoke());\n    }\n    return new Promise((resolve, reject) => {\n      lastRejector = options.rejectOnCancel ? reject : resolve;\n      if (maxDuration && !maxTimer) {\n        maxTimer = setTimeout(() => {\n          if (timer)\n            _clearTimeout(timer);\n          maxTimer = null;\n          resolve(invoke());\n        }, maxDuration);\n      }\n      timer = setTimeout(() => {\n        if (maxTimer)\n          _clearTimeout(maxTimer);\n        maxTimer = null;\n        resolve(invoke());\n      }, duration);\n    });\n  };\n  return filter;\n}\nfunction throttleFilter(ms, trailing = true, leading = true, rejectOnCancel = false) {\n  let lastExec = 0;\n  let timer;\n  let isLeading = true;\n  let lastRejector = noop;\n  let lastValue;\n  const clear = () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n      lastRejector();\n      lastRejector = noop;\n    }\n  };\n  const filter = (_invoke) => {\n    const duration = toValue(ms);\n    const elapsed = Date.now() - lastExec;\n    const invoke = () => {\n      return lastValue = _invoke();\n    };\n    clear();\n    if (duration <= 0) {\n      lastExec = Date.now();\n      return invoke();\n    }\n    if (elapsed > duration && (leading || !isLeading)) {\n      lastExec = Date.now();\n      invoke();\n    } else if (trailing) {\n      lastValue = new Promise((resolve, reject) => {\n        lastRejector = rejectOnCancel ? reject : resolve;\n        timer = setTimeout(() => {\n          lastExec = Date.now();\n          isLeading = true;\n          resolve(invoke());\n          clear();\n        }, Math.max(0, duration - elapsed));\n      });\n    }\n    if (!leading && !timer)\n      timer = setTimeout(() => isLeading = true, duration);\n    isLeading = false;\n    return lastValue;\n  };\n  return filter;\n}\nfunction pausableFilter(extendFilter = bypassFilter) {\n  const isActive = ref(true);\n  function pause() {\n    isActive.value = false;\n  }\n  function resume() {\n    isActive.value = true;\n  }\n  const eventFilter = (...args) => {\n    if (isActive.value)\n      extendFilter(...args);\n  };\n  return { isActive: readonly(isActive), pause, resume, eventFilter };\n}\n\nconst directiveHooks = {\n  mounted: isVue3 ? \"mounted\" : \"inserted\",\n  updated: isVue3 ? \"updated\" : \"componentUpdated\",\n  unmounted: isVue3 ? \"unmounted\" : \"unbind\"\n};\n\nfunction promiseTimeout(ms, throwOnTimeout = false, reason = \"Timeout\") {\n  return new Promise((resolve, reject) => {\n    if (throwOnTimeout)\n      setTimeout(() => reject(reason), ms);\n    else\n      setTimeout(resolve, ms);\n  });\n}\nfunction identity(arg) {\n  return arg;\n}\nfunction createSingletonPromise(fn) {\n  let _promise;\n  function wrapper() {\n    if (!_promise)\n      _promise = fn();\n    return _promise;\n  }\n  wrapper.reset = async () => {\n    const _prev = _promise;\n    _promise = void 0;\n    if (_prev)\n      await _prev;\n  };\n  return wrapper;\n}\nfunction invoke(fn) {\n  return fn();\n}\nfunction containsProp(obj, ...props) {\n  return props.some((k) => k in obj);\n}\nfunction increaseWithUnit(target, delta) {\n  var _a;\n  if (typeof target === \"number\")\n    return target + delta;\n  const value = ((_a = target.match(/^-?[0-9]+\\.?[0-9]*/)) == null ? void 0 : _a[0]) || \"\";\n  const unit = target.slice(value.length);\n  const result = Number.parseFloat(value) + delta;\n  if (Number.isNaN(result))\n    return target;\n  return result + unit;\n}\nfunction objectPick(obj, keys, omitUndefined = false) {\n  return keys.reduce((n, k) => {\n    if (k in obj) {\n      if (!omitUndefined || obj[k] !== void 0)\n        n[k] = obj[k];\n    }\n    return n;\n  }, {});\n}\nfunction objectOmit(obj, keys, omitUndefined = false) {\n  return Object.fromEntries(Object.entries(obj).filter(([key, value]) => {\n    return (!omitUndefined || value !== void 0) && !keys.includes(key);\n  }));\n}\nfunction objectEntries(obj) {\n  return Object.entries(obj);\n}\n\nfunction toRef(...args) {\n  if (args.length !== 1)\n    return toRef$1(...args);\n  const r = args[0];\n  return typeof r === \"function\" ? readonly(customRef(() => ({ get: r, set: noop }))) : ref(r);\n}\nconst resolveRef = toRef;\n\nfunction reactivePick(obj, ...keys) {\n  const flatKeys = keys.flat();\n  const predicate = flatKeys[0];\n  return reactiveComputed(() => typeof predicate === \"function\" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v]) => predicate(toValue(v), k))) : Object.fromEntries(flatKeys.map((k) => [k, toRef(obj, k)])));\n}\n\nfunction refAutoReset(defaultValue, afterMs = 1e4) {\n  return customRef((track, trigger) => {\n    let value = defaultValue;\n    let timer;\n    const resetAfter = () => setTimeout(() => {\n      value = defaultValue;\n      trigger();\n    }, toValue(afterMs));\n    tryOnScopeDispose(() => {\n      clearTimeout(timer);\n    });\n    return {\n      get() {\n        track();\n        return value;\n      },\n      set(newValue) {\n        value = newValue;\n        trigger();\n        clearTimeout(timer);\n        timer = resetAfter();\n      }\n    };\n  });\n}\n\nfunction useDebounceFn(fn, ms = 200, options = {}) {\n  return createFilterWrapper(\n    debounceFilter(ms, options),\n    fn\n  );\n}\n\nfunction refDebounced(value, ms = 200, options = {}) {\n  const debounced = ref(value.value);\n  const updater = useDebounceFn(() => {\n    debounced.value = value.value;\n  }, ms, options);\n  watch(value, () => updater());\n  return debounced;\n}\n\nfunction refDefault(source, defaultValue) {\n  return computed({\n    get() {\n      var _a;\n      return (_a = source.value) != null ? _a : defaultValue;\n    },\n    set(value) {\n      source.value = value;\n    }\n  });\n}\n\nfunction useThrottleFn(fn, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {\n  return createFilterWrapper(\n    throttleFilter(ms, trailing, leading, rejectOnCancel),\n    fn\n  );\n}\n\nfunction refThrottled(value, delay = 200, trailing = true, leading = true) {\n  if (delay <= 0)\n    return value;\n  const throttled = ref(value.value);\n  const updater = useThrottleFn(() => {\n    throttled.value = value.value;\n  }, delay, trailing, leading);\n  watch(value, () => updater());\n  return throttled;\n}\n\nfunction refWithControl(initial, options = {}) {\n  let source = initial;\n  let track;\n  let trigger;\n  const ref = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        return get();\n      },\n      set(v) {\n        set(v);\n      }\n    };\n  });\n  function get(tracking = true) {\n    if (tracking)\n      track();\n    return source;\n  }\n  function set(value, triggering = true) {\n    var _a, _b;\n    if (value === source)\n      return;\n    const old = source;\n    if (((_a = options.onBeforeChange) == null ? void 0 : _a.call(options, value, old)) === false)\n      return;\n    source = value;\n    (_b = options.onChanged) == null ? void 0 : _b.call(options, value, old);\n    if (triggering)\n      trigger();\n  }\n  const untrackedGet = () => get(false);\n  const silentSet = (v) => set(v, false);\n  const peek = () => get(false);\n  const lay = (v) => set(v, false);\n  return extendRef(\n    ref,\n    {\n      get,\n      set,\n      untrackedGet,\n      silentSet,\n      peek,\n      lay\n    },\n    { enumerable: true }\n  );\n}\nconst controlledRef = refWithControl;\n\nfunction set(...args) {\n  if (args.length === 2) {\n    const [ref, value] = args;\n    ref.value = value;\n  }\n  if (args.length === 3) {\n    if (isVue2) {\n      set$1(...args);\n    } else {\n      const [target, key, value] = args;\n      target[key] = value;\n    }\n  }\n}\n\nfunction syncRef(left, right, options = {}) {\n  var _a, _b;\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true,\n    direction = \"both\",\n    transform = {}\n  } = options;\n  let watchLeft;\n  let watchRight;\n  const transformLTR = (_a = transform.ltr) != null ? _a : (v) => v;\n  const transformRTL = (_b = transform.rtl) != null ? _b : (v) => v;\n  if (direction === \"both\" || direction === \"ltr\") {\n    watchLeft = watch(\n      left,\n      (newValue) => right.value = transformLTR(newValue),\n      { flush, deep, immediate }\n    );\n  }\n  if (direction === \"both\" || direction === \"rtl\") {\n    watchRight = watch(\n      right,\n      (newValue) => left.value = transformRTL(newValue),\n      { flush, deep, immediate }\n    );\n  }\n  return () => {\n    watchLeft == null ? void 0 : watchLeft();\n    watchRight == null ? void 0 : watchRight();\n  };\n}\n\nfunction syncRefs(source, targets, options = {}) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true\n  } = options;\n  if (!Array.isArray(targets))\n    targets = [targets];\n  return watch(\n    source,\n    (newValue) => targets.forEach((target) => target.value = newValue),\n    { flush, deep, immediate }\n  );\n}\n\nvar __defProp$9 = Object.defineProperty;\nvar __defProps$7 = Object.defineProperties;\nvar __getOwnPropDescs$7 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$b = Object.getOwnPropertySymbols;\nvar __hasOwnProp$b = Object.prototype.hasOwnProperty;\nvar __propIsEnum$b = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$9 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$b.call(b, prop))\n      __defNormalProp$9(a, prop, b[prop]);\n  if (__getOwnPropSymbols$b)\n    for (var prop of __getOwnPropSymbols$b(b)) {\n      if (__propIsEnum$b.call(b, prop))\n        __defNormalProp$9(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$7 = (a, b) => __defProps$7(a, __getOwnPropDescs$7(b));\nfunction toRefs(objectRef) {\n  if (!isRef(objectRef))\n    return toRefs$1(objectRef);\n  const result = Array.isArray(objectRef.value) ? new Array(objectRef.value.length) : {};\n  for (const key in objectRef.value) {\n    result[key] = customRef(() => ({\n      get() {\n        return objectRef.value[key];\n      },\n      set(v) {\n        if (Array.isArray(objectRef.value)) {\n          const copy = [...objectRef.value];\n          copy[key] = v;\n          objectRef.value = copy;\n        } else {\n          const newObject = __spreadProps$7(__spreadValues$9({}, objectRef.value), { [key]: v });\n          Object.setPrototypeOf(newObject, objectRef.value);\n          objectRef.value = newObject;\n        }\n      }\n    }));\n  }\n  return result;\n}\n\nfunction tryOnBeforeMount(fn, sync = true) {\n  if (getCurrentInstance())\n    onBeforeMount(fn);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnBeforeUnmount(fn) {\n  if (getCurrentInstance())\n    onBeforeUnmount(fn);\n}\n\nfunction tryOnMounted(fn, sync = true) {\n  if (getCurrentInstance())\n    onMounted(fn);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnUnmounted(fn) {\n  if (getCurrentInstance())\n    onUnmounted(fn);\n}\n\nfunction createUntil(r, isNot = false) {\n  function toMatch(condition, { flush = \"sync\", deep = false, timeout, throwOnTimeout } = {}) {\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch(\n        r,\n        (v) => {\n          if (condition(v) !== isNot) {\n            stop == null ? void 0 : stop();\n            resolve(v);\n          }\n        },\n        {\n          flush,\n          deep,\n          immediate: true\n        }\n      );\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(\n        promiseTimeout(timeout, throwOnTimeout).then(() => toValue(r)).finally(() => stop == null ? void 0 : stop())\n      );\n    }\n    return Promise.race(promises);\n  }\n  function toBe(value, options) {\n    if (!isRef(value))\n      return toMatch((v) => v === value, options);\n    const { flush = \"sync\", deep = false, timeout, throwOnTimeout } = options != null ? options : {};\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch(\n        [r, value],\n        ([v1, v2]) => {\n          if (isNot !== (v1 === v2)) {\n            stop == null ? void 0 : stop();\n            resolve(v1);\n          }\n        },\n        {\n          flush,\n          deep,\n          immediate: true\n        }\n      );\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(\n        promiseTimeout(timeout, throwOnTimeout).then(() => toValue(r)).finally(() => {\n          stop == null ? void 0 : stop();\n          return toValue(r);\n        })\n      );\n    }\n    return Promise.race(promises);\n  }\n  function toBeTruthy(options) {\n    return toMatch((v) => Boolean(v), options);\n  }\n  function toBeNull(options) {\n    return toBe(null, options);\n  }\n  function toBeUndefined(options) {\n    return toBe(void 0, options);\n  }\n  function toBeNaN(options) {\n    return toMatch(Number.isNaN, options);\n  }\n  function toContains(value, options) {\n    return toMatch((v) => {\n      const array = Array.from(v);\n      return array.includes(value) || array.includes(toValue(value));\n    }, options);\n  }\n  function changed(options) {\n    return changedTimes(1, options);\n  }\n  function changedTimes(n = 1, options) {\n    let count = -1;\n    return toMatch(() => {\n      count += 1;\n      return count >= n;\n    }, options);\n  }\n  if (Array.isArray(toValue(r))) {\n    const instance = {\n      toMatch,\n      toContains,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  } else {\n    const instance = {\n      toMatch,\n      toBe,\n      toBeTruthy,\n      toBeNull,\n      toBeNaN,\n      toBeUndefined,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  }\n}\nfunction until(r) {\n  return createUntil(r);\n}\n\nfunction defaultComparator(value, othVal) {\n  return value === othVal;\n}\nfunction useArrayDifference(...args) {\n  var _a;\n  const list = args[0];\n  const values = args[1];\n  let compareFn = (_a = args[2]) != null ? _a : defaultComparator;\n  if (typeof compareFn === \"string\") {\n    const key = compareFn;\n    compareFn = (value, othVal) => value[key] === othVal[key];\n  }\n  return computed(() => toValue(list).filter((x) => toValue(values).findIndex((y) => compareFn(x, y)) === -1));\n}\n\nfunction useArrayEvery(list, fn) {\n  return computed(() => toValue(list).every((element, index, array) => fn(toValue(element), index, array)));\n}\n\nfunction useArrayFilter(list, fn) {\n  return computed(() => toValue(list).map((i) => toValue(i)).filter(fn));\n}\n\nfunction useArrayFind(list, fn) {\n  return computed(\n    () => toValue(\n      toValue(list).find((element, index, array) => fn(toValue(element), index, array))\n    )\n  );\n}\n\nfunction useArrayFindIndex(list, fn) {\n  return computed(() => toValue(list).findIndex((element, index, array) => fn(toValue(element), index, array)));\n}\n\nfunction findLast(arr, cb) {\n  let index = arr.length;\n  while (index-- > 0) {\n    if (cb(arr[index], index, arr))\n      return arr[index];\n  }\n  return void 0;\n}\nfunction useArrayFindLast(list, fn) {\n  return computed(\n    () => toValue(\n      !Array.prototype.findLast ? findLast(toValue(list), (element, index, array) => fn(toValue(element), index, array)) : toValue(list).findLast((element, index, array) => fn(toValue(element), index, array))\n    )\n  );\n}\n\nfunction isArrayIncludesOptions(obj) {\n  return isObject(obj) && containsProp(obj, \"formIndex\", \"comparator\");\n}\nfunction useArrayIncludes(...args) {\n  var _a;\n  const list = args[0];\n  const value = args[1];\n  let comparator = args[2];\n  let formIndex = 0;\n  if (isArrayIncludesOptions(comparator)) {\n    formIndex = (_a = comparator.fromIndex) != null ? _a : 0;\n    comparator = comparator.comparator;\n  }\n  if (typeof comparator === \"string\") {\n    const key = comparator;\n    comparator = (element, value2) => element[key] === toValue(value2);\n  }\n  comparator = comparator != null ? comparator : (element, value2) => element === toValue(value2);\n  return computed(\n    () => toValue(list).slice(formIndex).some(\n      (element, index, array) => comparator(toValue(element), toValue(value), index, toValue(array))\n    )\n  );\n}\n\nfunction useArrayJoin(list, separator) {\n  return computed(() => toValue(list).map((i) => toValue(i)).join(toValue(separator)));\n}\n\nfunction useArrayMap(list, fn) {\n  return computed(() => toValue(list).map((i) => toValue(i)).map(fn));\n}\n\nfunction useArrayReduce(list, reducer, ...args) {\n  const reduceCallback = (sum, value, index) => reducer(toValue(sum), toValue(value), index);\n  return computed(() => {\n    const resolved = toValue(list);\n    return args.length ? resolved.reduce(reduceCallback, toValue(args[0])) : resolved.reduce(reduceCallback);\n  });\n}\n\nfunction useArraySome(list, fn) {\n  return computed(() => toValue(list).some((element, index, array) => fn(toValue(element), index, array)));\n}\n\nfunction uniq(array) {\n  return Array.from(new Set(array));\n}\nfunction uniqueElementsBy(array, fn) {\n  return array.reduce((acc, v) => {\n    if (!acc.some((x) => fn(v, x, array)))\n      acc.push(v);\n    return acc;\n  }, []);\n}\nfunction useArrayUnique(list, compareFn) {\n  return computed(() => {\n    const resolvedList = toValue(list).map((element) => toValue(element));\n    return compareFn ? uniqueElementsBy(resolvedList, compareFn) : uniq(resolvedList);\n  });\n}\n\nfunction useCounter(initialValue = 0, options = {}) {\n  const count = ref(initialValue);\n  const {\n    max = Infinity,\n    min = -Infinity\n  } = options;\n  const inc = (delta = 1) => count.value = Math.min(max, count.value + delta);\n  const dec = (delta = 1) => count.value = Math.max(min, count.value - delta);\n  const get = () => count.value;\n  const set = (val) => count.value = Math.max(min, Math.min(max, val));\n  const reset = (val = initialValue) => {\n    initialValue = val;\n    return set(val);\n  };\n  return { count, inc, dec, get, set, reset };\n}\n\nconst REGEX_PARSE = /^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[Tt\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/;\nconst REGEX_FORMAT = /\\[([^\\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|SSS/g;\nfunction defaultMeridiem(hours, minutes, isLowercase, hasPeriod) {\n  let m = hours < 12 ? \"AM\" : \"PM\";\n  if (hasPeriod)\n    m = m.split(\"\").reduce((acc, curr) => acc += `${curr}.`, \"\");\n  return isLowercase ? m.toLowerCase() : m;\n}\nfunction formatDate(date, formatStr, options = {}) {\n  var _a;\n  const years = date.getFullYear();\n  const month = date.getMonth();\n  const days = date.getDate();\n  const hours = date.getHours();\n  const minutes = date.getMinutes();\n  const seconds = date.getSeconds();\n  const milliseconds = date.getMilliseconds();\n  const day = date.getDay();\n  const meridiem = (_a = options.customMeridiem) != null ? _a : defaultMeridiem;\n  const matches = {\n    YY: () => String(years).slice(-2),\n    YYYY: () => years,\n    M: () => month + 1,\n    MM: () => `${month + 1}`.padStart(2, \"0\"),\n    MMM: () => date.toLocaleDateString(options.locales, { month: \"short\" }),\n    MMMM: () => date.toLocaleDateString(options.locales, { month: \"long\" }),\n    D: () => String(days),\n    DD: () => `${days}`.padStart(2, \"0\"),\n    H: () => String(hours),\n    HH: () => `${hours}`.padStart(2, \"0\"),\n    h: () => `${hours % 12 || 12}`.padStart(1, \"0\"),\n    hh: () => `${hours % 12 || 12}`.padStart(2, \"0\"),\n    m: () => String(minutes),\n    mm: () => `${minutes}`.padStart(2, \"0\"),\n    s: () => String(seconds),\n    ss: () => `${seconds}`.padStart(2, \"0\"),\n    SSS: () => `${milliseconds}`.padStart(3, \"0\"),\n    d: () => day,\n    dd: () => date.toLocaleDateString(options.locales, { weekday: \"narrow\" }),\n    ddd: () => date.toLocaleDateString(options.locales, { weekday: \"short\" }),\n    dddd: () => date.toLocaleDateString(options.locales, { weekday: \"long\" }),\n    A: () => meridiem(hours, minutes),\n    AA: () => meridiem(hours, minutes, false, true),\n    a: () => meridiem(hours, minutes, true),\n    aa: () => meridiem(hours, minutes, true, true)\n  };\n  return formatStr.replace(REGEX_FORMAT, (match, $1) => {\n    var _a2;\n    return $1 || ((_a2 = matches[match]) == null ? void 0 : _a2.call(matches)) || match;\n  });\n}\nfunction normalizeDate(date) {\n  if (date === null)\n    return /* @__PURE__ */ new Date(NaN);\n  if (date === void 0)\n    return /* @__PURE__ */ new Date();\n  if (date instanceof Date)\n    return new Date(date);\n  if (typeof date === \"string\" && !/Z$/i.test(date)) {\n    const d = date.match(REGEX_PARSE);\n    if (d) {\n      const m = d[2] - 1 || 0;\n      const ms = (d[7] || \"0\").substring(0, 3);\n      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);\n    }\n  }\n  return new Date(date);\n}\nfunction useDateFormat(date, formatStr = \"HH:mm:ss\", options = {}) {\n  return computed(() => formatDate(normalizeDate(toValue(date)), toValue(formatStr), options));\n}\n\nfunction useIntervalFn(cb, interval = 1e3, options = {}) {\n  const {\n    immediate = true,\n    immediateCallback = false\n  } = options;\n  let timer = null;\n  const isActive = ref(false);\n  function clean() {\n    if (timer) {\n      clearInterval(timer);\n      timer = null;\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    clean();\n  }\n  function resume() {\n    const intervalValue = toValue(interval);\n    if (intervalValue <= 0)\n      return;\n    isActive.value = true;\n    if (immediateCallback)\n      cb();\n    clean();\n    timer = setInterval(cb, intervalValue);\n  }\n  if (immediate && isClient)\n    resume();\n  if (isRef(interval) || typeof interval === \"function\") {\n    const stopWatch = watch(interval, () => {\n      if (isActive.value && isClient)\n        resume();\n    });\n    tryOnScopeDispose(stopWatch);\n  }\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nvar __defProp$8 = Object.defineProperty;\nvar __getOwnPropSymbols$a = Object.getOwnPropertySymbols;\nvar __hasOwnProp$a = Object.prototype.hasOwnProperty;\nvar __propIsEnum$a = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$8 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$a.call(b, prop))\n      __defNormalProp$8(a, prop, b[prop]);\n  if (__getOwnPropSymbols$a)\n    for (var prop of __getOwnPropSymbols$a(b)) {\n      if (__propIsEnum$a.call(b, prop))\n        __defNormalProp$8(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useInterval(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    immediate = true,\n    callback\n  } = options;\n  const counter = ref(0);\n  const update = () => counter.value += 1;\n  const reset = () => {\n    counter.value = 0;\n  };\n  const controls = useIntervalFn(\n    callback ? () => {\n      update();\n      callback(counter.value);\n    } : update,\n    interval,\n    { immediate }\n  );\n  if (exposeControls) {\n    return __spreadValues$8({\n      counter,\n      reset\n    }, controls);\n  } else {\n    return counter;\n  }\n}\n\nfunction useLastChanged(source, options = {}) {\n  var _a;\n  const ms = ref((_a = options.initialValue) != null ? _a : null);\n  watch(\n    source,\n    () => ms.value = timestamp(),\n    options\n  );\n  return ms;\n}\n\nfunction useTimeoutFn(cb, interval, options = {}) {\n  const {\n    immediate = true\n  } = options;\n  const isPending = ref(false);\n  let timer = null;\n  function clear() {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n  }\n  function stop() {\n    isPending.value = false;\n    clear();\n  }\n  function start(...args) {\n    clear();\n    isPending.value = true;\n    timer = setTimeout(() => {\n      isPending.value = false;\n      timer = null;\n      cb(...args);\n    }, toValue(interval));\n  }\n  if (immediate) {\n    isPending.value = true;\n    if (isClient)\n      start();\n  }\n  tryOnScopeDispose(stop);\n  return {\n    isPending: readonly(isPending),\n    start,\n    stop\n  };\n}\n\nvar __defProp$7 = Object.defineProperty;\nvar __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$9 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$9 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$7 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$9.call(b, prop))\n      __defNormalProp$7(a, prop, b[prop]);\n  if (__getOwnPropSymbols$9)\n    for (var prop of __getOwnPropSymbols$9(b)) {\n      if (__propIsEnum$9.call(b, prop))\n        __defNormalProp$7(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useTimeout(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    callback\n  } = options;\n  const controls = useTimeoutFn(\n    callback != null ? callback : noop,\n    interval,\n    options\n  );\n  const ready = computed(() => !controls.isPending.value);\n  if (exposeControls) {\n    return __spreadValues$7({\n      ready\n    }, controls);\n  } else {\n    return ready;\n  }\n}\n\nfunction useToNumber(value, options = {}) {\n  const {\n    method = \"parseFloat\",\n    radix,\n    nanToZero\n  } = options;\n  return computed(() => {\n    let resolved = toValue(value);\n    if (typeof resolved === \"string\")\n      resolved = Number[method](resolved, radix);\n    if (nanToZero && Number.isNaN(resolved))\n      resolved = 0;\n    return resolved;\n  });\n}\n\nfunction useToString(value) {\n  return computed(() => `${toValue(value)}`);\n}\n\nfunction useToggle(initialValue = false, options = {}) {\n  const {\n    truthyValue = true,\n    falsyValue = false\n  } = options;\n  const valueIsRef = isRef(initialValue);\n  const _value = ref(initialValue);\n  function toggle(value) {\n    if (arguments.length) {\n      _value.value = value;\n      return _value.value;\n    } else {\n      const truthy = toValue(truthyValue);\n      _value.value = _value.value === truthy ? toValue(falsyValue) : truthy;\n      return _value.value;\n    }\n  }\n  if (valueIsRef)\n    return toggle;\n  else\n    return [_value, toggle];\n}\n\nfunction watchArray(source, cb, options) {\n  let oldList = (options == null ? void 0 : options.immediate) ? [] : [\n    ...source instanceof Function ? source() : Array.isArray(source) ? source : toValue(source)\n  ];\n  return watch(source, (newList, _, onCleanup) => {\n    const oldListRemains = new Array(oldList.length);\n    const added = [];\n    for (const obj of newList) {\n      let found = false;\n      for (let i = 0; i < oldList.length; i++) {\n        if (!oldListRemains[i] && obj === oldList[i]) {\n          oldListRemains[i] = true;\n          found = true;\n          break;\n        }\n      }\n      if (!found)\n        added.push(obj);\n    }\n    const removed = oldList.filter((_2, i) => !oldListRemains[i]);\n    cb(newList, oldList, added, removed, onCleanup);\n    oldList = [...newList];\n  }, options);\n}\n\nvar __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$8 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$8 = Object.prototype.propertyIsEnumerable;\nvar __objRest$5 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$8.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$8)\n    for (var prop of __getOwnPropSymbols$8(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$8.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchWithFilter(source, cb, options = {}) {\n  const _a = options, {\n    eventFilter = bypassFilter\n  } = _a, watchOptions = __objRest$5(_a, [\n    \"eventFilter\"\n  ]);\n  return watch(\n    source,\n    createFilterWrapper(\n      eventFilter,\n      cb\n    ),\n    watchOptions\n  );\n}\n\nvar __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$7 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$7 = Object.prototype.propertyIsEnumerable;\nvar __objRest$4 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$7.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$7)\n    for (var prop of __getOwnPropSymbols$7(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$7.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchAtMost(source, cb, options) {\n  const _a = options, {\n    count\n  } = _a, watchOptions = __objRest$4(_a, [\n    \"count\"\n  ]);\n  const current = ref(0);\n  const stop = watchWithFilter(\n    source,\n    (...args) => {\n      current.value += 1;\n      if (current.value >= toValue(count))\n        nextTick(() => stop());\n      cb(...args);\n    },\n    watchOptions\n  );\n  return { count: current, stop };\n}\n\nvar __defProp$6 = Object.defineProperty;\nvar __defProps$6 = Object.defineProperties;\nvar __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$6 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$6 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$6 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$6.call(b, prop))\n      __defNormalProp$6(a, prop, b[prop]);\n  if (__getOwnPropSymbols$6)\n    for (var prop of __getOwnPropSymbols$6(b)) {\n      if (__propIsEnum$6.call(b, prop))\n        __defNormalProp$6(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));\nvar __objRest$3 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$6.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$6)\n    for (var prop of __getOwnPropSymbols$6(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$6.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchDebounced(source, cb, options = {}) {\n  const _a = options, {\n    debounce = 0,\n    maxWait = void 0\n  } = _a, watchOptions = __objRest$3(_a, [\n    \"debounce\",\n    \"maxWait\"\n  ]);\n  return watchWithFilter(\n    source,\n    cb,\n    __spreadProps$6(__spreadValues$6({}, watchOptions), {\n      eventFilter: debounceFilter(debounce, { maxWait })\n    })\n  );\n}\n\nvar __defProp$5 = Object.defineProperty;\nvar __defProps$5 = Object.defineProperties;\nvar __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$5 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$5 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$5 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$5.call(b, prop))\n      __defNormalProp$5(a, prop, b[prop]);\n  if (__getOwnPropSymbols$5)\n    for (var prop of __getOwnPropSymbols$5(b)) {\n      if (__propIsEnum$5.call(b, prop))\n        __defNormalProp$5(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));\nfunction watchDeep(source, cb, options) {\n  return watch(\n    source,\n    cb,\n    __spreadProps$5(__spreadValues$5({}, options), {\n      deep: true\n    })\n  );\n}\n\nvar __defProp$4 = Object.defineProperty;\nvar __defProps$4 = Object.defineProperties;\nvar __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$4 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$4 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$4 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$4.call(b, prop))\n      __defNormalProp$4(a, prop, b[prop]);\n  if (__getOwnPropSymbols$4)\n    for (var prop of __getOwnPropSymbols$4(b)) {\n      if (__propIsEnum$4.call(b, prop))\n        __defNormalProp$4(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));\nvar __objRest$2 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$4.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$4)\n    for (var prop of __getOwnPropSymbols$4(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$4.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchIgnorable(source, cb, options = {}) {\n  const _a = options, {\n    eventFilter = bypassFilter\n  } = _a, watchOptions = __objRest$2(_a, [\n    \"eventFilter\"\n  ]);\n  const filteredCb = createFilterWrapper(\n    eventFilter,\n    cb\n  );\n  let ignoreUpdates;\n  let ignorePrevAsyncUpdates;\n  let stop;\n  if (watchOptions.flush === \"sync\") {\n    const ignore = ref(false);\n    ignorePrevAsyncUpdates = () => {\n    };\n    ignoreUpdates = (updater) => {\n      ignore.value = true;\n      updater();\n      ignore.value = false;\n    };\n    stop = watch(\n      source,\n      (...args) => {\n        if (!ignore.value)\n          filteredCb(...args);\n      },\n      watchOptions\n    );\n  } else {\n    const disposables = [];\n    const ignoreCounter = ref(0);\n    const syncCounter = ref(0);\n    ignorePrevAsyncUpdates = () => {\n      ignoreCounter.value = syncCounter.value;\n    };\n    disposables.push(\n      watch(\n        source,\n        () => {\n          syncCounter.value++;\n        },\n        __spreadProps$4(__spreadValues$4({}, watchOptions), { flush: \"sync\" })\n      )\n    );\n    ignoreUpdates = (updater) => {\n      const syncCounterPrev = syncCounter.value;\n      updater();\n      ignoreCounter.value += syncCounter.value - syncCounterPrev;\n    };\n    disposables.push(\n      watch(\n        source,\n        (...args) => {\n          const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;\n          ignoreCounter.value = 0;\n          syncCounter.value = 0;\n          if (ignore)\n            return;\n          filteredCb(...args);\n        },\n        watchOptions\n      )\n    );\n    stop = () => {\n      disposables.forEach((fn) => fn());\n    };\n  }\n  return { stop, ignoreUpdates, ignorePrevAsyncUpdates };\n}\n\nvar __defProp$3 = Object.defineProperty;\nvar __defProps$3 = Object.defineProperties;\nvar __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$3 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$3 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$3 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$3.call(b, prop))\n      __defNormalProp$3(a, prop, b[prop]);\n  if (__getOwnPropSymbols$3)\n    for (var prop of __getOwnPropSymbols$3(b)) {\n      if (__propIsEnum$3.call(b, prop))\n        __defNormalProp$3(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));\nfunction watchImmediate(source, cb, options) {\n  return watch(\n    source,\n    cb,\n    __spreadProps$3(__spreadValues$3({}, options), {\n      immediate: true\n    })\n  );\n}\n\nfunction watchOnce(source, cb, options) {\n  const stop = watch(source, (...args) => {\n    nextTick(() => stop());\n    return cb(...args);\n  }, options);\n}\n\nvar __defProp$2 = Object.defineProperty;\nvar __defProps$2 = Object.defineProperties;\nvar __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$2 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$2 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$2.call(b, prop))\n      __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(b)) {\n      if (__propIsEnum$2.call(b, prop))\n        __defNormalProp$2(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));\nvar __objRest$1 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$2.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$2.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchPausable(source, cb, options = {}) {\n  const _a = options, {\n    eventFilter: filter\n  } = _a, watchOptions = __objRest$1(_a, [\n    \"eventFilter\"\n  ]);\n  const { eventFilter, pause, resume, isActive } = pausableFilter(filter);\n  const stop = watchWithFilter(\n    source,\n    cb,\n    __spreadProps$2(__spreadValues$2({}, watchOptions), {\n      eventFilter\n    })\n  );\n  return { stop, pause, resume, isActive };\n}\n\nvar __defProp$1 = Object.defineProperty;\nvar __defProps$1 = Object.defineProperties;\nvar __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$1.call(b, prop))\n      __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(b)) {\n      if (__propIsEnum$1.call(b, prop))\n        __defNormalProp$1(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchThrottled(source, cb, options = {}) {\n  const _a = options, {\n    throttle = 0,\n    trailing = true,\n    leading = true\n  } = _a, watchOptions = __objRest(_a, [\n    \"throttle\",\n    \"trailing\",\n    \"leading\"\n  ]);\n  return watchWithFilter(\n    source,\n    cb,\n    __spreadProps$1(__spreadValues$1({}, watchOptions), {\n      eventFilter: throttleFilter(throttle, trailing, leading)\n    })\n  );\n}\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nfunction watchTriggerable(source, cb, options = {}) {\n  let cleanupFn;\n  function onEffect() {\n    if (!cleanupFn)\n      return;\n    const fn = cleanupFn;\n    cleanupFn = void 0;\n    fn();\n  }\n  function onCleanup(callback) {\n    cleanupFn = callback;\n  }\n  const _cb = (value, oldValue) => {\n    onEffect();\n    return cb(value, oldValue, onCleanup);\n  };\n  const res = watchIgnorable(source, _cb, options);\n  const { ignoreUpdates } = res;\n  const trigger = () => {\n    let res2;\n    ignoreUpdates(() => {\n      res2 = _cb(getWatchSources(source), getOldValue(source));\n    });\n    return res2;\n  };\n  return __spreadProps(__spreadValues({}, res), {\n    trigger\n  });\n}\nfunction getWatchSources(sources) {\n  if (isReactive(sources))\n    return sources;\n  if (Array.isArray(sources))\n    return sources.map((item) => toValue(item));\n  return toValue(sources);\n}\nfunction getOldValue(source) {\n  return Array.isArray(source) ? source.map(() => void 0) : void 0;\n}\n\nfunction whenever(source, cb, options) {\n  return watch(\n    source,\n    (v, ov, onInvalidate) => {\n      if (v)\n        cb(v, ov, onInvalidate);\n    },\n    options\n  );\n}\n\nexport { assert, refAutoReset as autoResetRef, bypassFilter, clamp, computedEager, computedWithControl, containsProp, computedWithControl as controlledComputed, controlledRef, createEventHook, createFilterWrapper, createGlobalState, createInjectionState, reactify as createReactiveFn, createSharedComposable, createSingletonPromise, debounceFilter, refDebounced as debouncedRef, watchDebounced as debouncedWatch, directiveHooks, computedEager as eagerComputed, extendRef, formatDate, get, hasOwn, identity, watchIgnorable as ignorableWatch, increaseWithUnit, invoke, isClient, isDef, isDefined, isIOS, isObject, makeDestructurable, noop, normalizeDate, notNullish, now, objectEntries, objectOmit, objectPick, pausableFilter, watchPausable as pausableWatch, promiseTimeout, rand, reactify, reactifyObject, reactiveComputed, reactiveOmit, reactivePick, refAutoReset, refDebounced, refDefault, refThrottled, refWithControl, resolveRef, resolveUnref, set, syncRef, syncRefs, throttleFilter, refThrottled as throttledRef, watchThrottled as throttledWatch, timestamp, toReactive, toRef, toRefs, toValue, tryOnBeforeMount, tryOnBeforeUnmount, tryOnMounted, tryOnScopeDispose, tryOnUnmounted, until, useArrayDifference, useArrayEvery, useArrayFilter, useArrayFind, useArrayFindIndex, useArrayFindLast, useArrayIncludes, useArrayJoin, useArrayMap, useArrayReduce, useArraySome, useArrayUnique, useCounter, useDateFormat, refDebounced as useDebounce, useDebounceFn, useInterval, useIntervalFn, useLastChanged, refThrottled as useThrottle, useThrottleFn, useTimeout, useTimeoutFn, useToNumber, useToString, useToggle, watchArray, watchAtMost, watchDebounced, watchDeep, watchIgnorable, watchImmediate, watchOnce, watchPausable, watchThrottled, watchTriggerable, watchWithFilter, whenever };\n","import { noop, makeDestructurable, toValue, isClient, tryOnScopeDispose, isIOS, tryOnMounted, computedWithControl, isObject, objectOmit, promiseTimeout, until, toRef, increaseWithUnit, objectEntries, useTimeoutFn, pausableWatch, createEventHook, timestamp, pausableFilter, watchIgnorable, debounceFilter, createFilterWrapper, bypassFilter, createSingletonPromise, toRefs, useIntervalFn, notNullish, containsProp, hasOwn, throttleFilter, useDebounceFn, useThrottleFn, clamp, syncRef, objectPick, tryOnUnmounted, watchWithFilter, identity, isDef } from '@vueuse/shared';\nexport * from '@vueuse/shared';\nimport { isRef, ref, shallowRef, watchEffect, computed, inject, isVue3, version, defineComponent, h, TransitionGroup, shallowReactive, Fragment, watch, getCurrentInstance, customRef, onUpdated, onMounted, readonly, nextTick, reactive, markRaw, getCurrentScope, isVue2, set, del, isReadonly, onBeforeUpdate } from 'vue-demi';\n\nfunction computedAsync(evaluationCallback, initialState, optionsOrRef) {\n  let options;\n  if (isRef(optionsOrRef)) {\n    options = {\n      evaluating: optionsOrRef\n    };\n  } else {\n    options = optionsOrRef || {};\n  }\n  const {\n    lazy = false,\n    evaluating = void 0,\n    shallow = true,\n    onError = noop\n  } = options;\n  const started = ref(!lazy);\n  const current = shallow ? shallowRef(initialState) : ref(initialState);\n  let counter = 0;\n  watchEffect(async (onInvalidate) => {\n    if (!started.value)\n      return;\n    counter++;\n    const counterAtBeginning = counter;\n    let hasFinished = false;\n    if (evaluating) {\n      Promise.resolve().then(() => {\n        evaluating.value = true;\n      });\n    }\n    try {\n      const result = await evaluationCallback((cancelCallback) => {\n        onInvalidate(() => {\n          if (evaluating)\n            evaluating.value = false;\n          if (!hasFinished)\n            cancelCallback();\n        });\n      });\n      if (counterAtBeginning === counter)\n        current.value = result;\n    } catch (e) {\n      onError(e);\n    } finally {\n      if (evaluating && counterAtBeginning === counter)\n        evaluating.value = false;\n      hasFinished = true;\n    }\n  });\n  if (lazy) {\n    return computed(() => {\n      started.value = true;\n      return current.value;\n    });\n  } else {\n    return current;\n  }\n}\n\nfunction computedInject(key, options, defaultSource, treatDefaultAsFactory) {\n  let source = inject(key);\n  if (defaultSource)\n    source = inject(key, defaultSource);\n  if (treatDefaultAsFactory)\n    source = inject(key, defaultSource, treatDefaultAsFactory);\n  if (typeof options === \"function\") {\n    return computed((ctx) => options(source, ctx));\n  } else {\n    return computed({\n      get: (ctx) => options.get(source, ctx),\n      set: options.set\n    });\n  }\n}\n\nvar __defProp$q = Object.defineProperty;\nvar __defProps$d = Object.defineProperties;\nvar __getOwnPropDescs$d = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$t = Object.getOwnPropertySymbols;\nvar __hasOwnProp$t = Object.prototype.hasOwnProperty;\nvar __propIsEnum$t = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$q = (obj, key, value) => key in obj ? __defProp$q(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$q = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$t.call(b, prop))\n      __defNormalProp$q(a, prop, b[prop]);\n  if (__getOwnPropSymbols$t)\n    for (var prop of __getOwnPropSymbols$t(b)) {\n      if (__propIsEnum$t.call(b, prop))\n        __defNormalProp$q(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$d = (a, b) => __defProps$d(a, __getOwnPropDescs$d(b));\nfunction createReusableTemplate() {\n  if (!isVue3 && !version.startsWith(\"2.7.\")) {\n    if (process.env.NODE_ENV !== \"production\")\n      throw new Error(\"[VueUse] createReusableTemplate only works in Vue 2.7 or above.\");\n    return;\n  }\n  const render = shallowRef();\n  const define = /* #__PURE__ */ defineComponent({\n    setup(_, { slots }) {\n      return () => {\n        render.value = slots.default;\n      };\n    }\n  });\n  const reuse = /* #__PURE__ */ defineComponent({\n    inheritAttrs: false,\n    setup(_, { attrs, slots }) {\n      return () => {\n        var _a;\n        if (!render.value && process.env.NODE_ENV !== \"production\")\n          throw new Error(\"[VueUse] Failed to find the definition of reusable template\");\n        return (_a = render.value) == null ? void 0 : _a.call(render, __spreadProps$d(__spreadValues$q({}, attrs), { $slots: slots }));\n      };\n    }\n  });\n  return makeDestructurable(\n    { define, reuse },\n    [define, reuse]\n  );\n}\n\nfunction createTemplatePromise(options = {}) {\n  if (!isVue3) {\n    if (process.env.NODE_ENV !== \"production\")\n      throw new Error(\"[VueUse] createTemplatePromise only works in Vue 3 or above.\");\n    return;\n  }\n  let index = 0;\n  const instances = ref([]);\n  function create(...args) {\n    const props = shallowReactive({\n      key: index++,\n      args,\n      promise: void 0,\n      resolve: () => {\n      },\n      reject: () => {\n      },\n      isResolving: false,\n      options\n    });\n    instances.value.push(props);\n    props.promise = new Promise((_resolve, _reject) => {\n      props.resolve = (v) => {\n        props.isResolving = true;\n        return _resolve(v);\n      };\n      props.reject = _reject;\n    }).finally(() => {\n      props.promise = void 0;\n      const index2 = instances.value.indexOf(props);\n      if (index2 !== -1)\n        instances.value.splice(index2, 1);\n    });\n    return props.promise;\n  }\n  function start(...args) {\n    if (options.singleton && instances.value.length > 0)\n      return instances.value[0].promise;\n    return create(...args);\n  }\n  const component = /* #__PURE__ */ defineComponent((_, { slots }) => {\n    const renderList = () => instances.value.map((props) => {\n      var _a;\n      return h(Fragment, { key: props.key }, (_a = slots.default) == null ? void 0 : _a.call(slots, props));\n    });\n    if (options.transition)\n      return () => h(TransitionGroup, options.transition, renderList);\n    return renderList;\n  });\n  component.start = start;\n  return component;\n}\n\nfunction createUnrefFn(fn) {\n  return function(...args) {\n    return fn.apply(this, args.map((i) => toValue(i)));\n  };\n}\n\nfunction unrefElement(elRef) {\n  var _a;\n  const plain = toValue(elRef);\n  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;\n}\n\nconst defaultWindow = isClient ? window : void 0;\nconst defaultDocument = isClient ? window.document : void 0;\nconst defaultNavigator = isClient ? window.navigator : void 0;\nconst defaultLocation = isClient ? window.location : void 0;\n\nfunction useEventListener(...args) {\n  let target;\n  let events;\n  let listeners;\n  let options;\n  if (typeof args[0] === \"string\" || Array.isArray(args[0])) {\n    [events, listeners, options] = args;\n    target = defaultWindow;\n  } else {\n    [target, events, listeners, options] = args;\n  }\n  if (!target)\n    return noop;\n  if (!Array.isArray(events))\n    events = [events];\n  if (!Array.isArray(listeners))\n    listeners = [listeners];\n  const cleanups = [];\n  const cleanup = () => {\n    cleanups.forEach((fn) => fn());\n    cleanups.length = 0;\n  };\n  const register = (el, event, listener, options2) => {\n    el.addEventListener(event, listener, options2);\n    return () => el.removeEventListener(event, listener, options2);\n  };\n  const stopWatch = watch(\n    () => [unrefElement(target), toValue(options)],\n    ([el, options2]) => {\n      cleanup();\n      if (!el)\n        return;\n      cleanups.push(\n        ...events.flatMap((event) => {\n          return listeners.map((listener) => register(el, event, listener, options2));\n        })\n      );\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  const stop = () => {\n    stopWatch();\n    cleanup();\n  };\n  tryOnScopeDispose(stop);\n  return stop;\n}\n\nlet _iOSWorkaround = false;\nfunction onClickOutside(target, handler, options = {}) {\n  const { window = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;\n  if (!window)\n    return;\n  if (isIOS && !_iOSWorkaround) {\n    _iOSWorkaround = true;\n    Array.from(window.document.body.children).forEach((el) => el.addEventListener(\"click\", noop));\n  }\n  let shouldListen = true;\n  const shouldIgnore = (event) => {\n    return ignore.some((target2) => {\n      if (typeof target2 === \"string\") {\n        return Array.from(window.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));\n      } else {\n        const el = unrefElement(target2);\n        return el && (event.target === el || event.composedPath().includes(el));\n      }\n    });\n  };\n  const listener = (event) => {\n    const el = unrefElement(target);\n    if (!el || el === event.target || event.composedPath().includes(el))\n      return;\n    if (event.detail === 0)\n      shouldListen = !shouldIgnore(event);\n    if (!shouldListen) {\n      shouldListen = true;\n      return;\n    }\n    handler(event);\n  };\n  const cleanup = [\n    useEventListener(window, \"click\", listener, { passive: true, capture }),\n    useEventListener(window, \"pointerdown\", (e) => {\n      const el = unrefElement(target);\n      if (el)\n        shouldListen = !e.composedPath().includes(el) && !shouldIgnore(e);\n    }, { passive: true }),\n    detectIframe && useEventListener(window, \"blur\", (event) => {\n      setTimeout(() => {\n        var _a;\n        const el = unrefElement(target);\n        if (((_a = window.document.activeElement) == null ? void 0 : _a.tagName) === \"IFRAME\" && !(el == null ? void 0 : el.contains(window.document.activeElement)))\n          handler(event);\n      }, 0);\n    })\n  ].filter(Boolean);\n  const stop = () => cleanup.forEach((fn) => fn());\n  return stop;\n}\n\nvar __defProp$p = Object.defineProperty;\nvar __defProps$c = Object.defineProperties;\nvar __getOwnPropDescs$c = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$s = Object.getOwnPropertySymbols;\nvar __hasOwnProp$s = Object.prototype.hasOwnProperty;\nvar __propIsEnum$s = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$p = (obj, key, value) => key in obj ? __defProp$p(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$p = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$s.call(b, prop))\n      __defNormalProp$p(a, prop, b[prop]);\n  if (__getOwnPropSymbols$s)\n    for (var prop of __getOwnPropSymbols$s(b)) {\n      if (__propIsEnum$s.call(b, prop))\n        __defNormalProp$p(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$c = (a, b) => __defProps$c(a, __getOwnPropDescs$c(b));\nfunction createKeyPredicate(keyFilter) {\n  if (typeof keyFilter === \"function\")\n    return keyFilter;\n  else if (typeof keyFilter === \"string\")\n    return (event) => event.key === keyFilter;\n  else if (Array.isArray(keyFilter))\n    return (event) => keyFilter.includes(event.key);\n  return () => true;\n}\nfunction onKeyStroke(...args) {\n  let key;\n  let handler;\n  let options = {};\n  if (args.length === 3) {\n    key = args[0];\n    handler = args[1];\n    options = args[2];\n  } else if (args.length === 2) {\n    if (typeof args[1] === \"object\") {\n      key = true;\n      handler = args[0];\n      options = args[1];\n    } else {\n      key = args[0];\n      handler = args[1];\n    }\n  } else {\n    key = true;\n    handler = args[0];\n  }\n  const {\n    target = defaultWindow,\n    eventName = \"keydown\",\n    passive = false,\n    dedupe = false\n  } = options;\n  const predicate = createKeyPredicate(key);\n  const listener = (e) => {\n    if (e.repeat && toValue(dedupe))\n      return;\n    if (predicate(e))\n      handler(e);\n  };\n  return useEventListener(target, eventName, listener, passive);\n}\nfunction onKeyDown(key, handler, options = {}) {\n  return onKeyStroke(key, handler, __spreadProps$c(__spreadValues$p({}, options), { eventName: \"keydown\" }));\n}\nfunction onKeyPressed(key, handler, options = {}) {\n  return onKeyStroke(key, handler, __spreadProps$c(__spreadValues$p({}, options), { eventName: \"keypress\" }));\n}\nfunction onKeyUp(key, handler, options = {}) {\n  return onKeyStroke(key, handler, __spreadProps$c(__spreadValues$p({}, options), { eventName: \"keyup\" }));\n}\n\nconst DEFAULT_DELAY = 500;\nfunction onLongPress(target, handler, options) {\n  var _a, _b;\n  const elementRef = computed(() => unrefElement(target));\n  let timeout;\n  function clear() {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = void 0;\n    }\n  }\n  function onDown(ev) {\n    var _a2, _b2, _c, _d;\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\n      return;\n    clear();\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\n      ev.preventDefault();\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\n      ev.stopPropagation();\n    timeout = setTimeout(\n      () => handler(ev),\n      (_d = options == null ? void 0 : options.delay) != null ? _d : DEFAULT_DELAY\n    );\n  }\n  const listenerOptions = {\n    capture: (_a = options == null ? void 0 : options.modifiers) == null ? void 0 : _a.capture,\n    once: (_b = options == null ? void 0 : options.modifiers) == null ? void 0 : _b.once\n  };\n  useEventListener(elementRef, \"pointerdown\", onDown, listenerOptions);\n  useEventListener(elementRef, \"pointerup\", clear, listenerOptions);\n  useEventListener(elementRef, \"pointerleave\", clear, listenerOptions);\n}\n\nfunction isFocusedElementEditable() {\n  const { activeElement, body } = document;\n  if (!activeElement)\n    return false;\n  if (activeElement === body)\n    return false;\n  switch (activeElement.tagName) {\n    case \"INPUT\":\n    case \"TEXTAREA\":\n      return true;\n  }\n  return activeElement.hasAttribute(\"contenteditable\");\n}\nfunction isTypedCharValid({\n  keyCode,\n  metaKey,\n  ctrlKey,\n  altKey\n}) {\n  if (metaKey || ctrlKey || altKey)\n    return false;\n  if (keyCode >= 48 && keyCode <= 57)\n    return true;\n  if (keyCode >= 65 && keyCode <= 90)\n    return true;\n  if (keyCode >= 97 && keyCode <= 122)\n    return true;\n  return false;\n}\nfunction onStartTyping(callback, options = {}) {\n  const { document: document2 = defaultDocument } = options;\n  const keydown = (event) => {\n    !isFocusedElementEditable() && isTypedCharValid(event) && callback(event);\n  };\n  if (document2)\n    useEventListener(document2, \"keydown\", keydown, { passive: true });\n}\n\nfunction templateRef(key, initialValue = null) {\n  const instance = getCurrentInstance();\n  let _trigger = () => {\n  };\n  const element = customRef((track, trigger) => {\n    _trigger = trigger;\n    return {\n      get() {\n        var _a, _b;\n        track();\n        return (_b = (_a = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a.$refs[key]) != null ? _b : initialValue;\n      },\n      set() {\n      }\n    };\n  });\n  tryOnMounted(_trigger);\n  onUpdated(_trigger);\n  return element;\n}\n\nfunction useActiveElement(options = {}) {\n  var _a;\n  const { window = defaultWindow } = options;\n  const document = (_a = options.document) != null ? _a : window == null ? void 0 : window.document;\n  const activeElement = computedWithControl(\n    () => null,\n    () => document == null ? void 0 : document.activeElement\n  );\n  if (window) {\n    useEventListener(window, \"blur\", (event) => {\n      if (event.relatedTarget !== null)\n        return;\n      activeElement.trigger();\n    }, true);\n    useEventListener(window, \"focus\", activeElement.trigger, true);\n  }\n  return activeElement;\n}\n\nfunction useMounted() {\n  const isMounted = ref(false);\n  if (getCurrentInstance()) {\n    onMounted(() => {\n      isMounted.value = true;\n    });\n  }\n  return isMounted;\n}\n\nfunction useSupported(callback) {\n  const isMounted = useMounted();\n  return computed(() => {\n    isMounted.value;\n    return Boolean(callback());\n  });\n}\n\nfunction useRafFn(fn, options = {}) {\n  const {\n    immediate = true,\n    window = defaultWindow\n  } = options;\n  const isActive = ref(false);\n  let previousFrameTimestamp = 0;\n  let rafId = null;\n  function loop(timestamp) {\n    if (!isActive.value || !window)\n      return;\n    const delta = timestamp - previousFrameTimestamp;\n    fn({ delta, timestamp });\n    previousFrameTimestamp = timestamp;\n    rafId = window.requestAnimationFrame(loop);\n  }\n  function resume() {\n    if (!isActive.value && window) {\n      isActive.value = true;\n      rafId = window.requestAnimationFrame(loop);\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    if (rafId != null && window) {\n      window.cancelAnimationFrame(rafId);\n      rafId = null;\n    }\n  }\n  if (immediate)\n    resume();\n  tryOnScopeDispose(pause);\n  return {\n    isActive: readonly(isActive),\n    pause,\n    resume\n  };\n}\n\nfunction useAnimate(target, keyframes, options) {\n  let config;\n  let animateOptions;\n  if (isObject(options)) {\n    config = options;\n    animateOptions = objectOmit(options, [\"window\", \"immediate\", \"commitStyles\", \"persist\", \"onReady\", \"onError\"]);\n  } else {\n    config = { duration: options };\n    animateOptions = options;\n  }\n  const {\n    window = defaultWindow,\n    immediate = true,\n    commitStyles,\n    persist,\n    playbackRate: _playbackRate = 1,\n    onReady,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = config;\n  const isSupported = useSupported(() => window && HTMLElement && \"animate\" in HTMLElement.prototype);\n  const animate = shallowRef(void 0);\n  const store = shallowReactive({\n    startTime: null,\n    currentTime: null,\n    timeline: null,\n    playbackRate: _playbackRate,\n    pending: false,\n    playState: immediate ? \"idle\" : \"paused\",\n    replaceState: \"active\"\n  });\n  const pending = computed(() => store.pending);\n  const playState = computed(() => store.playState);\n  const replaceState = computed(() => store.replaceState);\n  const startTime = computed({\n    get() {\n      return store.startTime;\n    },\n    set(value) {\n      store.startTime = value;\n      if (animate.value)\n        animate.value.startTime = value;\n    }\n  });\n  const currentTime = computed({\n    get() {\n      return store.currentTime;\n    },\n    set(value) {\n      store.currentTime = value;\n      if (animate.value) {\n        animate.value.currentTime = value;\n        syncResume();\n      }\n    }\n  });\n  const timeline = computed({\n    get() {\n      return store.timeline;\n    },\n    set(value) {\n      store.timeline = value;\n      if (animate.value)\n        animate.value.timeline = value;\n    }\n  });\n  const playbackRate = computed({\n    get() {\n      return store.playbackRate;\n    },\n    set(value) {\n      store.playbackRate = value;\n      if (animate.value)\n        animate.value.playbackRate = value;\n    }\n  });\n  const play = () => {\n    if (animate.value) {\n      try {\n        animate.value.play();\n        syncResume();\n      } catch (e) {\n        syncPause();\n        onError(e);\n      }\n    } else {\n      update();\n    }\n  };\n  const pause = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.pause();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  const reverse = () => {\n    var _a;\n    !animate.value && update();\n    try {\n      (_a = animate.value) == null ? void 0 : _a.reverse();\n      syncResume();\n    } catch (e) {\n      syncPause();\n      onError(e);\n    }\n  };\n  const finish = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.finish();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  const cancel = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.cancel();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  watch(() => unrefElement(target), (el) => {\n    el && update();\n  });\n  watch(() => keyframes, (value) => {\n    !animate.value && update();\n    if (!unrefElement(target) && animate.value) {\n      animate.value.effect = new KeyframeEffect(\n        unrefElement(target),\n        toValue(value),\n        animateOptions\n      );\n    }\n  }, { deep: true });\n  tryOnMounted(() => {\n    nextTick(() => update(true));\n  });\n  tryOnScopeDispose(cancel);\n  function update(init) {\n    const el = unrefElement(target);\n    if (!isSupported.value || !el)\n      return;\n    animate.value = el.animate(toValue(keyframes), animateOptions);\n    if (commitStyles)\n      animate.value.commitStyles();\n    if (persist)\n      animate.value.persist();\n    if (_playbackRate !== 1)\n      animate.value.playbackRate = _playbackRate;\n    if (init && !immediate)\n      animate.value.pause();\n    else\n      syncResume();\n    onReady == null ? void 0 : onReady(animate.value);\n  }\n  useEventListener(animate, \"cancel\", syncPause);\n  useEventListener(animate, \"finish\", syncPause);\n  useEventListener(animate, \"remove\", syncPause);\n  const { resume: resumeRef, pause: pauseRef } = useRafFn(() => {\n    if (!animate.value)\n      return;\n    store.pending = animate.value.pending;\n    store.playState = animate.value.playState;\n    store.replaceState = animate.value.replaceState;\n    store.startTime = animate.value.startTime;\n    store.currentTime = animate.value.currentTime;\n    store.timeline = animate.value.timeline;\n    store.playbackRate = animate.value.playbackRate;\n  }, { immediate: false });\n  function syncResume() {\n    if (isSupported.value)\n      resumeRef();\n  }\n  function syncPause() {\n    if (isSupported.value && window)\n      window.requestAnimationFrame(pauseRef);\n  }\n  return {\n    isSupported,\n    animate,\n    // actions\n    play,\n    pause,\n    reverse,\n    finish,\n    cancel,\n    // state\n    pending,\n    playState,\n    replaceState,\n    startTime,\n    currentTime,\n    timeline,\n    playbackRate\n  };\n}\n\nfunction useAsyncQueue(tasks, options = {}) {\n  const {\n    interrupt = true,\n    onError = noop,\n    onFinished = noop,\n    signal\n  } = options;\n  const promiseState = {\n    aborted: \"aborted\",\n    fulfilled: \"fulfilled\",\n    pending: \"pending\",\n    rejected: \"rejected\"\n  };\n  const initialResult = Array.from(new Array(tasks.length), () => ({ state: promiseState.pending, data: null }));\n  const result = reactive(initialResult);\n  const activeIndex = ref(-1);\n  if (!tasks || tasks.length === 0) {\n    onFinished();\n    return {\n      activeIndex,\n      result\n    };\n  }\n  function updateResult(state, res) {\n    activeIndex.value++;\n    result[activeIndex.value].data = res;\n    result[activeIndex.value].state = state;\n  }\n  tasks.reduce((prev, curr) => {\n    return prev.then((prevRes) => {\n      var _a;\n      if (signal == null ? void 0 : signal.aborted) {\n        updateResult(promiseState.aborted, new Error(\"aborted\"));\n        return;\n      }\n      if (((_a = result[activeIndex.value]) == null ? void 0 : _a.state) === promiseState.rejected && interrupt) {\n        onFinished();\n        return;\n      }\n      const done = curr(prevRes).then((currentRes) => {\n        updateResult(promiseState.fulfilled, currentRes);\n        activeIndex.value === tasks.length - 1 && onFinished();\n        return currentRes;\n      });\n      if (!signal)\n        return done;\n      return Promise.race([done, whenAborted(signal)]);\n    }).catch((e) => {\n      if (signal == null ? void 0 : signal.aborted) {\n        updateResult(promiseState.aborted, e);\n        return e;\n      }\n      updateResult(promiseState.rejected, e);\n      onError();\n      return e;\n    });\n  }, Promise.resolve());\n  return {\n    activeIndex,\n    result\n  };\n}\nfunction whenAborted(signal) {\n  return new Promise((resolve, reject) => {\n    const error = new Error(\"aborted\");\n    if (signal.aborted)\n      reject(error);\n    else\n      signal.addEventListener(\"abort\", () => reject(error), { once: true });\n  });\n}\n\nvar __defProp$o = Object.defineProperty;\nvar __defProps$b = Object.defineProperties;\nvar __getOwnPropDescs$b = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$r = Object.getOwnPropertySymbols;\nvar __hasOwnProp$r = Object.prototype.hasOwnProperty;\nvar __propIsEnum$r = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$o = (obj, key, value) => key in obj ? __defProp$o(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$o = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$r.call(b, prop))\n      __defNormalProp$o(a, prop, b[prop]);\n  if (__getOwnPropSymbols$r)\n    for (var prop of __getOwnPropSymbols$r(b)) {\n      if (__propIsEnum$r.call(b, prop))\n        __defNormalProp$o(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$b = (a, b) => __defProps$b(a, __getOwnPropDescs$b(b));\nfunction useAsyncState(promise, initialState, options) {\n  const {\n    immediate = true,\n    delay = 0,\n    onError = noop,\n    onSuccess = noop,\n    resetOnExecute = true,\n    shallow = true,\n    throwError\n  } = options != null ? options : {};\n  const state = shallow ? shallowRef(initialState) : ref(initialState);\n  const isReady = ref(false);\n  const isLoading = ref(false);\n  const error = shallowRef(void 0);\n  async function execute(delay2 = 0, ...args) {\n    if (resetOnExecute)\n      state.value = initialState;\n    error.value = void 0;\n    isReady.value = false;\n    isLoading.value = true;\n    if (delay2 > 0)\n      await promiseTimeout(delay2);\n    const _promise = typeof promise === \"function\" ? promise(...args) : promise;\n    try {\n      const data = await _promise;\n      state.value = data;\n      isReady.value = true;\n      onSuccess(data);\n    } catch (e) {\n      error.value = e;\n      onError(e);\n      if (throwError)\n        throw e;\n    } finally {\n      isLoading.value = false;\n    }\n    return state.value;\n  }\n  if (immediate)\n    execute(delay);\n  const shell = {\n    state,\n    isReady,\n    isLoading,\n    error,\n    execute\n  };\n  function waitUntilIsLoaded() {\n    return new Promise((resolve, reject) => {\n      until(isLoading).toBe(false).then(() => resolve(shell)).catch(reject);\n    });\n  }\n  return __spreadProps$b(__spreadValues$o({}, shell), {\n    then(onFulfilled, onRejected) {\n      return waitUntilIsLoaded().then(onFulfilled, onRejected);\n    }\n  });\n}\n\nconst defaults = {\n  array: (v) => JSON.stringify(v),\n  object: (v) => JSON.stringify(v),\n  set: (v) => JSON.stringify(Array.from(v)),\n  map: (v) => JSON.stringify(Object.fromEntries(v)),\n  null: () => \"\"\n};\nfunction getDefaultSerialization(target) {\n  if (!target)\n    return defaults.null;\n  if (target instanceof Map)\n    return defaults.map;\n  else if (target instanceof Set)\n    return defaults.set;\n  else if (Array.isArray(target))\n    return defaults.array;\n  else\n    return defaults.object;\n}\n\nfunction useBase64(target, options) {\n  const base64 = ref(\"\");\n  const promise = ref();\n  function execute() {\n    if (!isClient)\n      return;\n    promise.value = new Promise((resolve, reject) => {\n      try {\n        const _target = toValue(target);\n        if (_target == null) {\n          resolve(\"\");\n        } else if (typeof _target === \"string\") {\n          resolve(blobToBase64(new Blob([_target], { type: \"text/plain\" })));\n        } else if (_target instanceof Blob) {\n          resolve(blobToBase64(_target));\n        } else if (_target instanceof ArrayBuffer) {\n          resolve(window.btoa(String.fromCharCode(...new Uint8Array(_target))));\n        } else if (_target instanceof HTMLCanvasElement) {\n          resolve(_target.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\n        } else if (_target instanceof HTMLImageElement) {\n          const img = _target.cloneNode(false);\n          img.crossOrigin = \"Anonymous\";\n          imgLoaded(img).then(() => {\n            const canvas = document.createElement(\"canvas\");\n            const ctx = canvas.getContext(\"2d\");\n            canvas.width = img.width;\n            canvas.height = img.height;\n            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n            resolve(canvas.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\n          }).catch(reject);\n        } else if (typeof _target === \"object\") {\n          const _serializeFn = (options == null ? void 0 : options.serializer) || getDefaultSerialization(_target);\n          const serialized = _serializeFn(_target);\n          return resolve(blobToBase64(new Blob([serialized], { type: \"application/json\" })));\n        } else {\n          reject(new Error(\"target is unsupported types\"));\n        }\n      } catch (error) {\n        reject(error);\n      }\n    });\n    promise.value.then((res) => base64.value = res);\n    return promise.value;\n  }\n  if (isRef(target) || typeof target === \"function\")\n    watch(target, execute, { immediate: true });\n  else\n    execute();\n  return {\n    base64,\n    promise,\n    execute\n  };\n}\nfunction imgLoaded(img) {\n  return new Promise((resolve, reject) => {\n    if (!img.complete) {\n      img.onload = () => {\n        resolve();\n      };\n      img.onerror = reject;\n    } else {\n      resolve();\n    }\n  });\n}\nfunction blobToBase64(blob) {\n  return new Promise((resolve, reject) => {\n    const fr = new FileReader();\n    fr.onload = (e) => {\n      resolve(e.target.result);\n    };\n    fr.onerror = reject;\n    fr.readAsDataURL(blob);\n  });\n}\n\nfunction useBattery({ navigator = defaultNavigator } = {}) {\n  const events = [\"chargingchange\", \"chargingtimechange\", \"dischargingtimechange\", \"levelchange\"];\n  const isSupported = useSupported(() => navigator && \"getBattery\" in navigator);\n  const charging = ref(false);\n  const chargingTime = ref(0);\n  const dischargingTime = ref(0);\n  const level = ref(1);\n  let battery;\n  function updateBatteryInfo() {\n    charging.value = this.charging;\n    chargingTime.value = this.chargingTime || 0;\n    dischargingTime.value = this.dischargingTime || 0;\n    level.value = this.level;\n  }\n  if (isSupported.value) {\n    navigator.getBattery().then((_battery) => {\n      battery = _battery;\n      updateBatteryInfo.call(battery);\n      for (const event of events)\n        useEventListener(battery, event, updateBatteryInfo, { passive: true });\n    });\n  }\n  return {\n    isSupported,\n    charging,\n    chargingTime,\n    dischargingTime,\n    level\n  };\n}\n\nfunction useBluetooth(options) {\n  let {\n    acceptAllDevices = false\n  } = options || {};\n  const {\n    filters = void 0,\n    optionalServices = void 0,\n    navigator = defaultNavigator\n  } = options || {};\n  const isSupported = useSupported(() => navigator && \"bluetooth\" in navigator);\n  const device = shallowRef(void 0);\n  const error = shallowRef(null);\n  watch(device, () => {\n    connectToBluetoothGATTServer();\n  });\n  async function requestDevice() {\n    if (!isSupported.value)\n      return;\n    error.value = null;\n    if (filters && filters.length > 0)\n      acceptAllDevices = false;\n    try {\n      device.value = await (navigator == null ? void 0 : navigator.bluetooth.requestDevice({\n        acceptAllDevices,\n        filters,\n        optionalServices\n      }));\n    } catch (err) {\n      error.value = err;\n    }\n  }\n  const server = ref();\n  const isConnected = computed(() => {\n    var _a;\n    return ((_a = server.value) == null ? void 0 : _a.connected) || false;\n  });\n  async function connectToBluetoothGATTServer() {\n    error.value = null;\n    if (device.value && device.value.gatt) {\n      device.value.addEventListener(\"gattserverdisconnected\", () => {\n      });\n      try {\n        server.value = await device.value.gatt.connect();\n      } catch (err) {\n        error.value = err;\n      }\n    }\n  }\n  tryOnMounted(() => {\n    var _a;\n    if (device.value)\n      (_a = device.value.gatt) == null ? void 0 : _a.connect();\n  });\n  tryOnScopeDispose(() => {\n    var _a;\n    if (device.value)\n      (_a = device.value.gatt) == null ? void 0 : _a.disconnect();\n  });\n  return {\n    isSupported,\n    isConnected,\n    // Device:\n    device,\n    requestDevice,\n    // Server:\n    server,\n    // Errors:\n    error\n  };\n}\n\nfunction useMediaQuery(query, options = {}) {\n  const { window = defaultWindow } = options;\n  const isSupported = useSupported(() => window && \"matchMedia\" in window && typeof window.matchMedia === \"function\");\n  let mediaQuery;\n  const matches = ref(false);\n  const cleanup = () => {\n    if (!mediaQuery)\n      return;\n    if (\"removeEventListener\" in mediaQuery)\n      mediaQuery.removeEventListener(\"change\", update);\n    else\n      mediaQuery.removeListener(update);\n  };\n  const update = () => {\n    if (!isSupported.value)\n      return;\n    cleanup();\n    mediaQuery = window.matchMedia(toRef(query).value);\n    matches.value = !!(mediaQuery == null ? void 0 : mediaQuery.matches);\n    if (!mediaQuery)\n      return;\n    if (\"addEventListener\" in mediaQuery)\n      mediaQuery.addEventListener(\"change\", update);\n    else\n      mediaQuery.addListener(update);\n  };\n  watchEffect(update);\n  tryOnScopeDispose(() => cleanup());\n  return matches;\n}\n\nconst breakpointsTailwind = {\n  \"sm\": 640,\n  \"md\": 768,\n  \"lg\": 1024,\n  \"xl\": 1280,\n  \"2xl\": 1536\n};\nconst breakpointsBootstrapV5 = {\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1400\n};\nconst breakpointsVuetify = {\n  xs: 600,\n  sm: 960,\n  md: 1264,\n  lg: 1904\n};\nconst breakpointsAntDesign = {\n  xs: 480,\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1600\n};\nconst breakpointsQuasar = {\n  xs: 600,\n  sm: 1024,\n  md: 1440,\n  lg: 1920\n};\nconst breakpointsSematic = {\n  mobileS: 320,\n  mobileM: 375,\n  mobileL: 425,\n  tablet: 768,\n  laptop: 1024,\n  laptopL: 1440,\n  desktop4K: 2560\n};\nconst breakpointsMasterCss = {\n  \"3xs\": 360,\n  \"2xs\": 480,\n  \"xs\": 600,\n  \"sm\": 768,\n  \"md\": 1024,\n  \"lg\": 1280,\n  \"xl\": 1440,\n  \"2xl\": 1600,\n  \"3xl\": 1920,\n  \"4xl\": 2560\n};\n\nfunction useBreakpoints(breakpoints, options = {}) {\n  function getValue(k, delta) {\n    let v = breakpoints[k];\n    if (delta != null)\n      v = increaseWithUnit(v, delta);\n    if (typeof v === \"number\")\n      v = `${v}px`;\n    return v;\n  }\n  const { window = defaultWindow } = options;\n  function match(query) {\n    if (!window)\n      return false;\n    return window.matchMedia(query).matches;\n  }\n  const greaterOrEqual = (k) => {\n    return useMediaQuery(`(min-width: ${getValue(k)})`, options);\n  };\n  const shortcutMethods = Object.keys(breakpoints).reduce((shortcuts, k) => {\n    Object.defineProperty(shortcuts, k, {\n      get: () => greaterOrEqual(k),\n      enumerable: true,\n      configurable: true\n    });\n    return shortcuts;\n  }, {});\n  return Object.assign(shortcutMethods, {\n    greater(k) {\n      return useMediaQuery(`(min-width: ${getValue(k, 0.1)})`, options);\n    },\n    greaterOrEqual,\n    smaller(k) {\n      return useMediaQuery(`(max-width: ${getValue(k, -0.1)})`, options);\n    },\n    smallerOrEqual(k) {\n      return useMediaQuery(`(max-width: ${getValue(k)})`, options);\n    },\n    between(a, b) {\n      return useMediaQuery(`(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`, options);\n    },\n    isGreater(k) {\n      return match(`(min-width: ${getValue(k, 0.1)})`);\n    },\n    isGreaterOrEqual(k) {\n      return match(`(min-width: ${getValue(k)})`);\n    },\n    isSmaller(k) {\n      return match(`(max-width: ${getValue(k, -0.1)})`);\n    },\n    isSmallerOrEqual(k) {\n      return match(`(max-width: ${getValue(k)})`);\n    },\n    isInBetween(a, b) {\n      return match(`(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`);\n    },\n    current() {\n      const points = Object.keys(breakpoints).map((i) => [i, greaterOrEqual(i)]);\n      return computed(() => points.filter(([, v]) => v.value).map(([k]) => k));\n    }\n  });\n}\n\nfunction useBroadcastChannel(options) {\n  const {\n    name,\n    window = defaultWindow\n  } = options;\n  const isSupported = useSupported(() => window && \"BroadcastChannel\" in window);\n  const isClosed = ref(false);\n  const channel = ref();\n  const data = ref();\n  const error = shallowRef(null);\n  const post = (data2) => {\n    if (channel.value)\n      channel.value.postMessage(data2);\n  };\n  const close = () => {\n    if (channel.value)\n      channel.value.close();\n    isClosed.value = true;\n  };\n  if (isSupported.value) {\n    tryOnMounted(() => {\n      error.value = null;\n      channel.value = new BroadcastChannel(name);\n      channel.value.addEventListener(\"message\", (e) => {\n        data.value = e.data;\n      }, { passive: true });\n      channel.value.addEventListener(\"messageerror\", (e) => {\n        error.value = e;\n      }, { passive: true });\n      channel.value.addEventListener(\"close\", () => {\n        isClosed.value = true;\n      });\n    });\n  }\n  tryOnScopeDispose(() => {\n    close();\n  });\n  return {\n    isSupported,\n    channel,\n    data,\n    post,\n    close,\n    error,\n    isClosed\n  };\n}\n\nvar __defProp$n = Object.defineProperty;\nvar __getOwnPropSymbols$q = Object.getOwnPropertySymbols;\nvar __hasOwnProp$q = Object.prototype.hasOwnProperty;\nvar __propIsEnum$q = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$n = (obj, key, value) => key in obj ? __defProp$n(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$n = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$q.call(b, prop))\n      __defNormalProp$n(a, prop, b[prop]);\n  if (__getOwnPropSymbols$q)\n    for (var prop of __getOwnPropSymbols$q(b)) {\n      if (__propIsEnum$q.call(b, prop))\n        __defNormalProp$n(a, prop, b[prop]);\n    }\n  return a;\n};\nconst WRITABLE_PROPERTIES = [\n  \"hash\",\n  \"host\",\n  \"hostname\",\n  \"href\",\n  \"pathname\",\n  \"port\",\n  \"protocol\",\n  \"search\"\n];\nfunction useBrowserLocation({ window = defaultWindow } = {}) {\n  const refs = Object.fromEntries(\n    WRITABLE_PROPERTIES.map((key) => [key, ref()])\n  );\n  for (const [key, ref2] of objectEntries(refs)) {\n    watch(ref2, (value) => {\n      if (!(window == null ? void 0 : window.location) || window.location[key] === value)\n        return;\n      window.location[key] = value;\n    });\n  }\n  const buildState = (trigger) => {\n    var _a;\n    const { state: state2, length } = (window == null ? void 0 : window.history) || {};\n    const { origin } = (window == null ? void 0 : window.location) || {};\n    for (const key of WRITABLE_PROPERTIES)\n      refs[key].value = (_a = window == null ? void 0 : window.location) == null ? void 0 : _a[key];\n    return reactive(__spreadValues$n({\n      trigger,\n      state: state2,\n      length,\n      origin\n    }, refs));\n  };\n  const state = ref(buildState(\"load\"));\n  if (window) {\n    useEventListener(window, \"popstate\", () => state.value = buildState(\"popstate\"), { passive: true });\n    useEventListener(window, \"hashchange\", () => state.value = buildState(\"hashchange\"), { passive: true });\n  }\n  return state;\n}\n\nfunction useCached(refValue, comparator = (a, b) => a === b, watchOptions) {\n  const cachedValue = ref(refValue.value);\n  watch(() => refValue.value, (value) => {\n    if (!comparator(value, cachedValue.value))\n      cachedValue.value = value;\n  }, watchOptions);\n  return cachedValue;\n}\n\nfunction useClipboard(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    read = false,\n    source,\n    copiedDuring = 1500,\n    legacy = false\n  } = options;\n  const events = [\"copy\", \"cut\"];\n  const isClipboardApiSupported = useSupported(() => navigator && \"clipboard\" in navigator);\n  const isSupported = computed(() => isClipboardApiSupported.value || legacy);\n  const text = ref(\"\");\n  const copied = ref(false);\n  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring);\n  function updateText() {\n    if (isClipboardApiSupported.value) {\n      navigator.clipboard.readText().then((value) => {\n        text.value = value;\n      });\n    } else {\n      text.value = legacyRead();\n    }\n  }\n  if (isSupported.value && read) {\n    for (const event of events)\n      useEventListener(event, updateText);\n  }\n  async function copy(value = toValue(source)) {\n    if (isSupported.value && value != null) {\n      if (isClipboardApiSupported.value)\n        await navigator.clipboard.writeText(value);\n      else\n        legacyCopy(value);\n      text.value = value;\n      copied.value = true;\n      timeout.start();\n    }\n  }\n  function legacyCopy(value) {\n    const ta = document.createElement(\"textarea\");\n    ta.value = value != null ? value : \"\";\n    ta.style.position = \"absolute\";\n    ta.style.opacity = \"0\";\n    document.body.appendChild(ta);\n    ta.select();\n    document.execCommand(\"copy\");\n    ta.remove();\n  }\n  function legacyRead() {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = document == null ? void 0 : document.getSelection) == null ? void 0 : _a.call(document)) == null ? void 0 : _b.toString()) != null ? _c : \"\";\n  }\n  return {\n    isSupported,\n    text,\n    copied,\n    copy\n  };\n}\n\nvar __defProp$m = Object.defineProperty;\nvar __defProps$a = Object.defineProperties;\nvar __getOwnPropDescs$a = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$p = Object.getOwnPropertySymbols;\nvar __hasOwnProp$p = Object.prototype.hasOwnProperty;\nvar __propIsEnum$p = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$m = (obj, key, value) => key in obj ? __defProp$m(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$m = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$p.call(b, prop))\n      __defNormalProp$m(a, prop, b[prop]);\n  if (__getOwnPropSymbols$p)\n    for (var prop of __getOwnPropSymbols$p(b)) {\n      if (__propIsEnum$p.call(b, prop))\n        __defNormalProp$m(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$a = (a, b) => __defProps$a(a, __getOwnPropDescs$a(b));\nfunction cloneFnJSON(source) {\n  return JSON.parse(JSON.stringify(source));\n}\nfunction useCloned(source, options = {}) {\n  const cloned = ref({});\n  const {\n    manual,\n    clone = cloneFnJSON,\n    // watch options\n    deep = true,\n    immediate = true\n  } = options;\n  function sync() {\n    cloned.value = clone(toValue(source));\n  }\n  if (!manual && (isRef(source) || typeof source === \"function\")) {\n    watch(source, sync, __spreadProps$a(__spreadValues$m({}, options), {\n      deep,\n      immediate\n    }));\n  } else {\n    sync();\n  }\n  return { cloned, sync };\n}\n\nconst _global = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nconst globalKey = \"__vueuse_ssr_handlers__\";\nconst handlers = /* @__PURE__ */ getHandlers();\nfunction getHandlers() {\n  if (!(globalKey in _global))\n    _global[globalKey] = _global[globalKey] || {};\n  return _global[globalKey];\n}\nfunction getSSRHandler(key, fallback) {\n  return handlers[key] || fallback;\n}\nfunction setSSRHandler(key, fn) {\n  handlers[key] = fn;\n}\n\nfunction guessSerializerType(rawInit) {\n  return rawInit == null ? \"any\" : rawInit instanceof Set ? \"set\" : rawInit instanceof Map ? \"map\" : rawInit instanceof Date ? \"date\" : typeof rawInit === \"boolean\" ? \"boolean\" : typeof rawInit === \"string\" ? \"string\" : typeof rawInit === \"object\" ? \"object\" : !Number.isNaN(rawInit) ? \"number\" : \"any\";\n}\n\nvar __defProp$l = Object.defineProperty;\nvar __getOwnPropSymbols$o = Object.getOwnPropertySymbols;\nvar __hasOwnProp$o = Object.prototype.hasOwnProperty;\nvar __propIsEnum$o = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$l = (obj, key, value) => key in obj ? __defProp$l(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$l = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$o.call(b, prop))\n      __defNormalProp$l(a, prop, b[prop]);\n  if (__getOwnPropSymbols$o)\n    for (var prop of __getOwnPropSymbols$o(b)) {\n      if (__propIsEnum$o.call(b, prop))\n        __defNormalProp$l(a, prop, b[prop]);\n    }\n  return a;\n};\nconst StorageSerializers = {\n  boolean: {\n    read: (v) => v === \"true\",\n    write: (v) => String(v)\n  },\n  object: {\n    read: (v) => JSON.parse(v),\n    write: (v) => JSON.stringify(v)\n  },\n  number: {\n    read: (v) => Number.parseFloat(v),\n    write: (v) => String(v)\n  },\n  any: {\n    read: (v) => v,\n    write: (v) => String(v)\n  },\n  string: {\n    read: (v) => v,\n    write: (v) => String(v)\n  },\n  map: {\n    read: (v) => new Map(JSON.parse(v)),\n    write: (v) => JSON.stringify(Array.from(v.entries()))\n  },\n  set: {\n    read: (v) => new Set(JSON.parse(v)),\n    write: (v) => JSON.stringify(Array.from(v))\n  },\n  date: {\n    read: (v) => new Date(v),\n    write: (v) => v.toISOString()\n  }\n};\nconst customStorageEventName = \"vueuse-storage\";\nfunction useStorage(key, defaults, storage, options = {}) {\n  var _a;\n  const {\n    flush = \"pre\",\n    deep = true,\n    listenToStorageChanges = true,\n    writeDefaults = true,\n    mergeDefaults = false,\n    shallow,\n    window = defaultWindow,\n    eventFilter,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = options;\n  const data = (shallow ? shallowRef : ref)(defaults);\n  if (!storage) {\n    try {\n      storage = getSSRHandler(\"getDefaultStorage\", () => {\n        var _a2;\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\n      })();\n    } catch (e) {\n      onError(e);\n    }\n  }\n  if (!storage)\n    return data;\n  const rawInit = toValue(defaults);\n  const type = guessSerializerType(rawInit);\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\n  const { pause: pauseWatch, resume: resumeWatch } = pausableWatch(\n    data,\n    () => write(data.value),\n    { flush, deep, eventFilter }\n  );\n  if (window && listenToStorageChanges) {\n    useEventListener(window, \"storage\", update);\n    useEventListener(window, customStorageEventName, updateFromCustomEvent);\n  }\n  update();\n  return data;\n  function write(v) {\n    try {\n      if (v == null) {\n        storage.removeItem(key);\n      } else {\n        const serialized = serializer.write(v);\n        const oldValue = storage.getItem(key);\n        if (oldValue !== serialized) {\n          storage.setItem(key, serialized);\n          if (window) {\n            window.dispatchEvent(new CustomEvent(customStorageEventName, {\n              detail: {\n                key,\n                oldValue,\n                newValue: serialized,\n                storageArea: storage\n              }\n            }));\n          }\n        }\n      }\n    } catch (e) {\n      onError(e);\n    }\n  }\n  function read(event) {\n    const rawValue = event ? event.newValue : storage.getItem(key);\n    if (rawValue == null) {\n      if (writeDefaults && rawInit !== null)\n        storage.setItem(key, serializer.write(rawInit));\n      return rawInit;\n    } else if (!event && mergeDefaults) {\n      const value = serializer.read(rawValue);\n      if (typeof mergeDefaults === \"function\")\n        return mergeDefaults(value, rawInit);\n      else if (type === \"object\" && !Array.isArray(value))\n        return __spreadValues$l(__spreadValues$l({}, rawInit), value);\n      return value;\n    } else if (typeof rawValue !== \"string\") {\n      return rawValue;\n    } else {\n      return serializer.read(rawValue);\n    }\n  }\n  function updateFromCustomEvent(event) {\n    update(event.detail);\n  }\n  function update(event) {\n    if (event && event.storageArea !== storage)\n      return;\n    if (event && event.key == null) {\n      data.value = rawInit;\n      return;\n    }\n    if (event && event.key !== key)\n      return;\n    pauseWatch();\n    try {\n      data.value = read(event);\n    } catch (e) {\n      onError(e);\n    } finally {\n      if (event)\n        nextTick(resumeWatch);\n      else\n        resumeWatch();\n    }\n  }\n}\n\nfunction usePreferredDark(options) {\n  return useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n}\n\nvar __defProp$k = Object.defineProperty;\nvar __getOwnPropSymbols$n = Object.getOwnPropertySymbols;\nvar __hasOwnProp$n = Object.prototype.hasOwnProperty;\nvar __propIsEnum$n = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$k = (obj, key, value) => key in obj ? __defProp$k(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$k = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$n.call(b, prop))\n      __defNormalProp$k(a, prop, b[prop]);\n  if (__getOwnPropSymbols$n)\n    for (var prop of __getOwnPropSymbols$n(b)) {\n      if (__propIsEnum$n.call(b, prop))\n        __defNormalProp$k(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useColorMode(options = {}) {\n  const {\n    selector = \"html\",\n    attribute = \"class\",\n    initialValue = \"auto\",\n    window = defaultWindow,\n    storage,\n    storageKey = \"vueuse-color-scheme\",\n    listenToStorageChanges = true,\n    storageRef,\n    emitAuto,\n    disableTransition = true\n  } = options;\n  const modes = __spreadValues$k({\n    auto: \"\",\n    light: \"light\",\n    dark: \"dark\"\n  }, options.modes || {});\n  const preferredDark = usePreferredDark({ window });\n  const system = computed(() => preferredDark.value ? \"dark\" : \"light\");\n  const store = storageRef || (storageKey == null ? toRef(initialValue) : useStorage(storageKey, initialValue, storage, { window, listenToStorageChanges }));\n  const state = computed(\n    () => store.value === \"auto\" ? system.value : store.value\n  );\n  const updateHTMLAttrs = getSSRHandler(\n    \"updateHTMLAttrs\",\n    (selector2, attribute2, value) => {\n      const el = typeof selector2 === \"string\" ? window == null ? void 0 : window.document.querySelector(selector2) : unrefElement(selector2);\n      if (!el)\n        return;\n      let style;\n      if (disableTransition) {\n        style = window.document.createElement(\"style\");\n        const styleString = \"*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}\";\n        style.appendChild(document.createTextNode(styleString));\n        window.document.head.appendChild(style);\n      }\n      if (attribute2 === \"class\") {\n        const current = value.split(/\\s/g);\n        Object.values(modes).flatMap((i) => (i || \"\").split(/\\s/g)).filter(Boolean).forEach((v) => {\n          if (current.includes(v))\n            el.classList.add(v);\n          else\n            el.classList.remove(v);\n        });\n      } else {\n        el.setAttribute(attribute2, value);\n      }\n      if (disableTransition) {\n        window.getComputedStyle(style).opacity;\n        document.head.removeChild(style);\n      }\n    }\n  );\n  function defaultOnChanged(mode) {\n    var _a;\n    updateHTMLAttrs(selector, attribute, (_a = modes[mode]) != null ? _a : mode);\n  }\n  function onChanged(mode) {\n    if (options.onChanged)\n      options.onChanged(mode, defaultOnChanged);\n    else\n      defaultOnChanged(mode);\n  }\n  watch(state, onChanged, { flush: \"post\", immediate: true });\n  tryOnMounted(() => onChanged(state.value));\n  const auto = computed({\n    get() {\n      return emitAuto ? store.value : state.value;\n    },\n    set(v) {\n      store.value = v;\n    }\n  });\n  try {\n    return Object.assign(auto, { store, system, state });\n  } catch (e) {\n    return auto;\n  }\n}\n\nfunction useConfirmDialog(revealed = ref(false)) {\n  const confirmHook = createEventHook();\n  const cancelHook = createEventHook();\n  const revealHook = createEventHook();\n  let _resolve = noop;\n  const reveal = (data) => {\n    revealHook.trigger(data);\n    revealed.value = true;\n    return new Promise((resolve) => {\n      _resolve = resolve;\n    });\n  };\n  const confirm = (data) => {\n    revealed.value = false;\n    confirmHook.trigger(data);\n    _resolve({ data, isCanceled: false });\n  };\n  const cancel = (data) => {\n    revealed.value = false;\n    cancelHook.trigger(data);\n    _resolve({ data, isCanceled: true });\n  };\n  return {\n    isRevealed: computed(() => revealed.value),\n    reveal,\n    confirm,\n    cancel,\n    onReveal: revealHook.on,\n    onConfirm: confirmHook.on,\n    onCancel: cancelHook.on\n  };\n}\n\nvar __getOwnPropSymbols$m = Object.getOwnPropertySymbols;\nvar __hasOwnProp$m = Object.prototype.hasOwnProperty;\nvar __propIsEnum$m = Object.prototype.propertyIsEnumerable;\nvar __objRest$3 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$m.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$m)\n    for (var prop of __getOwnPropSymbols$m(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$m.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction useMutationObserver(target, callback, options = {}) {\n  const _a = options, { window = defaultWindow } = _a, mutationOptions = __objRest$3(_a, [\"window\"]);\n  let observer;\n  const isSupported = useSupported(() => window && \"MutationObserver\" in window);\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  const stopWatch = watch(\n    () => unrefElement(target),\n    (el) => {\n      cleanup();\n      if (isSupported.value && window && el) {\n        observer = new MutationObserver(callback);\n        observer.observe(el, mutationOptions);\n      }\n    },\n    { immediate: true }\n  );\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop\n  };\n}\n\nfunction useCssVar(prop, target, options = {}) {\n  const { window = defaultWindow, initialValue = \"\", observe = false } = options;\n  const variable = ref(initialValue);\n  const elRef = computed(() => {\n    var _a;\n    return unrefElement(target) || ((_a = window == null ? void 0 : window.document) == null ? void 0 : _a.documentElement);\n  });\n  function updateCssVar() {\n    var _a;\n    const key = toValue(prop);\n    const el = toValue(elRef);\n    if (el && window) {\n      const value = (_a = window.getComputedStyle(el).getPropertyValue(key)) == null ? void 0 : _a.trim();\n      variable.value = value || initialValue;\n    }\n  }\n  if (observe) {\n    useMutationObserver(elRef, updateCssVar, {\n      attributeFilter: [\"style\", \"class\"],\n      window\n    });\n  }\n  watch(\n    [elRef, () => toValue(prop)],\n    updateCssVar,\n    { immediate: true }\n  );\n  watch(\n    variable,\n    (val) => {\n      var _a;\n      if ((_a = elRef.value) == null ? void 0 : _a.style)\n        elRef.value.style.setProperty(toValue(prop), val);\n    }\n  );\n  return variable;\n}\n\nfunction useCurrentElement() {\n  const vm = getCurrentInstance();\n  const currentElement = computedWithControl(\n    () => null,\n    () => vm.proxy.$el\n  );\n  onUpdated(currentElement.trigger);\n  onMounted(currentElement.trigger);\n  return currentElement;\n}\n\nfunction useCycleList(list, options) {\n  const state = shallowRef(getInitialValue());\n  const listRef = toRef(list);\n  const index = computed({\n    get() {\n      var _a;\n      const targetList = listRef.value;\n      let index2 = (options == null ? void 0 : options.getIndexOf) ? options.getIndexOf(state.value, targetList) : targetList.indexOf(state.value);\n      if (index2 < 0)\n        index2 = (_a = options == null ? void 0 : options.fallbackIndex) != null ? _a : 0;\n      return index2;\n    },\n    set(v) {\n      set(v);\n    }\n  });\n  function set(i) {\n    const targetList = listRef.value;\n    const length = targetList.length;\n    const index2 = (i % length + length) % length;\n    const value = targetList[index2];\n    state.value = value;\n    return value;\n  }\n  function shift(delta = 1) {\n    return set(index.value + delta);\n  }\n  function next(n = 1) {\n    return shift(n);\n  }\n  function prev(n = 1) {\n    return shift(-n);\n  }\n  function getInitialValue() {\n    var _a, _b;\n    return (_b = toValue((_a = options == null ? void 0 : options.initialValue) != null ? _a : toValue(list)[0])) != null ? _b : void 0;\n  }\n  watch(listRef, () => set(index.value));\n  return {\n    state,\n    index,\n    next,\n    prev\n  };\n}\n\nvar __defProp$j = Object.defineProperty;\nvar __defProps$9 = Object.defineProperties;\nvar __getOwnPropDescs$9 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$l = Object.getOwnPropertySymbols;\nvar __hasOwnProp$l = Object.prototype.hasOwnProperty;\nvar __propIsEnum$l = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$j = (obj, key, value) => key in obj ? __defProp$j(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$j = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$l.call(b, prop))\n      __defNormalProp$j(a, prop, b[prop]);\n  if (__getOwnPropSymbols$l)\n    for (var prop of __getOwnPropSymbols$l(b)) {\n      if (__propIsEnum$l.call(b, prop))\n        __defNormalProp$j(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$9 = (a, b) => __defProps$9(a, __getOwnPropDescs$9(b));\nfunction useDark(options = {}) {\n  const {\n    valueDark = \"dark\",\n    valueLight = \"\"\n  } = options;\n  const mode = useColorMode(__spreadProps$9(__spreadValues$j({}, options), {\n    onChanged: (mode2, defaultHandler) => {\n      var _a;\n      if (options.onChanged)\n        (_a = options.onChanged) == null ? void 0 : _a.call(options, mode2 === \"dark\", defaultHandler, mode2);\n      else\n        defaultHandler(mode2);\n    },\n    modes: {\n      dark: valueDark,\n      light: valueLight\n    }\n  }));\n  const isDark = computed({\n    get() {\n      return mode.value === \"dark\";\n    },\n    set(v) {\n      const modeVal = v ? \"dark\" : \"light\";\n      if (mode.system.value === modeVal)\n        mode.value = \"auto\";\n      else\n        mode.value = modeVal;\n    }\n  });\n  return isDark;\n}\n\nfunction fnBypass(v) {\n  return v;\n}\nfunction fnSetSource(source, value) {\n  return source.value = value;\n}\nfunction defaultDump(clone) {\n  return clone ? typeof clone === \"function\" ? clone : cloneFnJSON : fnBypass;\n}\nfunction defaultParse(clone) {\n  return clone ? typeof clone === \"function\" ? clone : cloneFnJSON : fnBypass;\n}\nfunction useManualRefHistory(source, options = {}) {\n  const {\n    clone = false,\n    dump = defaultDump(clone),\n    parse = defaultParse(clone),\n    setSource = fnSetSource\n  } = options;\n  function _createHistoryRecord() {\n    return markRaw({\n      snapshot: dump(source.value),\n      timestamp: timestamp()\n    });\n  }\n  const last = ref(_createHistoryRecord());\n  const undoStack = ref([]);\n  const redoStack = ref([]);\n  const _setSource = (record) => {\n    setSource(source, parse(record.snapshot));\n    last.value = record;\n  };\n  const commit = () => {\n    undoStack.value.unshift(last.value);\n    last.value = _createHistoryRecord();\n    if (options.capacity && undoStack.value.length > options.capacity)\n      undoStack.value.splice(options.capacity, Infinity);\n    if (redoStack.value.length)\n      redoStack.value.splice(0, redoStack.value.length);\n  };\n  const clear = () => {\n    undoStack.value.splice(0, undoStack.value.length);\n    redoStack.value.splice(0, redoStack.value.length);\n  };\n  const undo = () => {\n    const state = undoStack.value.shift();\n    if (state) {\n      redoStack.value.unshift(last.value);\n      _setSource(state);\n    }\n  };\n  const redo = () => {\n    const state = redoStack.value.shift();\n    if (state) {\n      undoStack.value.unshift(last.value);\n      _setSource(state);\n    }\n  };\n  const reset = () => {\n    _setSource(last.value);\n  };\n  const history = computed(() => [last.value, ...undoStack.value]);\n  const canUndo = computed(() => undoStack.value.length > 0);\n  const canRedo = computed(() => redoStack.value.length > 0);\n  return {\n    source,\n    undoStack,\n    redoStack,\n    last,\n    history,\n    canUndo,\n    canRedo,\n    clear,\n    commit,\n    reset,\n    undo,\n    redo\n  };\n}\n\nvar __defProp$i = Object.defineProperty;\nvar __defProps$8 = Object.defineProperties;\nvar __getOwnPropDescs$8 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$k = Object.getOwnPropertySymbols;\nvar __hasOwnProp$k = Object.prototype.hasOwnProperty;\nvar __propIsEnum$k = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$i = (obj, key, value) => key in obj ? __defProp$i(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$i = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$k.call(b, prop))\n      __defNormalProp$i(a, prop, b[prop]);\n  if (__getOwnPropSymbols$k)\n    for (var prop of __getOwnPropSymbols$k(b)) {\n      if (__propIsEnum$k.call(b, prop))\n        __defNormalProp$i(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$8 = (a, b) => __defProps$8(a, __getOwnPropDescs$8(b));\nfunction useRefHistory(source, options = {}) {\n  const {\n    deep = false,\n    flush = \"pre\",\n    eventFilter\n  } = options;\n  const {\n    eventFilter: composedFilter,\n    pause,\n    resume: resumeTracking,\n    isActive: isTracking\n  } = pausableFilter(eventFilter);\n  const {\n    ignoreUpdates,\n    ignorePrevAsyncUpdates,\n    stop\n  } = watchIgnorable(\n    source,\n    commit,\n    { deep, flush, eventFilter: composedFilter }\n  );\n  function setSource(source2, value) {\n    ignorePrevAsyncUpdates();\n    ignoreUpdates(() => {\n      source2.value = value;\n    });\n  }\n  const manualHistory = useManualRefHistory(source, __spreadProps$8(__spreadValues$i({}, options), { clone: options.clone || deep, setSource }));\n  const { clear, commit: manualCommit } = manualHistory;\n  function commit() {\n    ignorePrevAsyncUpdates();\n    manualCommit();\n  }\n  function resume(commitNow) {\n    resumeTracking();\n    if (commitNow)\n      commit();\n  }\n  function batch(fn) {\n    let canceled = false;\n    const cancel = () => canceled = true;\n    ignoreUpdates(() => {\n      fn(cancel);\n    });\n    if (!canceled)\n      commit();\n  }\n  function dispose() {\n    stop();\n    clear();\n  }\n  return __spreadProps$8(__spreadValues$i({}, manualHistory), {\n    isTracking,\n    pause,\n    resume,\n    commit,\n    batch,\n    dispose\n  });\n}\n\nvar __defProp$h = Object.defineProperty;\nvar __defProps$7 = Object.defineProperties;\nvar __getOwnPropDescs$7 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$j = Object.getOwnPropertySymbols;\nvar __hasOwnProp$j = Object.prototype.hasOwnProperty;\nvar __propIsEnum$j = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$h = (obj, key, value) => key in obj ? __defProp$h(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$h = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$j.call(b, prop))\n      __defNormalProp$h(a, prop, b[prop]);\n  if (__getOwnPropSymbols$j)\n    for (var prop of __getOwnPropSymbols$j(b)) {\n      if (__propIsEnum$j.call(b, prop))\n        __defNormalProp$h(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$7 = (a, b) => __defProps$7(a, __getOwnPropDescs$7(b));\nfunction useDebouncedRefHistory(source, options = {}) {\n  const filter = options.debounce ? debounceFilter(options.debounce) : void 0;\n  const history = useRefHistory(source, __spreadProps$7(__spreadValues$h({}, options), { eventFilter: filter }));\n  return __spreadValues$h({}, history);\n}\n\nfunction useDeviceMotion(options = {}) {\n  const {\n    window = defaultWindow,\n    eventFilter = bypassFilter\n  } = options;\n  const acceleration = ref({ x: null, y: null, z: null });\n  const rotationRate = ref({ alpha: null, beta: null, gamma: null });\n  const interval = ref(0);\n  const accelerationIncludingGravity = ref({\n    x: null,\n    y: null,\n    z: null\n  });\n  if (window) {\n    const onDeviceMotion = createFilterWrapper(\n      eventFilter,\n      (event) => {\n        acceleration.value = event.acceleration;\n        accelerationIncludingGravity.value = event.accelerationIncludingGravity;\n        rotationRate.value = event.rotationRate;\n        interval.value = event.interval;\n      }\n    );\n    useEventListener(window, \"devicemotion\", onDeviceMotion);\n  }\n  return {\n    acceleration,\n    accelerationIncludingGravity,\n    rotationRate,\n    interval\n  };\n}\n\nfunction useDeviceOrientation(options = {}) {\n  const { window = defaultWindow } = options;\n  const isSupported = useSupported(() => window && \"DeviceOrientationEvent\" in window);\n  const isAbsolute = ref(false);\n  const alpha = ref(null);\n  const beta = ref(null);\n  const gamma = ref(null);\n  if (window && isSupported.value) {\n    useEventListener(window, \"deviceorientation\", (event) => {\n      isAbsolute.value = event.absolute;\n      alpha.value = event.alpha;\n      beta.value = event.beta;\n      gamma.value = event.gamma;\n    });\n  }\n  return {\n    isSupported,\n    isAbsolute,\n    alpha,\n    beta,\n    gamma\n  };\n}\n\nfunction useDevicePixelRatio({\n  window = defaultWindow\n} = {}) {\n  const pixelRatio = ref(1);\n  if (window) {\n    let observe = function() {\n      pixelRatio.value = window.devicePixelRatio;\n      cleanup();\n      media = window.matchMedia(`(resolution: ${pixelRatio.value}dppx)`);\n      media.addEventListener(\"change\", observe, { once: true });\n    }, cleanup = function() {\n      media == null ? void 0 : media.removeEventListener(\"change\", observe);\n    };\n    let media;\n    observe();\n    tryOnScopeDispose(cleanup);\n  }\n  return { pixelRatio };\n}\n\nfunction usePermission(permissionDesc, options = {}) {\n  const {\n    controls = false,\n    navigator = defaultNavigator\n  } = options;\n  const isSupported = useSupported(() => navigator && \"permissions\" in navigator);\n  let permissionStatus;\n  const desc = typeof permissionDesc === \"string\" ? { name: permissionDesc } : permissionDesc;\n  const state = ref();\n  const onChange = () => {\n    if (permissionStatus)\n      state.value = permissionStatus.state;\n  };\n  const query = createSingletonPromise(async () => {\n    if (!isSupported.value)\n      return;\n    if (!permissionStatus) {\n      try {\n        permissionStatus = await navigator.permissions.query(desc);\n        useEventListener(permissionStatus, \"change\", onChange);\n        onChange();\n      } catch (e) {\n        state.value = \"prompt\";\n      }\n    }\n    return permissionStatus;\n  });\n  query();\n  if (controls) {\n    return {\n      state,\n      isSupported,\n      query\n    };\n  } else {\n    return state;\n  }\n}\n\nfunction useDevicesList(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    requestPermissions = false,\n    constraints = { audio: true, video: true },\n    onUpdated\n  } = options;\n  const devices = ref([]);\n  const videoInputs = computed(() => devices.value.filter((i) => i.kind === \"videoinput\"));\n  const audioInputs = computed(() => devices.value.filter((i) => i.kind === \"audioinput\"));\n  const audioOutputs = computed(() => devices.value.filter((i) => i.kind === \"audiooutput\"));\n  const isSupported = useSupported(() => navigator && navigator.mediaDevices && navigator.mediaDevices.enumerateDevices);\n  const permissionGranted = ref(false);\n  let stream;\n  async function update() {\n    if (!isSupported.value)\n      return;\n    devices.value = await navigator.mediaDevices.enumerateDevices();\n    onUpdated == null ? void 0 : onUpdated(devices.value);\n    if (stream) {\n      stream.getTracks().forEach((t) => t.stop());\n      stream = null;\n    }\n  }\n  async function ensurePermissions() {\n    if (!isSupported.value)\n      return false;\n    if (permissionGranted.value)\n      return true;\n    const { state, query } = usePermission(\"camera\", { controls: true });\n    await query();\n    if (state.value !== \"granted\") {\n      stream = await navigator.mediaDevices.getUserMedia(constraints);\n      update();\n      permissionGranted.value = true;\n    } else {\n      permissionGranted.value = true;\n    }\n    return permissionGranted.value;\n  }\n  if (isSupported.value) {\n    if (requestPermissions)\n      ensurePermissions();\n    useEventListener(navigator.mediaDevices, \"devicechange\", update);\n    update();\n  }\n  return {\n    devices,\n    ensurePermissions,\n    permissionGranted,\n    videoInputs,\n    audioInputs,\n    audioOutputs,\n    isSupported\n  };\n}\n\nfunction useDisplayMedia(options = {}) {\n  var _a;\n  const enabled = ref((_a = options.enabled) != null ? _a : false);\n  const video = options.video;\n  const audio = options.audio;\n  const { navigator = defaultNavigator } = options;\n  const isSupported = useSupported(() => {\n    var _a2;\n    return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getDisplayMedia;\n  });\n  const constraint = { audio, video };\n  const stream = shallowRef();\n  async function _start() {\n    if (!isSupported.value || stream.value)\n      return;\n    stream.value = await navigator.mediaDevices.getDisplayMedia(constraint);\n    return stream.value;\n  }\n  async function _stop() {\n    var _a2;\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\n    stream.value = void 0;\n  }\n  function stop() {\n    _stop();\n    enabled.value = false;\n  }\n  async function start() {\n    await _start();\n    if (stream.value)\n      enabled.value = true;\n    return stream.value;\n  }\n  watch(\n    enabled,\n    (v) => {\n      if (v)\n        _start();\n      else\n        _stop();\n    },\n    { immediate: true }\n  );\n  return {\n    isSupported,\n    stream,\n    start,\n    stop,\n    enabled\n  };\n}\n\nfunction useDocumentVisibility({ document = defaultDocument } = {}) {\n  if (!document)\n    return ref(\"visible\");\n  const visibility = ref(document.visibilityState);\n  useEventListener(document, \"visibilitychange\", () => {\n    visibility.value = document.visibilityState;\n  });\n  return visibility;\n}\n\nvar __defProp$g = Object.defineProperty;\nvar __defProps$6 = Object.defineProperties;\nvar __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$i = Object.getOwnPropertySymbols;\nvar __hasOwnProp$i = Object.prototype.hasOwnProperty;\nvar __propIsEnum$i = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$g = (obj, key, value) => key in obj ? __defProp$g(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$g = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$i.call(b, prop))\n      __defNormalProp$g(a, prop, b[prop]);\n  if (__getOwnPropSymbols$i)\n    for (var prop of __getOwnPropSymbols$i(b)) {\n      if (__propIsEnum$i.call(b, prop))\n        __defNormalProp$g(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));\nfunction useDraggable(target, options = {}) {\n  var _a, _b;\n  const {\n    pointerTypes,\n    preventDefault,\n    stopPropagation,\n    exact,\n    onMove,\n    onEnd,\n    onStart,\n    initialValue,\n    axis = \"both\",\n    draggingElement = defaultWindow,\n    handle: draggingHandle = target\n  } = options;\n  const position = ref(\n    (_a = toValue(initialValue)) != null ? _a : { x: 0, y: 0 }\n  );\n  const pressedDelta = ref();\n  const filterEvent = (e) => {\n    if (pointerTypes)\n      return pointerTypes.includes(e.pointerType);\n    return true;\n  };\n  const handleEvent = (e) => {\n    if (toValue(preventDefault))\n      e.preventDefault();\n    if (toValue(stopPropagation))\n      e.stopPropagation();\n  };\n  const start = (e) => {\n    if (!filterEvent(e))\n      return;\n    if (toValue(exact) && e.target !== toValue(target))\n      return;\n    const rect = toValue(target).getBoundingClientRect();\n    const pos = {\n      x: e.clientX - rect.left,\n      y: e.clientY - rect.top\n    };\n    if ((onStart == null ? void 0 : onStart(pos, e)) === false)\n      return;\n    pressedDelta.value = pos;\n    handleEvent(e);\n  };\n  const move = (e) => {\n    if (!filterEvent(e))\n      return;\n    if (!pressedDelta.value)\n      return;\n    let { x, y } = position.value;\n    if (axis === \"x\" || axis === \"both\")\n      x = e.clientX - pressedDelta.value.x;\n    if (axis === \"y\" || axis === \"both\")\n      y = e.clientY - pressedDelta.value.y;\n    position.value = {\n      x,\n      y\n    };\n    onMove == null ? void 0 : onMove(position.value, e);\n    handleEvent(e);\n  };\n  const end = (e) => {\n    if (!filterEvent(e))\n      return;\n    if (!pressedDelta.value)\n      return;\n    pressedDelta.value = void 0;\n    onEnd == null ? void 0 : onEnd(position.value, e);\n    handleEvent(e);\n  };\n  if (isClient) {\n    const config = { capture: (_b = options.capture) != null ? _b : true };\n    useEventListener(draggingHandle, \"pointerdown\", start, config);\n    useEventListener(draggingElement, \"pointermove\", move, config);\n    useEventListener(draggingElement, \"pointerup\", end, config);\n  }\n  return __spreadProps$6(__spreadValues$g({}, toRefs(position)), {\n    position,\n    isDragging: computed(() => !!pressedDelta.value),\n    style: computed(\n      () => `left:${position.value.x}px;top:${position.value.y}px;`\n    )\n  });\n}\n\nfunction useDropZone(target, onDrop) {\n  const isOverDropZone = ref(false);\n  let counter = 0;\n  if (isClient) {\n    useEventListener(target, \"dragenter\", (event) => {\n      event.preventDefault();\n      counter += 1;\n      isOverDropZone.value = true;\n    });\n    useEventListener(target, \"dragover\", (event) => {\n      event.preventDefault();\n    });\n    useEventListener(target, \"dragleave\", (event) => {\n      event.preventDefault();\n      counter -= 1;\n      if (counter === 0)\n        isOverDropZone.value = false;\n    });\n    useEventListener(target, \"drop\", (event) => {\n      var _a, _b;\n      event.preventDefault();\n      counter = 0;\n      isOverDropZone.value = false;\n      const files = Array.from((_b = (_a = event.dataTransfer) == null ? void 0 : _a.files) != null ? _b : []);\n      onDrop == null ? void 0 : onDrop(files.length === 0 ? null : files);\n    });\n  }\n  return {\n    isOverDropZone\n  };\n}\n\nvar __getOwnPropSymbols$h = Object.getOwnPropertySymbols;\nvar __hasOwnProp$h = Object.prototype.hasOwnProperty;\nvar __propIsEnum$h = Object.prototype.propertyIsEnumerable;\nvar __objRest$2 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$h.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$h)\n    for (var prop of __getOwnPropSymbols$h(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$h.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction useResizeObserver(target, callback, options = {}) {\n  const _a = options, { window = defaultWindow } = _a, observerOptions = __objRest$2(_a, [\"window\"]);\n  let observer;\n  const isSupported = useSupported(() => window && \"ResizeObserver\" in window);\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  const targets = computed(\n    () => Array.isArray(target) ? target.map((el) => unrefElement(el)) : [unrefElement(target)]\n  );\n  const stopWatch = watch(\n    targets,\n    (els) => {\n      cleanup();\n      if (isSupported.value && window) {\n        observer = new ResizeObserver(callback);\n        for (const _el of els)\n          _el && observer.observe(_el, observerOptions);\n      }\n    },\n    { immediate: true, flush: \"post\", deep: true }\n  );\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop\n  };\n}\n\nfunction useElementBounding(target, options = {}) {\n  const {\n    reset = true,\n    windowResize = true,\n    windowScroll = true,\n    immediate = true\n  } = options;\n  const height = ref(0);\n  const bottom = ref(0);\n  const left = ref(0);\n  const right = ref(0);\n  const top = ref(0);\n  const width = ref(0);\n  const x = ref(0);\n  const y = ref(0);\n  function update() {\n    const el = unrefElement(target);\n    if (!el) {\n      if (reset) {\n        height.value = 0;\n        bottom.value = 0;\n        left.value = 0;\n        right.value = 0;\n        top.value = 0;\n        width.value = 0;\n        x.value = 0;\n        y.value = 0;\n      }\n      return;\n    }\n    const rect = el.getBoundingClientRect();\n    height.value = rect.height;\n    bottom.value = rect.bottom;\n    left.value = rect.left;\n    right.value = rect.right;\n    top.value = rect.top;\n    width.value = rect.width;\n    x.value = rect.x;\n    y.value = rect.y;\n  }\n  useResizeObserver(target, update);\n  watch(() => unrefElement(target), (ele) => !ele && update());\n  if (windowScroll)\n    useEventListener(\"scroll\", update, { capture: true, passive: true });\n  if (windowResize)\n    useEventListener(\"resize\", update, { passive: true });\n  tryOnMounted(() => {\n    if (immediate)\n      update();\n  });\n  return {\n    height,\n    bottom,\n    left,\n    right,\n    top,\n    width,\n    x,\n    y,\n    update\n  };\n}\n\nvar __defProp$f = Object.defineProperty;\nvar __getOwnPropSymbols$g = Object.getOwnPropertySymbols;\nvar __hasOwnProp$g = Object.prototype.hasOwnProperty;\nvar __propIsEnum$g = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$f = (obj, key, value) => key in obj ? __defProp$f(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$f = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$g.call(b, prop))\n      __defNormalProp$f(a, prop, b[prop]);\n  if (__getOwnPropSymbols$g)\n    for (var prop of __getOwnPropSymbols$g(b)) {\n      if (__propIsEnum$g.call(b, prop))\n        __defNormalProp$f(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useElementByPoint(options) {\n  const {\n    x,\n    y,\n    document = defaultDocument,\n    multiple,\n    interval = \"requestAnimationFrame\",\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => {\n    if (toValue(multiple))\n      return document && \"elementsFromPoint\" in document;\n    return document && \"elementFromPoint\" in document;\n  });\n  const element = ref(null);\n  const cb = () => {\n    var _a, _b;\n    element.value = toValue(multiple) ? (_a = document == null ? void 0 : document.elementsFromPoint(toValue(x), toValue(y))) != null ? _a : [] : (_b = document == null ? void 0 : document.elementFromPoint(toValue(x), toValue(y))) != null ? _b : null;\n  };\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });\n  return __spreadValues$f({\n    isSupported,\n    element\n  }, controls);\n}\n\nfunction useElementHover(el, options = {}) {\n  const {\n    delayEnter = 0,\n    delayLeave = 0,\n    window = defaultWindow\n  } = options;\n  const isHovered = ref(false);\n  let timer;\n  const toggle = (entering) => {\n    const delay = entering ? delayEnter : delayLeave;\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n    }\n    if (delay)\n      timer = setTimeout(() => isHovered.value = entering, delay);\n    else\n      isHovered.value = entering;\n  };\n  if (!window)\n    return isHovered;\n  useEventListener(el, \"mouseenter\", () => toggle(true), { passive: true });\n  useEventListener(el, \"mouseleave\", () => toggle(false), { passive: true });\n  return isHovered;\n}\n\nfunction useElementSize(target, initialSize = { width: 0, height: 0 }, options = {}) {\n  const { window = defaultWindow, box = \"content-box\" } = options;\n  const isSVG = computed(() => {\n    var _a, _b;\n    return (_b = (_a = unrefElement(target)) == null ? void 0 : _a.namespaceURI) == null ? void 0 : _b.includes(\"svg\");\n  });\n  const width = ref(initialSize.width);\n  const height = ref(initialSize.height);\n  useResizeObserver(\n    target,\n    ([entry]) => {\n      const boxSize = box === \"border-box\" ? entry.borderBoxSize : box === \"content-box\" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;\n      if (window && isSVG.value) {\n        const $elem = unrefElement(target);\n        if ($elem) {\n          const styles = window.getComputedStyle($elem);\n          width.value = Number.parseFloat(styles.width);\n          height.value = Number.parseFloat(styles.height);\n        }\n      } else {\n        if (boxSize) {\n          const formatBoxSize = Array.isArray(boxSize) ? boxSize : [boxSize];\n          width.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);\n          height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);\n        } else {\n          width.value = entry.contentRect.width;\n          height.value = entry.contentRect.height;\n        }\n      }\n    },\n    options\n  );\n  watch(\n    () => unrefElement(target),\n    (ele) => {\n      width.value = ele ? initialSize.width : 0;\n      height.value = ele ? initialSize.height : 0;\n    }\n  );\n  return {\n    width,\n    height\n  };\n}\n\nfunction useIntersectionObserver(target, callback, options = {}) {\n  const {\n    root,\n    rootMargin = \"0px\",\n    threshold = 0.1,\n    window = defaultWindow,\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => window && \"IntersectionObserver\" in window);\n  const targets = computed(() => {\n    const _target = toValue(target);\n    return (Array.isArray(_target) ? _target : [_target]).map(unrefElement).filter(notNullish);\n  });\n  let cleanup = noop;\n  const isActive = ref(immediate);\n  const stopWatch = isSupported.value ? watch(\n    () => [targets.value, unrefElement(root), isActive.value],\n    ([targets2, root2]) => {\n      cleanup();\n      if (!isActive.value)\n        return;\n      if (!targets2.length)\n        return;\n      const observer = new IntersectionObserver(\n        callback,\n        {\n          root: unrefElement(root2),\n          rootMargin,\n          threshold\n        }\n      );\n      targets2.forEach((el) => el && observer.observe(el));\n      cleanup = () => {\n        observer.disconnect();\n        cleanup = noop;\n      };\n    },\n    { immediate, flush: \"post\" }\n  ) : noop;\n  const stop = () => {\n    cleanup();\n    stopWatch();\n    isActive.value = false;\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    isActive,\n    pause() {\n      cleanup();\n      isActive.value = false;\n    },\n    resume() {\n      isActive.value = true;\n    },\n    stop\n  };\n}\n\nfunction useElementVisibility(element, { window = defaultWindow, scrollTarget } = {}) {\n  const elementIsVisible = ref(false);\n  useIntersectionObserver(\n    element,\n    ([{ isIntersecting }]) => {\n      elementIsVisible.value = isIntersecting;\n    },\n    {\n      root: scrollTarget,\n      window\n    }\n  );\n  return elementIsVisible;\n}\n\nconst events = /* @__PURE__ */ new Map();\n\nfunction useEventBus(key) {\n  const scope = getCurrentScope();\n  function on(listener) {\n    var _a;\n    const listeners = events.get(key) || /* @__PURE__ */ new Set();\n    listeners.add(listener);\n    events.set(key, listeners);\n    const _off = () => off(listener);\n    (_a = scope == null ? void 0 : scope.cleanups) == null ? void 0 : _a.push(_off);\n    return _off;\n  }\n  function once(listener) {\n    function _listener(...args) {\n      off(_listener);\n      listener(...args);\n    }\n    return on(_listener);\n  }\n  function off(listener) {\n    const listeners = events.get(key);\n    if (!listeners)\n      return;\n    listeners.delete(listener);\n    if (!listeners.size)\n      reset();\n  }\n  function reset() {\n    events.delete(key);\n  }\n  function emit(event, payload) {\n    var _a;\n    (_a = events.get(key)) == null ? void 0 : _a.forEach((v) => v(event, payload));\n  }\n  return { on, once, off, emit, reset };\n}\n\nfunction useEventSource(url, events = [], options = {}) {\n  const event = ref(null);\n  const data = ref(null);\n  const status = ref(\"CONNECTING\");\n  const eventSource = ref(null);\n  const error = shallowRef(null);\n  const {\n    withCredentials = false\n  } = options;\n  const close = () => {\n    if (eventSource.value) {\n      eventSource.value.close();\n      eventSource.value = null;\n      status.value = \"CLOSED\";\n    }\n  };\n  const es = new EventSource(url, { withCredentials });\n  eventSource.value = es;\n  es.onopen = () => {\n    status.value = \"OPEN\";\n    error.value = null;\n  };\n  es.onerror = (e) => {\n    status.value = \"CLOSED\";\n    error.value = e;\n  };\n  es.onmessage = (e) => {\n    event.value = null;\n    data.value = e.data;\n  };\n  for (const event_name of events) {\n    useEventListener(es, event_name, (e) => {\n      event.value = event_name;\n      data.value = e.data || null;\n    });\n  }\n  tryOnScopeDispose(() => {\n    close();\n  });\n  return {\n    eventSource,\n    event,\n    data,\n    status,\n    error,\n    close\n  };\n}\n\nfunction useEyeDropper(options = {}) {\n  const { initialValue = \"\" } = options;\n  const isSupported = useSupported(() => typeof window !== \"undefined\" && \"EyeDropper\" in window);\n  const sRGBHex = ref(initialValue);\n  async function open(openOptions) {\n    if (!isSupported.value)\n      return;\n    const eyeDropper = new window.EyeDropper();\n    const result = await eyeDropper.open(openOptions);\n    sRGBHex.value = result.sRGBHex;\n    return result;\n  }\n  return { isSupported, sRGBHex, open };\n}\n\nfunction useFavicon(newIcon = null, options = {}) {\n  const {\n    baseUrl = \"\",\n    rel = \"icon\",\n    document = defaultDocument\n  } = options;\n  const favicon = toRef(newIcon);\n  const applyIcon = (icon) => {\n    document == null ? void 0 : document.head.querySelectorAll(`link[rel*=\"${rel}\"]`).forEach((el) => el.href = `${baseUrl}${icon}`);\n  };\n  watch(\n    favicon,\n    (i, o) => {\n      if (typeof i === \"string\" && i !== o)\n        applyIcon(i);\n    },\n    { immediate: true }\n  );\n  return favicon;\n}\n\nvar __defProp$e = Object.defineProperty;\nvar __defProps$5 = Object.defineProperties;\nvar __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$f = Object.getOwnPropertySymbols;\nvar __hasOwnProp$f = Object.prototype.hasOwnProperty;\nvar __propIsEnum$f = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$e = (obj, key, value) => key in obj ? __defProp$e(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$e = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$f.call(b, prop))\n      __defNormalProp$e(a, prop, b[prop]);\n  if (__getOwnPropSymbols$f)\n    for (var prop of __getOwnPropSymbols$f(b)) {\n      if (__propIsEnum$f.call(b, prop))\n        __defNormalProp$e(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));\nconst payloadMapping = {\n  json: \"application/json\",\n  text: \"text/plain\"\n};\nfunction isFetchOptions(obj) {\n  return obj && containsProp(obj, \"immediate\", \"refetch\", \"initialData\", \"timeout\", \"beforeFetch\", \"afterFetch\", \"onFetchError\", \"fetch\");\n}\nfunction isAbsoluteURL(url) {\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n}\nfunction headersToObject(headers) {\n  if (typeof Headers !== \"undefined\" && headers instanceof Headers)\n    return Object.fromEntries([...headers.entries()]);\n  return headers;\n}\nfunction combineCallbacks(combination, ...callbacks) {\n  if (combination === \"overwrite\") {\n    return async (ctx) => {\n      const callback = callbacks[callbacks.length - 1];\n      if (callback)\n        return __spreadValues$e(__spreadValues$e({}, ctx), await callback(ctx));\n      return ctx;\n    };\n  } else {\n    return async (ctx) => {\n      for (const callback of callbacks) {\n        if (callback)\n          ctx = __spreadValues$e(__spreadValues$e({}, ctx), await callback(ctx));\n      }\n      return ctx;\n    };\n  }\n}\nfunction createFetch(config = {}) {\n  const _combination = config.combination || \"chain\";\n  const _options = config.options || {};\n  const _fetchOptions = config.fetchOptions || {};\n  function useFactoryFetch(url, ...args) {\n    const computedUrl = computed(() => {\n      const baseUrl = toValue(config.baseUrl);\n      const targetUrl = toValue(url);\n      return baseUrl && !isAbsoluteURL(targetUrl) ? joinPaths(baseUrl, targetUrl) : targetUrl;\n    });\n    let options = _options;\n    let fetchOptions = _fetchOptions;\n    if (args.length > 0) {\n      if (isFetchOptions(args[0])) {\n        options = __spreadProps$5(__spreadValues$e(__spreadValues$e({}, options), args[0]), {\n          beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[0].beforeFetch),\n          afterFetch: combineCallbacks(_combination, _options.afterFetch, args[0].afterFetch),\n          onFetchError: combineCallbacks(_combination, _options.onFetchError, args[0].onFetchError)\n        });\n      } else {\n        fetchOptions = __spreadProps$5(__spreadValues$e(__spreadValues$e({}, fetchOptions), args[0]), {\n          headers: __spreadValues$e(__spreadValues$e({}, headersToObject(fetchOptions.headers) || {}), headersToObject(args[0].headers) || {})\n        });\n      }\n    }\n    if (args.length > 1 && isFetchOptions(args[1])) {\n      options = __spreadProps$5(__spreadValues$e(__spreadValues$e({}, options), args[1]), {\n        beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[1].beforeFetch),\n        afterFetch: combineCallbacks(_combination, _options.afterFetch, args[1].afterFetch),\n        onFetchError: combineCallbacks(_combination, _options.onFetchError, args[1].onFetchError)\n      });\n    }\n    return useFetch(computedUrl, fetchOptions, options);\n  }\n  return useFactoryFetch;\n}\nfunction useFetch(url, ...args) {\n  var _a;\n  const supportsAbort = typeof AbortController === \"function\";\n  let fetchOptions = {};\n  let options = { immediate: true, refetch: false, timeout: 0 };\n  const config = {\n    method: \"GET\",\n    type: \"text\",\n    payload: void 0\n  };\n  if (args.length > 0) {\n    if (isFetchOptions(args[0]))\n      options = __spreadValues$e(__spreadValues$e({}, options), args[0]);\n    else\n      fetchOptions = args[0];\n  }\n  if (args.length > 1) {\n    if (isFetchOptions(args[1]))\n      options = __spreadValues$e(__spreadValues$e({}, options), args[1]);\n  }\n  const {\n    fetch = (_a = defaultWindow) == null ? void 0 : _a.fetch,\n    initialData,\n    timeout\n  } = options;\n  const responseEvent = createEventHook();\n  const errorEvent = createEventHook();\n  const finallyEvent = createEventHook();\n  const isFinished = ref(false);\n  const isFetching = ref(false);\n  const aborted = ref(false);\n  const statusCode = ref(null);\n  const response = shallowRef(null);\n  const error = shallowRef(null);\n  const data = shallowRef(initialData || null);\n  const canAbort = computed(() => supportsAbort && isFetching.value);\n  let controller;\n  let timer;\n  const abort = () => {\n    if (supportsAbort) {\n      controller == null ? void 0 : controller.abort();\n      controller = new AbortController();\n      controller.signal.onabort = () => aborted.value = true;\n      fetchOptions = __spreadProps$5(__spreadValues$e({}, fetchOptions), {\n        signal: controller.signal\n      });\n    }\n  };\n  const loading = (isLoading) => {\n    isFetching.value = isLoading;\n    isFinished.value = !isLoading;\n  };\n  if (timeout)\n    timer = useTimeoutFn(abort, timeout, { immediate: false });\n  const execute = async (throwOnFailed = false) => {\n    var _a2;\n    abort();\n    loading(true);\n    error.value = null;\n    statusCode.value = null;\n    aborted.value = false;\n    const defaultFetchOptions = {\n      method: config.method,\n      headers: {}\n    };\n    if (config.payload) {\n      const headers = headersToObject(defaultFetchOptions.headers);\n      if (config.payloadType)\n        headers[\"Content-Type\"] = (_a2 = payloadMapping[config.payloadType]) != null ? _a2 : config.payloadType;\n      const payload = toValue(config.payload);\n      defaultFetchOptions.body = config.payloadType === \"json\" ? JSON.stringify(payload) : payload;\n    }\n    let isCanceled = false;\n    const context = {\n      url: toValue(url),\n      options: __spreadValues$e(__spreadValues$e({}, defaultFetchOptions), fetchOptions),\n      cancel: () => {\n        isCanceled = true;\n      }\n    };\n    if (options.beforeFetch)\n      Object.assign(context, await options.beforeFetch(context));\n    if (isCanceled || !fetch) {\n      loading(false);\n      return Promise.resolve(null);\n    }\n    let responseData = null;\n    if (timer)\n      timer.start();\n    return new Promise((resolve, reject) => {\n      var _a3;\n      fetch(\n        context.url,\n        __spreadProps$5(__spreadValues$e(__spreadValues$e({}, defaultFetchOptions), context.options), {\n          headers: __spreadValues$e(__spreadValues$e({}, headersToObject(defaultFetchOptions.headers)), headersToObject((_a3 = context.options) == null ? void 0 : _a3.headers))\n        })\n      ).then(async (fetchResponse) => {\n        response.value = fetchResponse;\n        statusCode.value = fetchResponse.status;\n        responseData = await fetchResponse[config.type]();\n        if (!fetchResponse.ok) {\n          data.value = initialData || null;\n          throw new Error(fetchResponse.statusText);\n        }\n        if (options.afterFetch)\n          ({ data: responseData } = await options.afterFetch({ data: responseData, response: fetchResponse }));\n        data.value = responseData;\n        responseEvent.trigger(fetchResponse);\n        return resolve(fetchResponse);\n      }).catch(async (fetchError) => {\n        let errorData = fetchError.message || fetchError.name;\n        if (options.onFetchError)\n          ({ error: errorData } = await options.onFetchError({ data: responseData, error: fetchError, response: response.value }));\n        error.value = errorData;\n        errorEvent.trigger(fetchError);\n        if (throwOnFailed)\n          return reject(fetchError);\n        return resolve(null);\n      }).finally(() => {\n        loading(false);\n        if (timer)\n          timer.stop();\n        finallyEvent.trigger(null);\n      });\n    });\n  };\n  const refetch = toRef(options.refetch);\n  watch(\n    [\n      refetch,\n      toRef(url)\n    ],\n    ([refetch2]) => refetch2 && execute(),\n    { deep: true }\n  );\n  const shell = {\n    isFinished,\n    statusCode,\n    response,\n    error,\n    data,\n    isFetching,\n    canAbort,\n    aborted,\n    abort,\n    execute,\n    onFetchResponse: responseEvent.on,\n    onFetchError: errorEvent.on,\n    onFetchFinally: finallyEvent.on,\n    // method\n    get: setMethod(\"GET\"),\n    put: setMethod(\"PUT\"),\n    post: setMethod(\"POST\"),\n    delete: setMethod(\"DELETE\"),\n    patch: setMethod(\"PATCH\"),\n    head: setMethod(\"HEAD\"),\n    options: setMethod(\"OPTIONS\"),\n    // type\n    json: setType(\"json\"),\n    text: setType(\"text\"),\n    blob: setType(\"blob\"),\n    arrayBuffer: setType(\"arrayBuffer\"),\n    formData: setType(\"formData\")\n  };\n  function setMethod(method) {\n    return (payload, payloadType) => {\n      if (!isFetching.value) {\n        config.method = method;\n        config.payload = payload;\n        config.payloadType = payloadType;\n        if (isRef(config.payload)) {\n          watch(\n            [\n              refetch,\n              toRef(config.payload)\n            ],\n            ([refetch2]) => refetch2 && execute(),\n            { deep: true }\n          );\n        }\n        const rawPayload = toValue(config.payload);\n        if (!payloadType && rawPayload && Object.getPrototypeOf(rawPayload) === Object.prototype && !(rawPayload instanceof FormData))\n          config.payloadType = \"json\";\n        return __spreadProps$5(__spreadValues$e({}, shell), {\n          then(onFulfilled, onRejected) {\n            return waitUntilFinished().then(onFulfilled, onRejected);\n          }\n        });\n      }\n      return void 0;\n    };\n  }\n  function waitUntilFinished() {\n    return new Promise((resolve, reject) => {\n      until(isFinished).toBe(true).then(() => resolve(shell)).catch((error2) => reject(error2));\n    });\n  }\n  function setType(type) {\n    return () => {\n      if (!isFetching.value) {\n        config.type = type;\n        return __spreadProps$5(__spreadValues$e({}, shell), {\n          then(onFulfilled, onRejected) {\n            return waitUntilFinished().then(onFulfilled, onRejected);\n          }\n        });\n      }\n      return void 0;\n    };\n  }\n  if (options.immediate)\n    Promise.resolve().then(() => execute());\n  return __spreadProps$5(__spreadValues$e({}, shell), {\n    then(onFulfilled, onRejected) {\n      return waitUntilFinished().then(onFulfilled, onRejected);\n    }\n  });\n}\nfunction joinPaths(start, end) {\n  if (!start.endsWith(\"/\") && !end.startsWith(\"/\"))\n    return `${start}/${end}`;\n  return `${start}${end}`;\n}\n\nvar __defProp$d = Object.defineProperty;\nvar __getOwnPropSymbols$e = Object.getOwnPropertySymbols;\nvar __hasOwnProp$e = Object.prototype.hasOwnProperty;\nvar __propIsEnum$e = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$d = (obj, key, value) => key in obj ? __defProp$d(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$d = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$e.call(b, prop))\n      __defNormalProp$d(a, prop, b[prop]);\n  if (__getOwnPropSymbols$e)\n    for (var prop of __getOwnPropSymbols$e(b)) {\n      if (__propIsEnum$e.call(b, prop))\n        __defNormalProp$d(a, prop, b[prop]);\n    }\n  return a;\n};\nconst DEFAULT_OPTIONS = {\n  multiple: true,\n  accept: \"*\",\n  reset: false\n};\nfunction useFileDialog(options = {}) {\n  const {\n    document = defaultDocument\n  } = options;\n  const files = ref(null);\n  const { on: onChange, trigger } = createEventHook();\n  let input;\n  if (document) {\n    input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.onchange = (event) => {\n      const result = event.target;\n      files.value = result.files;\n      trigger(files.value);\n    };\n  }\n  const reset = () => {\n    files.value = null;\n    if (input)\n      input.value = \"\";\n  };\n  const open = (localOptions) => {\n    if (!input)\n      return;\n    const _options = __spreadValues$d(__spreadValues$d(__spreadValues$d({}, DEFAULT_OPTIONS), options), localOptions);\n    input.multiple = _options.multiple;\n    input.accept = _options.accept;\n    if (hasOwn(_options, \"capture\"))\n      input.capture = _options.capture;\n    if (_options.reset)\n      reset();\n    input.click();\n  };\n  return {\n    files: readonly(files),\n    open,\n    reset,\n    onChange\n  };\n}\n\nvar __defProp$c = Object.defineProperty;\nvar __getOwnPropSymbols$d = Object.getOwnPropertySymbols;\nvar __hasOwnProp$d = Object.prototype.hasOwnProperty;\nvar __propIsEnum$d = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$c = (obj, key, value) => key in obj ? __defProp$c(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$c = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$d.call(b, prop))\n      __defNormalProp$c(a, prop, b[prop]);\n  if (__getOwnPropSymbols$d)\n    for (var prop of __getOwnPropSymbols$d(b)) {\n      if (__propIsEnum$d.call(b, prop))\n        __defNormalProp$c(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useFileSystemAccess(options = {}) {\n  const {\n    window: _window = defaultWindow,\n    dataType = \"Text\"\n  } = options;\n  const window = _window;\n  const isSupported = useSupported(() => window && \"showSaveFilePicker\" in window && \"showOpenFilePicker\" in window);\n  const fileHandle = ref();\n  const data = ref();\n  const file = ref();\n  const fileName = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.name) != null ? _b : \"\";\n  });\n  const fileMIME = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.type) != null ? _b : \"\";\n  });\n  const fileSize = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.size) != null ? _b : 0;\n  });\n  const fileLastModified = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.lastModified) != null ? _b : 0;\n  });\n  async function open(_options = {}) {\n    if (!isSupported.value)\n      return;\n    const [handle] = await window.showOpenFilePicker(__spreadValues$c(__spreadValues$c({}, toValue(options)), _options));\n    fileHandle.value = handle;\n    await updateFile();\n    await updateData();\n  }\n  async function create(_options = {}) {\n    if (!isSupported.value)\n      return;\n    fileHandle.value = await window.showSaveFilePicker(__spreadValues$c(__spreadValues$c({}, options), _options));\n    data.value = void 0;\n    await updateFile();\n    await updateData();\n  }\n  async function save(_options = {}) {\n    if (!isSupported.value)\n      return;\n    if (!fileHandle.value)\n      return saveAs(_options);\n    if (data.value) {\n      const writableStream = await fileHandle.value.createWritable();\n      await writableStream.write(data.value);\n      await writableStream.close();\n    }\n    await updateFile();\n  }\n  async function saveAs(_options = {}) {\n    if (!isSupported.value)\n      return;\n    fileHandle.value = await window.showSaveFilePicker(__spreadValues$c(__spreadValues$c({}, options), _options));\n    if (data.value) {\n      const writableStream = await fileHandle.value.createWritable();\n      await writableStream.write(data.value);\n      await writableStream.close();\n    }\n    await updateFile();\n  }\n  async function updateFile() {\n    var _a;\n    file.value = await ((_a = fileHandle.value) == null ? void 0 : _a.getFile());\n  }\n  async function updateData() {\n    var _a, _b;\n    const type = toValue(dataType);\n    if (type === \"Text\")\n      data.value = await ((_a = file.value) == null ? void 0 : _a.text());\n    else if (type === \"ArrayBuffer\")\n      data.value = await ((_b = file.value) == null ? void 0 : _b.arrayBuffer());\n    else if (type === \"Blob\")\n      data.value = file.value;\n  }\n  watch(() => toValue(dataType), updateData);\n  return {\n    isSupported,\n    data,\n    file,\n    fileName,\n    fileMIME,\n    fileSize,\n    fileLastModified,\n    open,\n    create,\n    save,\n    saveAs,\n    updateData\n  };\n}\n\nfunction useFocus(target, options = {}) {\n  const { initialValue = false } = options;\n  const innerFocused = ref(false);\n  const targetElement = computed(() => unrefElement(target));\n  useEventListener(targetElement, \"focus\", () => innerFocused.value = true);\n  useEventListener(targetElement, \"blur\", () => innerFocused.value = false);\n  const focused = computed({\n    get: () => innerFocused.value,\n    set(value) {\n      var _a, _b;\n      if (!value && innerFocused.value)\n        (_a = targetElement.value) == null ? void 0 : _a.blur();\n      else if (value && !innerFocused.value)\n        (_b = targetElement.value) == null ? void 0 : _b.focus();\n    }\n  });\n  watch(\n    targetElement,\n    () => {\n      focused.value = initialValue;\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  return { focused };\n}\n\nfunction useFocusWithin(target, options = {}) {\n  const activeElement = useActiveElement(options);\n  const targetElement = computed(() => unrefElement(target));\n  const focused = computed(() => targetElement.value && activeElement.value ? targetElement.value.contains(activeElement.value) : false);\n  return { focused };\n}\n\nfunction useFps(options) {\n  var _a;\n  const fps = ref(0);\n  if (typeof performance === \"undefined\")\n    return fps;\n  const every = (_a = options == null ? void 0 : options.every) != null ? _a : 10;\n  let last = performance.now();\n  let ticks = 0;\n  useRafFn(() => {\n    ticks += 1;\n    if (ticks >= every) {\n      const now = performance.now();\n      const diff = now - last;\n      fps.value = Math.round(1e3 / (diff / ticks));\n      last = now;\n      ticks = 0;\n    }\n  });\n  return fps;\n}\n\nconst eventHandlers = [\n  \"fullscreenchange\",\n  \"webkitfullscreenchange\",\n  \"webkitendfullscreen\",\n  \"mozfullscreenchange\",\n  \"MSFullscreenChange\"\n];\nfunction useFullscreen(target, options = {}) {\n  const {\n    document = defaultDocument,\n    autoExit = false\n  } = options;\n  const targetRef = computed(() => {\n    var _a;\n    return (_a = unrefElement(target)) != null ? _a : document == null ? void 0 : document.querySelector(\"html\");\n  });\n  const isFullscreen = ref(false);\n  const requestMethod = computed(() => {\n    return [\n      \"requestFullscreen\",\n      \"webkitRequestFullscreen\",\n      \"webkitEnterFullscreen\",\n      \"webkitEnterFullScreen\",\n      \"webkitRequestFullScreen\",\n      \"mozRequestFullScreen\",\n      \"msRequestFullscreen\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const exitMethod = computed(() => {\n    return [\n      \"exitFullscreen\",\n      \"webkitExitFullscreen\",\n      \"webkitExitFullScreen\",\n      \"webkitCancelFullScreen\",\n      \"mozCancelFullScreen\",\n      \"msExitFullscreen\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const fullscreenEnabled = computed(() => {\n    return [\n      \"fullScreen\",\n      \"webkitIsFullScreen\",\n      \"webkitDisplayingFullscreen\",\n      \"mozFullScreen\",\n      \"msFullscreenElement\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const fullscreenElementMethod = [\n    \"fullscreenElement\",\n    \"webkitFullscreenElement\",\n    \"mozFullScreenElement\",\n    \"msFullscreenElement\"\n  ].find((m) => document && m in document);\n  const isSupported = useSupported(\n    () => targetRef.value && document && requestMethod.value !== void 0 && exitMethod.value !== void 0 && fullscreenEnabled.value !== void 0\n  );\n  const isCurrentElementFullScreen = () => {\n    if (fullscreenElementMethod)\n      return (document == null ? void 0 : document[fullscreenElementMethod]) === targetRef.value;\n    return false;\n  };\n  const isElementFullScreen = () => {\n    if (fullscreenEnabled.value) {\n      if (document && document[fullscreenEnabled.value] != null) {\n        return document[fullscreenEnabled.value];\n      } else {\n        const target2 = targetRef.value;\n        if ((target2 == null ? void 0 : target2[fullscreenEnabled.value]) != null) {\n          return Boolean(target2[fullscreenEnabled.value]);\n        }\n      }\n    }\n    return false;\n  };\n  async function exit() {\n    if (!isSupported.value)\n      return;\n    if (exitMethod.value) {\n      if ((document == null ? void 0 : document[exitMethod.value]) != null) {\n        await document[exitMethod.value]();\n      } else {\n        const target2 = targetRef.value;\n        if ((target2 == null ? void 0 : target2[exitMethod.value]) != null)\n          await target2[exitMethod.value]();\n      }\n    }\n    isFullscreen.value = false;\n  }\n  async function enter() {\n    if (!isSupported.value)\n      return;\n    if (isElementFullScreen())\n      await exit();\n    const target2 = targetRef.value;\n    if (requestMethod.value && (target2 == null ? void 0 : target2[requestMethod.value]) != null) {\n      await target2[requestMethod.value]();\n      isFullscreen.value = true;\n    }\n  }\n  async function toggle() {\n    await (isFullscreen.value ? exit() : enter());\n  }\n  const handlerCallback = () => {\n    const isElementFullScreenValue = isElementFullScreen();\n    if (!isElementFullScreenValue || isElementFullScreenValue && isCurrentElementFullScreen())\n      isFullscreen.value = isElementFullScreenValue;\n  };\n  useEventListener(document, eventHandlers, handlerCallback, false);\n  useEventListener(() => unrefElement(targetRef), eventHandlers, handlerCallback, false);\n  if (autoExit)\n    tryOnScopeDispose(exit);\n  return {\n    isSupported,\n    isFullscreen,\n    enter,\n    exit,\n    toggle\n  };\n}\n\nvar __defProp$b = Object.defineProperty;\nvar __defProps$4 = Object.defineProperties;\nvar __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$c = Object.getOwnPropertySymbols;\nvar __hasOwnProp$c = Object.prototype.hasOwnProperty;\nvar __propIsEnum$c = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$b(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$b = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$c.call(b, prop))\n      __defNormalProp$b(a, prop, b[prop]);\n  if (__getOwnPropSymbols$c)\n    for (var prop of __getOwnPropSymbols$c(b)) {\n      if (__propIsEnum$c.call(b, prop))\n        __defNormalProp$b(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));\nfunction mapGamepadToXbox360Controller(gamepad) {\n  return computed(() => {\n    if (gamepad.value) {\n      return {\n        buttons: {\n          a: gamepad.value.buttons[0],\n          b: gamepad.value.buttons[1],\n          x: gamepad.value.buttons[2],\n          y: gamepad.value.buttons[3]\n        },\n        bumper: {\n          left: gamepad.value.buttons[4],\n          right: gamepad.value.buttons[5]\n        },\n        triggers: {\n          left: gamepad.value.buttons[6],\n          right: gamepad.value.buttons[7]\n        },\n        stick: {\n          left: {\n            horizontal: gamepad.value.axes[0],\n            vertical: gamepad.value.axes[1],\n            button: gamepad.value.buttons[10]\n          },\n          right: {\n            horizontal: gamepad.value.axes[2],\n            vertical: gamepad.value.axes[3],\n            button: gamepad.value.buttons[11]\n          }\n        },\n        dpad: {\n          up: gamepad.value.buttons[12],\n          down: gamepad.value.buttons[13],\n          left: gamepad.value.buttons[14],\n          right: gamepad.value.buttons[15]\n        },\n        back: gamepad.value.buttons[8],\n        start: gamepad.value.buttons[9]\n      };\n    }\n    return null;\n  });\n}\nfunction useGamepad(options = {}) {\n  const {\n    navigator = defaultNavigator\n  } = options;\n  const isSupported = useSupported(() => navigator && \"getGamepads\" in navigator);\n  const gamepads = ref([]);\n  const onConnectedHook = createEventHook();\n  const onDisconnectedHook = createEventHook();\n  const stateFromGamepad = (gamepad) => {\n    const hapticActuators = [];\n    const vibrationActuator = \"vibrationActuator\" in gamepad ? gamepad.vibrationActuator : null;\n    if (vibrationActuator)\n      hapticActuators.push(vibrationActuator);\n    if (gamepad.hapticActuators)\n      hapticActuators.push(...gamepad.hapticActuators);\n    return __spreadProps$4(__spreadValues$b({}, gamepad), {\n      id: gamepad.id,\n      hapticActuators,\n      axes: gamepad.axes.map((axes) => axes),\n      buttons: gamepad.buttons.map((button) => ({ pressed: button.pressed, touched: button.touched, value: button.value }))\n    });\n  };\n  const updateGamepadState = () => {\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\n    for (let i = 0; i < _gamepads.length; ++i) {\n      const gamepad = _gamepads[i];\n      if (gamepad) {\n        const index = gamepads.value.findIndex(({ index: index2 }) => index2 === gamepad.index);\n        if (index > -1)\n          gamepads.value[index] = stateFromGamepad(gamepad);\n      }\n    }\n  };\n  const { isActive, pause, resume } = useRafFn(updateGamepadState);\n  const onGamepadConnected = (gamepad) => {\n    if (!gamepads.value.some(({ index }) => index === gamepad.index)) {\n      gamepads.value.push(stateFromGamepad(gamepad));\n      onConnectedHook.trigger(gamepad.index);\n    }\n    resume();\n  };\n  const onGamepadDisconnected = (gamepad) => {\n    gamepads.value = gamepads.value.filter((x) => x.index !== gamepad.index);\n    onDisconnectedHook.trigger(gamepad.index);\n  };\n  useEventListener(\"gamepadconnected\", (e) => onGamepadConnected(e.gamepad));\n  useEventListener(\"gamepaddisconnected\", (e) => onGamepadDisconnected(e.gamepad));\n  tryOnMounted(() => {\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\n    if (_gamepads) {\n      for (let i = 0; i < _gamepads.length; ++i) {\n        const gamepad = _gamepads[i];\n        if (gamepad)\n          onGamepadConnected(gamepad);\n      }\n    }\n  });\n  pause();\n  return {\n    isSupported,\n    onConnected: onConnectedHook.on,\n    onDisconnected: onDisconnectedHook.on,\n    gamepads,\n    pause,\n    resume,\n    isActive\n  };\n}\n\nfunction useGeolocation(options = {}) {\n  const {\n    enableHighAccuracy = true,\n    maximumAge = 3e4,\n    timeout = 27e3,\n    navigator = defaultNavigator,\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => navigator && \"geolocation\" in navigator);\n  const locatedAt = ref(null);\n  const error = shallowRef(null);\n  const coords = ref({\n    accuracy: 0,\n    latitude: Infinity,\n    longitude: Infinity,\n    altitude: null,\n    altitudeAccuracy: null,\n    heading: null,\n    speed: null\n  });\n  function updatePosition(position) {\n    locatedAt.value = position.timestamp;\n    coords.value = position.coords;\n    error.value = null;\n  }\n  let watcher;\n  function resume() {\n    if (isSupported.value) {\n      watcher = navigator.geolocation.watchPosition(\n        updatePosition,\n        (err) => error.value = err,\n        {\n          enableHighAccuracy,\n          maximumAge,\n          timeout\n        }\n      );\n    }\n  }\n  if (immediate)\n    resume();\n  function pause() {\n    if (watcher && navigator)\n      navigator.geolocation.clearWatch(watcher);\n  }\n  tryOnScopeDispose(() => {\n    pause();\n  });\n  return {\n    isSupported,\n    coords,\n    locatedAt,\n    error,\n    resume,\n    pause\n  };\n}\n\nconst defaultEvents$1 = [\"mousemove\", \"mousedown\", \"resize\", \"keydown\", \"touchstart\", \"wheel\"];\nconst oneMinute = 6e4;\nfunction useIdle(timeout = oneMinute, options = {}) {\n  const {\n    initialState = false,\n    listenForVisibilityChange = true,\n    events = defaultEvents$1,\n    window = defaultWindow,\n    eventFilter = throttleFilter(50)\n  } = options;\n  const idle = ref(initialState);\n  const lastActive = ref(timestamp());\n  let timer;\n  const reset = () => {\n    idle.value = false;\n    clearTimeout(timer);\n    timer = setTimeout(() => idle.value = true, timeout);\n  };\n  const onEvent = createFilterWrapper(\n    eventFilter,\n    () => {\n      lastActive.value = timestamp();\n      reset();\n    }\n  );\n  if (window) {\n    const document = window.document;\n    for (const event of events)\n      useEventListener(window, event, onEvent, { passive: true });\n    if (listenForVisibilityChange) {\n      useEventListener(document, \"visibilitychange\", () => {\n        if (!document.hidden)\n          onEvent();\n      });\n    }\n    reset();\n  }\n  return {\n    idle,\n    lastActive,\n    reset\n  };\n}\n\nvar __defProp$a = Object.defineProperty;\nvar __getOwnPropSymbols$b = Object.getOwnPropertySymbols;\nvar __hasOwnProp$b = Object.prototype.hasOwnProperty;\nvar __propIsEnum$b = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$a = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$b.call(b, prop))\n      __defNormalProp$a(a, prop, b[prop]);\n  if (__getOwnPropSymbols$b)\n    for (var prop of __getOwnPropSymbols$b(b)) {\n      if (__propIsEnum$b.call(b, prop))\n        __defNormalProp$a(a, prop, b[prop]);\n    }\n  return a;\n};\nasync function loadImage(options) {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    const { src, srcset, sizes, class: clazz, loading, crossorigin, referrerPolicy } = options;\n    img.src = src;\n    if (srcset)\n      img.srcset = srcset;\n    if (sizes)\n      img.sizes = sizes;\n    if (clazz)\n      img.className = clazz;\n    if (loading)\n      img.loading = loading;\n    if (crossorigin)\n      img.crossOrigin = crossorigin;\n    if (referrerPolicy)\n      img.referrerPolicy = referrerPolicy;\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n  });\n}\nfunction useImage(options, asyncStateOptions = {}) {\n  const state = useAsyncState(\n    () => loadImage(toValue(options)),\n    void 0,\n    __spreadValues$a({\n      resetOnExecute: true\n    }, asyncStateOptions)\n  );\n  watch(\n    () => toValue(options),\n    () => state.execute(asyncStateOptions.delay),\n    { deep: true }\n  );\n  return state;\n}\n\nconst ARRIVED_STATE_THRESHOLD_PIXELS = 1;\nfunction useScroll(element, options = {}) {\n  const {\n    throttle = 0,\n    idle = 200,\n    onStop = noop,\n    onScroll = noop,\n    offset = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    },\n    eventListenerOptions = {\n      capture: false,\n      passive: true\n    },\n    behavior = \"auto\"\n  } = options;\n  const internalX = ref(0);\n  const internalY = ref(0);\n  const x = computed({\n    get() {\n      return internalX.value;\n    },\n    set(x2) {\n      scrollTo(x2, void 0);\n    }\n  });\n  const y = computed({\n    get() {\n      return internalY.value;\n    },\n    set(y2) {\n      scrollTo(void 0, y2);\n    }\n  });\n  function scrollTo(_x, _y) {\n    var _a, _b, _c;\n    const _element = toValue(element);\n    if (!_element)\n      return;\n    (_c = _element instanceof Document ? document.body : _element) == null ? void 0 : _c.scrollTo({\n      top: (_a = toValue(_y)) != null ? _a : y.value,\n      left: (_b = toValue(_x)) != null ? _b : x.value,\n      behavior: toValue(behavior)\n    });\n  }\n  const isScrolling = ref(false);\n  const arrivedState = reactive({\n    left: true,\n    right: false,\n    top: true,\n    bottom: false\n  });\n  const directions = reactive({\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  });\n  const onScrollEnd = (e) => {\n    if (!isScrolling.value)\n      return;\n    isScrolling.value = false;\n    directions.left = false;\n    directions.right = false;\n    directions.top = false;\n    directions.bottom = false;\n    onStop(e);\n  };\n  const onScrollEndDebounced = useDebounceFn(onScrollEnd, throttle + idle);\n  const setArrivedState = (target) => {\n    const el = target === window ? target.document.documentElement : target === document ? target.documentElement : target;\n    const { display, flexDirection } = getComputedStyle(el);\n    const scrollLeft = el.scrollLeft;\n    directions.left = scrollLeft < internalX.value;\n    directions.right = scrollLeft > internalX.value;\n    const left = Math.abs(scrollLeft) <= 0 + (offset.left || 0);\n    const right = Math.abs(scrollLeft) + el.clientWidth >= el.scrollWidth - (offset.right || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n    if (display === \"flex\" && flexDirection === \"row-reverse\") {\n      arrivedState.left = right;\n      arrivedState.right = left;\n    } else {\n      arrivedState.left = left;\n      arrivedState.right = right;\n    }\n    internalX.value = scrollLeft;\n    let scrollTop = el.scrollTop;\n    if (target === document && !scrollTop)\n      scrollTop = document.body.scrollTop;\n    directions.top = scrollTop < internalY.value;\n    directions.bottom = scrollTop > internalY.value;\n    const top = Math.abs(scrollTop) <= 0 + (offset.top || 0);\n    const bottom = Math.abs(scrollTop) + el.clientHeight >= el.scrollHeight - (offset.bottom || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n    if (display === \"flex\" && flexDirection === \"column-reverse\") {\n      arrivedState.top = bottom;\n      arrivedState.bottom = top;\n    } else {\n      arrivedState.top = top;\n      arrivedState.bottom = bottom;\n    }\n    internalY.value = scrollTop;\n  };\n  const onScrollHandler = (e) => {\n    const eventTarget = e.target === document ? e.target.documentElement : e.target;\n    setArrivedState(eventTarget);\n    isScrolling.value = true;\n    onScrollEndDebounced(e);\n    onScroll(e);\n  };\n  useEventListener(\n    element,\n    \"scroll\",\n    throttle ? useThrottleFn(onScrollHandler, throttle, true, false) : onScrollHandler,\n    eventListenerOptions\n  );\n  useEventListener(\n    element,\n    \"scrollend\",\n    onScrollEnd,\n    eventListenerOptions\n  );\n  return {\n    x,\n    y,\n    isScrolling,\n    arrivedState,\n    directions,\n    measure() {\n      const _element = toValue(element);\n      if (_element)\n        setArrivedState(_element);\n    }\n  };\n}\n\nvar __defProp$9 = Object.defineProperty;\nvar __defProps$3 = Object.defineProperties;\nvar __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$a = Object.getOwnPropertySymbols;\nvar __hasOwnProp$a = Object.prototype.hasOwnProperty;\nvar __propIsEnum$a = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$9 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$a.call(b, prop))\n      __defNormalProp$9(a, prop, b[prop]);\n  if (__getOwnPropSymbols$a)\n    for (var prop of __getOwnPropSymbols$a(b)) {\n      if (__propIsEnum$a.call(b, prop))\n        __defNormalProp$9(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));\nfunction useInfiniteScroll(element, onLoadMore, options = {}) {\n  var _a;\n  const {\n    direction = \"bottom\",\n    interval = 100\n  } = options;\n  const state = reactive(useScroll(\n    element,\n    __spreadProps$3(__spreadValues$9({}, options), {\n      offset: __spreadValues$9({\n        [direction]: (_a = options.distance) != null ? _a : 0\n      }, options.offset)\n    })\n  ));\n  const promise = ref();\n  const isLoading = computed(() => !!promise.value);\n  function checkAndLoad() {\n    state.measure();\n    const el = toValue(element);\n    if (!el)\n      return;\n    const isNarrower = direction === \"bottom\" || direction === \"top\" ? el.scrollHeight <= el.clientHeight : el.scrollWidth <= el.clientWidth;\n    if (state.arrivedState[direction] || isNarrower) {\n      if (!promise.value) {\n        promise.value = Promise.all([\n          onLoadMore(state),\n          new Promise((resolve) => setTimeout(resolve, interval))\n        ]).finally(() => {\n          promise.value = null;\n          nextTick(() => checkAndLoad());\n        });\n      }\n    }\n  }\n  watch(\n    () => [state.arrivedState[direction], toValue(element)],\n    checkAndLoad,\n    { immediate: true }\n  );\n  return {\n    isLoading\n  };\n}\n\nconst defaultEvents = [\"mousedown\", \"mouseup\", \"keydown\", \"keyup\"];\nfunction useKeyModifier(modifier, options = {}) {\n  const {\n    events = defaultEvents,\n    document = defaultDocument,\n    initial = null\n  } = options;\n  const state = ref(initial);\n  if (document) {\n    events.forEach((listenerEvent) => {\n      useEventListener(document, listenerEvent, (evt) => {\n        if (typeof evt.getModifierState === \"function\")\n          state.value = evt.getModifierState(modifier);\n      });\n    });\n  }\n  return state;\n}\n\nfunction useLocalStorage(key, initialValue, options = {}) {\n  const { window = defaultWindow } = options;\n  return useStorage(key, initialValue, window == null ? void 0 : window.localStorage, options);\n}\n\nconst DefaultMagicKeysAliasMap = {\n  ctrl: \"control\",\n  command: \"meta\",\n  cmd: \"meta\",\n  option: \"alt\",\n  up: \"arrowup\",\n  down: \"arrowdown\",\n  left: \"arrowleft\",\n  right: \"arrowright\"\n};\n\nfunction useMagicKeys(options = {}) {\n  const {\n    reactive: useReactive = false,\n    target = defaultWindow,\n    aliasMap = DefaultMagicKeysAliasMap,\n    passive = true,\n    onEventFired = noop\n  } = options;\n  const current = reactive(/* @__PURE__ */ new Set());\n  const obj = {\n    toJSON() {\n      return {};\n    },\n    current\n  };\n  const refs = useReactive ? reactive(obj) : obj;\n  const metaDeps = /* @__PURE__ */ new Set();\n  const usedKeys = /* @__PURE__ */ new Set();\n  function setRefs(key, value) {\n    if (key in refs) {\n      if (useReactive)\n        refs[key] = value;\n      else\n        refs[key].value = value;\n    }\n  }\n  function reset() {\n    current.clear();\n    for (const key of usedKeys)\n      setRefs(key, false);\n  }\n  function updateRefs(e, value) {\n    var _a, _b;\n    const key = (_a = e.key) == null ? void 0 : _a.toLowerCase();\n    const code = (_b = e.code) == null ? void 0 : _b.toLowerCase();\n    const values = [code, key].filter(Boolean);\n    if (key) {\n      if (value)\n        current.add(key);\n      else\n        current.delete(key);\n    }\n    for (const key2 of values) {\n      usedKeys.add(key2);\n      setRefs(key2, value);\n    }\n    if (key === \"meta\" && !value) {\n      metaDeps.forEach((key2) => {\n        current.delete(key2);\n        setRefs(key2, false);\n      });\n      metaDeps.clear();\n    } else if (typeof e.getModifierState === \"function\" && e.getModifierState(\"Meta\") && value) {\n      [...current, ...values].forEach((key2) => metaDeps.add(key2));\n    }\n  }\n  useEventListener(target, \"keydown\", (e) => {\n    updateRefs(e, true);\n    return onEventFired(e);\n  }, { passive });\n  useEventListener(target, \"keyup\", (e) => {\n    updateRefs(e, false);\n    return onEventFired(e);\n  }, { passive });\n  useEventListener(\"blur\", reset, { passive: true });\n  useEventListener(\"focus\", reset, { passive: true });\n  const proxy = new Proxy(\n    refs,\n    {\n      get(target2, prop, rec) {\n        if (typeof prop !== \"string\")\n          return Reflect.get(target2, prop, rec);\n        prop = prop.toLowerCase();\n        if (prop in aliasMap)\n          prop = aliasMap[prop];\n        if (!(prop in refs)) {\n          if (/[+_-]/.test(prop)) {\n            const keys = prop.split(/[+_-]/g).map((i) => i.trim());\n            refs[prop] = computed(() => keys.every((key) => toValue(proxy[key])));\n          } else {\n            refs[prop] = ref(false);\n          }\n        }\n        const r = Reflect.get(target2, prop, rec);\n        return useReactive ? toValue(r) : r;\n      }\n    }\n  );\n  return proxy;\n}\n\nvar __defProp$8 = Object.defineProperty;\nvar __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$9 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$9 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$8 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$9.call(b, prop))\n      __defNormalProp$8(a, prop, b[prop]);\n  if (__getOwnPropSymbols$9)\n    for (var prop of __getOwnPropSymbols$9(b)) {\n      if (__propIsEnum$9.call(b, prop))\n        __defNormalProp$8(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction usingElRef(source, cb) {\n  if (toValue(source))\n    cb(toValue(source));\n}\nfunction timeRangeToArray(timeRanges) {\n  let ranges = [];\n  for (let i = 0; i < timeRanges.length; ++i)\n    ranges = [...ranges, [timeRanges.start(i), timeRanges.end(i)]];\n  return ranges;\n}\nfunction tracksToArray(tracks) {\n  return Array.from(tracks).map(({ label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }, id) => ({ id, label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }));\n}\nconst defaultOptions = {\n  src: \"\",\n  tracks: []\n};\nfunction useMediaControls(target, options = {}) {\n  options = __spreadValues$8(__spreadValues$8({}, defaultOptions), options);\n  const {\n    document = defaultDocument\n  } = options;\n  const currentTime = ref(0);\n  const duration = ref(0);\n  const seeking = ref(false);\n  const volume = ref(1);\n  const waiting = ref(false);\n  const ended = ref(false);\n  const playing = ref(false);\n  const rate = ref(1);\n  const stalled = ref(false);\n  const buffered = ref([]);\n  const tracks = ref([]);\n  const selectedTrack = ref(-1);\n  const isPictureInPicture = ref(false);\n  const muted = ref(false);\n  const supportsPictureInPicture = document && \"pictureInPictureEnabled\" in document;\n  const sourceErrorEvent = createEventHook();\n  const disableTrack = (track) => {\n    usingElRef(target, (el) => {\n      if (track) {\n        const id = typeof track === \"number\" ? track : track.id;\n        el.textTracks[id].mode = \"disabled\";\n      } else {\n        for (let i = 0; i < el.textTracks.length; ++i)\n          el.textTracks[i].mode = \"disabled\";\n      }\n      selectedTrack.value = -1;\n    });\n  };\n  const enableTrack = (track, disableTracks = true) => {\n    usingElRef(target, (el) => {\n      const id = typeof track === \"number\" ? track : track.id;\n      if (disableTracks)\n        disableTrack();\n      el.textTracks[id].mode = \"showing\";\n      selectedTrack.value = id;\n    });\n  };\n  const togglePictureInPicture = () => {\n    return new Promise((resolve, reject) => {\n      usingElRef(target, async (el) => {\n        if (supportsPictureInPicture) {\n          if (!isPictureInPicture.value) {\n            el.requestPictureInPicture().then(resolve).catch(reject);\n          } else {\n            document.exitPictureInPicture().then(resolve).catch(reject);\n          }\n        }\n      });\n    });\n  };\n  watchEffect(() => {\n    if (!document)\n      return;\n    const el = toValue(target);\n    if (!el)\n      return;\n    const src = toValue(options.src);\n    let sources = [];\n    if (!src)\n      return;\n    if (typeof src === \"string\")\n      sources = [{ src }];\n    else if (Array.isArray(src))\n      sources = src;\n    else if (isObject(src))\n      sources = [src];\n    el.querySelectorAll(\"source\").forEach((e) => {\n      e.removeEventListener(\"error\", sourceErrorEvent.trigger);\n      e.remove();\n    });\n    sources.forEach(({ src: src2, type }) => {\n      const source = document.createElement(\"source\");\n      source.setAttribute(\"src\", src2);\n      source.setAttribute(\"type\", type || \"\");\n      source.addEventListener(\"error\", sourceErrorEvent.trigger);\n      el.appendChild(source);\n    });\n    el.load();\n  });\n  tryOnScopeDispose(() => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.querySelectorAll(\"source\").forEach((e) => e.removeEventListener(\"error\", sourceErrorEvent.trigger));\n  });\n  watch([target, volume], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.volume = volume.value;\n  });\n  watch([target, muted], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.muted = muted.value;\n  });\n  watch([target, rate], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.playbackRate = rate.value;\n  });\n  watchEffect(() => {\n    if (!document)\n      return;\n    const textTracks = toValue(options.tracks);\n    const el = toValue(target);\n    if (!textTracks || !textTracks.length || !el)\n      return;\n    el.querySelectorAll(\"track\").forEach((e) => e.remove());\n    textTracks.forEach(({ default: isDefault, kind, label, src, srcLang }, i) => {\n      const track = document.createElement(\"track\");\n      track.default = isDefault || false;\n      track.kind = kind;\n      track.label = label;\n      track.src = src;\n      track.srclang = srcLang;\n      if (track.default)\n        selectedTrack.value = i;\n      el.appendChild(track);\n    });\n  });\n  const { ignoreUpdates: ignoreCurrentTimeUpdates } = watchIgnorable(currentTime, (time) => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.currentTime = time;\n  });\n  const { ignoreUpdates: ignorePlayingUpdates } = watchIgnorable(playing, (isPlaying) => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    isPlaying ? el.play() : el.pause();\n  });\n  useEventListener(target, \"timeupdate\", () => ignoreCurrentTimeUpdates(() => currentTime.value = toValue(target).currentTime));\n  useEventListener(target, \"durationchange\", () => duration.value = toValue(target).duration);\n  useEventListener(target, \"progress\", () => buffered.value = timeRangeToArray(toValue(target).buffered));\n  useEventListener(target, \"seeking\", () => seeking.value = true);\n  useEventListener(target, \"seeked\", () => seeking.value = false);\n  useEventListener(target, [\"waiting\", \"loadstart\"], () => {\n    waiting.value = true;\n    ignorePlayingUpdates(() => playing.value = false);\n  });\n  useEventListener(target, \"loadeddata\", () => waiting.value = false);\n  useEventListener(target, \"playing\", () => {\n    waiting.value = false;\n    ended.value = false;\n    ignorePlayingUpdates(() => playing.value = true);\n  });\n  useEventListener(target, \"ratechange\", () => rate.value = toValue(target).playbackRate);\n  useEventListener(target, \"stalled\", () => stalled.value = true);\n  useEventListener(target, \"ended\", () => ended.value = true);\n  useEventListener(target, \"pause\", () => ignorePlayingUpdates(() => playing.value = false));\n  useEventListener(target, \"play\", () => ignorePlayingUpdates(() => playing.value = true));\n  useEventListener(target, \"enterpictureinpicture\", () => isPictureInPicture.value = true);\n  useEventListener(target, \"leavepictureinpicture\", () => isPictureInPicture.value = false);\n  useEventListener(target, \"volumechange\", () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    volume.value = el.volume;\n    muted.value = el.muted;\n  });\n  const listeners = [];\n  const stop = watch([target], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    stop();\n    listeners[0] = useEventListener(el.textTracks, \"addtrack\", () => tracks.value = tracksToArray(el.textTracks));\n    listeners[1] = useEventListener(el.textTracks, \"removetrack\", () => tracks.value = tracksToArray(el.textTracks));\n    listeners[2] = useEventListener(el.textTracks, \"change\", () => tracks.value = tracksToArray(el.textTracks));\n  });\n  tryOnScopeDispose(() => listeners.forEach((listener) => listener()));\n  return {\n    currentTime,\n    duration,\n    waiting,\n    seeking,\n    ended,\n    stalled,\n    buffered,\n    playing,\n    rate,\n    // Volume\n    volume,\n    muted,\n    // Tracks\n    tracks,\n    selectedTrack,\n    enableTrack,\n    disableTrack,\n    // Picture in Picture\n    supportsPictureInPicture,\n    togglePictureInPicture,\n    isPictureInPicture,\n    // Events\n    onSourceError: sourceErrorEvent.on\n  };\n}\n\nfunction getMapVue2Compat() {\n  const data = reactive({});\n  return {\n    get: (key) => data[key],\n    set: (key, value) => set(data, key, value),\n    has: (key) => hasOwn(data, key),\n    delete: (key) => del(data, key),\n    clear: () => {\n      Object.keys(data).forEach((key) => {\n        del(data, key);\n      });\n    }\n  };\n}\nfunction useMemoize(resolver, options) {\n  const initCache = () => {\n    if (options == null ? void 0 : options.cache)\n      return reactive(options.cache);\n    if (isVue2)\n      return getMapVue2Compat();\n    return reactive(/* @__PURE__ */ new Map());\n  };\n  const cache = initCache();\n  const generateKey = (...args) => (options == null ? void 0 : options.getKey) ? options.getKey(...args) : JSON.stringify(args);\n  const _loadData = (key, ...args) => {\n    cache.set(key, resolver(...args));\n    return cache.get(key);\n  };\n  const loadData = (...args) => _loadData(generateKey(...args), ...args);\n  const deleteData = (...args) => {\n    cache.delete(generateKey(...args));\n  };\n  const clearData = () => {\n    cache.clear();\n  };\n  const memoized = (...args) => {\n    const key = generateKey(...args);\n    if (cache.has(key))\n      return cache.get(key);\n    return _loadData(key, ...args);\n  };\n  memoized.load = loadData;\n  memoized.delete = deleteData;\n  memoized.clear = clearData;\n  memoized.generateKey = generateKey;\n  memoized.cache = cache;\n  return memoized;\n}\n\nfunction useMemory(options = {}) {\n  const memory = ref();\n  const isSupported = useSupported(() => typeof performance !== \"undefined\" && \"memory\" in performance);\n  if (isSupported.value) {\n    const { interval = 1e3 } = options;\n    useIntervalFn(() => {\n      memory.value = performance.memory;\n    }, interval, { immediate: options.immediate, immediateCallback: options.immediateCallback });\n  }\n  return { isSupported, memory };\n}\n\nconst BuiltinExtractors = {\n  page: (event) => [event.pageX, event.pageY],\n  client: (event) => [event.clientX, event.clientY],\n  screen: (event) => [event.screenX, event.screenY],\n  movement: (event) => event instanceof Touch ? null : [event.movementX, event.movementY]\n};\nfunction useMouse(options = {}) {\n  const {\n    type = \"page\",\n    touch = true,\n    resetOnTouchEnds = false,\n    initialValue = { x: 0, y: 0 },\n    window = defaultWindow,\n    target = window,\n    eventFilter\n  } = options;\n  const x = ref(initialValue.x);\n  const y = ref(initialValue.y);\n  const sourceType = ref(null);\n  const extractor = typeof type === \"function\" ? type : BuiltinExtractors[type];\n  const mouseHandler = (event) => {\n    const result = extractor(event);\n    if (result) {\n      [x.value, y.value] = result;\n      sourceType.value = \"mouse\";\n    }\n  };\n  const touchHandler = (event) => {\n    if (event.touches.length > 0) {\n      const result = extractor(event.touches[0]);\n      if (result) {\n        [x.value, y.value] = result;\n        sourceType.value = \"touch\";\n      }\n    }\n  };\n  const reset = () => {\n    x.value = initialValue.x;\n    y.value = initialValue.y;\n  };\n  const mouseHandlerWrapper = eventFilter ? (event) => eventFilter(() => mouseHandler(event), {}) : (event) => mouseHandler(event);\n  const touchHandlerWrapper = eventFilter ? (event) => eventFilter(() => touchHandler(event), {}) : (event) => touchHandler(event);\n  if (target) {\n    useEventListener(target, \"mousemove\", mouseHandlerWrapper, { passive: true });\n    useEventListener(target, \"dragover\", mouseHandlerWrapper, { passive: true });\n    if (touch && type !== \"movement\") {\n      useEventListener(target, \"touchstart\", touchHandlerWrapper, { passive: true });\n      useEventListener(target, \"touchmove\", touchHandlerWrapper, { passive: true });\n      if (resetOnTouchEnds)\n        useEventListener(target, \"touchend\", reset, { passive: true });\n    }\n  }\n  return {\n    x,\n    y,\n    sourceType\n  };\n}\n\nfunction useMouseInElement(target, options = {}) {\n  const {\n    handleOutside = true,\n    window = defaultWindow\n  } = options;\n  const { x, y, sourceType } = useMouse(options);\n  const targetRef = ref(target != null ? target : window == null ? void 0 : window.document.body);\n  const elementX = ref(0);\n  const elementY = ref(0);\n  const elementPositionX = ref(0);\n  const elementPositionY = ref(0);\n  const elementHeight = ref(0);\n  const elementWidth = ref(0);\n  const isOutside = ref(true);\n  let stop = () => {\n  };\n  if (window) {\n    stop = watch(\n      [targetRef, x, y],\n      () => {\n        const el = unrefElement(targetRef);\n        if (!el)\n          return;\n        const {\n          left,\n          top,\n          width,\n          height\n        } = el.getBoundingClientRect();\n        elementPositionX.value = left + window.pageXOffset;\n        elementPositionY.value = top + window.pageYOffset;\n        elementHeight.value = height;\n        elementWidth.value = width;\n        const elX = x.value - elementPositionX.value;\n        const elY = y.value - elementPositionY.value;\n        isOutside.value = width === 0 || height === 0 || elX < 0 || elY < 0 || elX > width || elY > height;\n        if (handleOutside || !isOutside.value) {\n          elementX.value = elX;\n          elementY.value = elY;\n        }\n      },\n      { immediate: true }\n    );\n    useEventListener(document, \"mouseleave\", () => {\n      isOutside.value = true;\n    });\n  }\n  return {\n    x,\n    y,\n    sourceType,\n    elementX,\n    elementY,\n    elementPositionX,\n    elementPositionY,\n    elementHeight,\n    elementWidth,\n    isOutside,\n    stop\n  };\n}\n\nfunction useMousePressed(options = {}) {\n  const {\n    touch = true,\n    drag = true,\n    initialValue = false,\n    window = defaultWindow\n  } = options;\n  const pressed = ref(initialValue);\n  const sourceType = ref(null);\n  if (!window) {\n    return {\n      pressed,\n      sourceType\n    };\n  }\n  const onPressed = (srcType) => () => {\n    pressed.value = true;\n    sourceType.value = srcType;\n  };\n  const onReleased = () => {\n    pressed.value = false;\n    sourceType.value = null;\n  };\n  const target = computed(() => unrefElement(options.target) || window);\n  useEventListener(target, \"mousedown\", onPressed(\"mouse\"), { passive: true });\n  useEventListener(window, \"mouseleave\", onReleased, { passive: true });\n  useEventListener(window, \"mouseup\", onReleased, { passive: true });\n  if (drag) {\n    useEventListener(target, \"dragstart\", onPressed(\"mouse\"), { passive: true });\n    useEventListener(window, \"drop\", onReleased, { passive: true });\n    useEventListener(window, \"dragend\", onReleased, { passive: true });\n  }\n  if (touch) {\n    useEventListener(target, \"touchstart\", onPressed(\"touch\"), { passive: true });\n    useEventListener(window, \"touchend\", onReleased, { passive: true });\n    useEventListener(window, \"touchcancel\", onReleased, { passive: true });\n  }\n  return {\n    pressed,\n    sourceType\n  };\n}\n\nfunction useNavigatorLanguage(options = {}) {\n  const { window = defaultWindow } = options;\n  const navigator = window == null ? void 0 : window.navigator;\n  const isSupported = useSupported(() => navigator && \"language\" in navigator);\n  const language = ref(navigator == null ? void 0 : navigator.language);\n  useEventListener(window, \"languagechange\", () => {\n    if (navigator)\n      language.value = navigator.language;\n  });\n  return {\n    isSupported,\n    language\n  };\n}\n\nfunction useNetwork(options = {}) {\n  const { window = defaultWindow } = options;\n  const navigator = window == null ? void 0 : window.navigator;\n  const isSupported = useSupported(() => navigator && \"connection\" in navigator);\n  const isOnline = ref(true);\n  const saveData = ref(false);\n  const offlineAt = ref(void 0);\n  const onlineAt = ref(void 0);\n  const downlink = ref(void 0);\n  const downlinkMax = ref(void 0);\n  const rtt = ref(void 0);\n  const effectiveType = ref(void 0);\n  const type = ref(\"unknown\");\n  const connection = isSupported.value && navigator.connection;\n  function updateNetworkInformation() {\n    if (!navigator)\n      return;\n    isOnline.value = navigator.onLine;\n    offlineAt.value = isOnline.value ? void 0 : Date.now();\n    onlineAt.value = isOnline.value ? Date.now() : void 0;\n    if (connection) {\n      downlink.value = connection.downlink;\n      downlinkMax.value = connection.downlinkMax;\n      effectiveType.value = connection.effectiveType;\n      rtt.value = connection.rtt;\n      saveData.value = connection.saveData;\n      type.value = connection.type;\n    }\n  }\n  if (window) {\n    useEventListener(window, \"offline\", () => {\n      isOnline.value = false;\n      offlineAt.value = Date.now();\n    });\n    useEventListener(window, \"online\", () => {\n      isOnline.value = true;\n      onlineAt.value = Date.now();\n    });\n  }\n  if (connection)\n    useEventListener(connection, \"change\", updateNetworkInformation, false);\n  updateNetworkInformation();\n  return {\n    isSupported,\n    isOnline,\n    saveData,\n    offlineAt,\n    onlineAt,\n    downlink,\n    downlinkMax,\n    effectiveType,\n    rtt,\n    type\n  };\n}\n\nvar __defProp$7 = Object.defineProperty;\nvar __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$8 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$8 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$7 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$8.call(b, prop))\n      __defNormalProp$7(a, prop, b[prop]);\n  if (__getOwnPropSymbols$8)\n    for (var prop of __getOwnPropSymbols$8(b)) {\n      if (__propIsEnum$8.call(b, prop))\n        __defNormalProp$7(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useNow(options = {}) {\n  const {\n    controls: exposeControls = false,\n    interval = \"requestAnimationFrame\"\n  } = options;\n  const now = ref(/* @__PURE__ */ new Date());\n  const update = () => now.value = /* @__PURE__ */ new Date();\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(update, { immediate: true }) : useIntervalFn(update, interval, { immediate: true });\n  if (exposeControls) {\n    return __spreadValues$7({\n      now\n    }, controls);\n  } else {\n    return now;\n  }\n}\n\nfunction useObjectUrl(object) {\n  const url = ref();\n  const release = () => {\n    if (url.value)\n      URL.revokeObjectURL(url.value);\n    url.value = void 0;\n  };\n  watch(\n    () => toValue(object),\n    (newObject) => {\n      release();\n      if (newObject)\n        url.value = URL.createObjectURL(newObject);\n    },\n    { immediate: true }\n  );\n  tryOnScopeDispose(release);\n  return readonly(url);\n}\n\nfunction useClamp(value, min, max) {\n  if (typeof value === \"function\" || isReadonly(value))\n    return computed(() => clamp(toValue(value), toValue(min), toValue(max)));\n  const _value = ref(value);\n  return computed({\n    get() {\n      return _value.value = clamp(_value.value, toValue(min), toValue(max));\n    },\n    set(value2) {\n      _value.value = clamp(value2, toValue(min), toValue(max));\n    }\n  });\n}\n\nfunction useOffsetPagination(options) {\n  const {\n    total = Infinity,\n    pageSize = 10,\n    page = 1,\n    onPageChange = noop,\n    onPageSizeChange = noop,\n    onPageCountChange = noop\n  } = options;\n  const currentPageSize = useClamp(pageSize, 1, Infinity);\n  const pageCount = computed(() => Math.max(\n    1,\n    Math.ceil(toValue(total) / toValue(currentPageSize))\n  ));\n  const currentPage = useClamp(page, 1, pageCount);\n  const isFirstPage = computed(() => currentPage.value === 1);\n  const isLastPage = computed(() => currentPage.value === pageCount.value);\n  if (isRef(page))\n    syncRef(page, currentPage);\n  if (isRef(pageSize))\n    syncRef(pageSize, currentPageSize);\n  function prev() {\n    currentPage.value--;\n  }\n  function next() {\n    currentPage.value++;\n  }\n  const returnValue = {\n    currentPage,\n    currentPageSize,\n    pageCount,\n    isFirstPage,\n    isLastPage,\n    prev,\n    next\n  };\n  watch(currentPage, () => {\n    onPageChange(reactive(returnValue));\n  });\n  watch(currentPageSize, () => {\n    onPageSizeChange(reactive(returnValue));\n  });\n  watch(pageCount, () => {\n    onPageCountChange(reactive(returnValue));\n  });\n  return returnValue;\n}\n\nfunction useOnline(options = {}) {\n  const { isOnline } = useNetwork(options);\n  return isOnline;\n}\n\nfunction usePageLeave(options = {}) {\n  const { window = defaultWindow } = options;\n  const isLeft = ref(false);\n  const handler = (event) => {\n    if (!window)\n      return;\n    event = event || window.event;\n    const from = event.relatedTarget || event.toElement;\n    isLeft.value = !from;\n  };\n  if (window) {\n    useEventListener(window, \"mouseout\", handler, { passive: true });\n    useEventListener(window.document, \"mouseleave\", handler, { passive: true });\n    useEventListener(window.document, \"mouseenter\", handler, { passive: true });\n  }\n  return isLeft;\n}\n\nfunction useParallax(target, options = {}) {\n  const {\n    deviceOrientationTiltAdjust = (i) => i,\n    deviceOrientationRollAdjust = (i) => i,\n    mouseTiltAdjust = (i) => i,\n    mouseRollAdjust = (i) => i,\n    window = defaultWindow\n  } = options;\n  const orientation = reactive(useDeviceOrientation({ window }));\n  const {\n    elementX: x,\n    elementY: y,\n    elementWidth: width,\n    elementHeight: height\n  } = useMouseInElement(target, { handleOutside: false, window });\n  const source = computed(() => {\n    if (orientation.isSupported && (orientation.alpha != null && orientation.alpha !== 0 || orientation.gamma != null && orientation.gamma !== 0))\n      return \"deviceOrientation\";\n    return \"mouse\";\n  });\n  const roll = computed(() => {\n    if (source.value === \"deviceOrientation\") {\n      const value = -orientation.beta / 90;\n      return deviceOrientationRollAdjust(value);\n    } else {\n      const value = -(y.value - height.value / 2) / height.value;\n      return mouseRollAdjust(value);\n    }\n  });\n  const tilt = computed(() => {\n    if (source.value === \"deviceOrientation\") {\n      const value = orientation.gamma / 90;\n      return deviceOrientationTiltAdjust(value);\n    } else {\n      const value = (x.value - width.value / 2) / width.value;\n      return mouseTiltAdjust(value);\n    }\n  });\n  return { roll, tilt, source };\n}\n\nfunction useParentElement(element = useCurrentElement()) {\n  const parentElement = shallowRef();\n  const update = () => {\n    const el = unrefElement(element);\n    if (el)\n      parentElement.value = el.parentElement;\n  };\n  tryOnMounted(update);\n  watch(() => toValue(element), update);\n  return parentElement;\n}\n\nvar __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$7 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$7 = Object.prototype.propertyIsEnumerable;\nvar __objRest$1 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$7.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$7)\n    for (var prop of __getOwnPropSymbols$7(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$7.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction usePerformanceObserver(options, callback) {\n  const _a = options, {\n    window = defaultWindow,\n    immediate = true\n  } = _a, performanceOptions = __objRest$1(_a, [\n    \"window\",\n    \"immediate\"\n  ]);\n  const isSupported = useSupported(() => window && \"PerformanceObserver\" in window);\n  let observer;\n  const stop = () => {\n    observer == null ? void 0 : observer.disconnect();\n  };\n  const start = () => {\n    if (isSupported.value) {\n      stop();\n      observer = new PerformanceObserver(callback);\n      observer.observe(performanceOptions);\n    }\n  };\n  tryOnScopeDispose(stop);\n  if (immediate)\n    start();\n  return {\n    isSupported,\n    start,\n    stop\n  };\n}\n\nvar __defProp$6 = Object.defineProperty;\nvar __defProps$2 = Object.defineProperties;\nvar __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$6 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$6 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$6 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$6.call(b, prop))\n      __defNormalProp$6(a, prop, b[prop]);\n  if (__getOwnPropSymbols$6)\n    for (var prop of __getOwnPropSymbols$6(b)) {\n      if (__propIsEnum$6.call(b, prop))\n        __defNormalProp$6(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));\nconst defaultState = {\n  x: 0,\n  y: 0,\n  pointerId: 0,\n  pressure: 0,\n  tiltX: 0,\n  tiltY: 0,\n  width: 0,\n  height: 0,\n  twist: 0,\n  pointerType: null\n};\nconst keys = /* @__PURE__ */ Object.keys(defaultState);\nfunction usePointer(options = {}) {\n  const {\n    target = defaultWindow\n  } = options;\n  const isInside = ref(false);\n  const state = ref(options.initialValue || {});\n  Object.assign(state.value, defaultState, state.value);\n  const handler = (event) => {\n    isInside.value = true;\n    if (options.pointerTypes && !options.pointerTypes.includes(event.pointerType))\n      return;\n    state.value = objectPick(event, keys, false);\n  };\n  if (target) {\n    useEventListener(target, \"pointerdown\", handler, { passive: true });\n    useEventListener(target, \"pointermove\", handler, { passive: true });\n    useEventListener(target, \"pointerleave\", () => isInside.value = false, { passive: true });\n  }\n  return __spreadProps$2(__spreadValues$6({}, toRefs(state)), {\n    isInside\n  });\n}\n\nfunction usePointerLock(target, options = {}) {\n  const { document = defaultDocument, pointerLockOptions } = options;\n  const isSupported = useSupported(() => document && \"pointerLockElement\" in document);\n  const element = ref();\n  const triggerElement = ref();\n  let targetElement;\n  if (isSupported.value) {\n    useEventListener(document, \"pointerlockchange\", () => {\n      var _a;\n      const currentElement = (_a = document.pointerLockElement) != null ? _a : element.value;\n      if (targetElement && currentElement === targetElement) {\n        element.value = document.pointerLockElement;\n        if (!element.value)\n          targetElement = triggerElement.value = null;\n      }\n    });\n    useEventListener(document, \"pointerlockerror\", () => {\n      var _a;\n      const currentElement = (_a = document.pointerLockElement) != null ? _a : element.value;\n      if (targetElement && currentElement === targetElement) {\n        const action = document.pointerLockElement ? \"release\" : \"acquire\";\n        throw new Error(`Failed to ${action} pointer lock.`);\n      }\n    });\n  }\n  async function lock(e, options2) {\n    var _a;\n    if (!isSupported.value)\n      throw new Error(\"Pointer Lock API is not supported by your browser.\");\n    triggerElement.value = e instanceof Event ? e.currentTarget : null;\n    targetElement = e instanceof Event ? (_a = unrefElement(target)) != null ? _a : triggerElement.value : unrefElement(e);\n    if (!targetElement)\n      throw new Error(\"Target element undefined.\");\n    targetElement.requestPointerLock(options2 != null ? options2 : pointerLockOptions);\n    return await until(element).toBe(targetElement);\n  }\n  async function unlock() {\n    if (!element.value)\n      return false;\n    document.exitPointerLock();\n    await until(element).toBeNull();\n    return true;\n  }\n  return {\n    isSupported,\n    element,\n    triggerElement,\n    lock,\n    unlock\n  };\n}\n\nfunction usePointerSwipe(target, options = {}) {\n  const targetRef = toRef(target);\n  const {\n    threshold = 50,\n    onSwipe,\n    onSwipeEnd,\n    onSwipeStart\n  } = options;\n  const posStart = reactive({ x: 0, y: 0 });\n  const updatePosStart = (x, y) => {\n    posStart.x = x;\n    posStart.y = y;\n  };\n  const posEnd = reactive({ x: 0, y: 0 });\n  const updatePosEnd = (x, y) => {\n    posEnd.x = x;\n    posEnd.y = y;\n  };\n  const distanceX = computed(() => posStart.x - posEnd.x);\n  const distanceY = computed(() => posStart.y - posEnd.y);\n  const { max, abs } = Math;\n  const isThresholdExceeded = computed(() => max(abs(distanceX.value), abs(distanceY.value)) >= threshold);\n  const isSwiping = ref(false);\n  const isPointerDown = ref(false);\n  const direction = computed(() => {\n    if (!isThresholdExceeded.value)\n      return \"none\";\n    if (abs(distanceX.value) > abs(distanceY.value)) {\n      return distanceX.value > 0 ? \"left\" : \"right\";\n    } else {\n      return distanceY.value > 0 ? \"up\" : \"down\";\n    }\n  });\n  const eventIsAllowed = (e) => {\n    var _a, _b, _c;\n    const isReleasingButton = e.buttons === 0;\n    const isPrimaryButton = e.buttons === 1;\n    return (_c = (_b = (_a = options.pointerTypes) == null ? void 0 : _a.includes(e.pointerType)) != null ? _b : isReleasingButton || isPrimaryButton) != null ? _c : true;\n  };\n  const stops = [\n    useEventListener(target, \"pointerdown\", (e) => {\n      var _a, _b;\n      if (!eventIsAllowed(e))\n        return;\n      isPointerDown.value = true;\n      (_b = (_a = targetRef.value) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty(\"touch-action\", \"none\");\n      const eventTarget = e.target;\n      eventTarget == null ? void 0 : eventTarget.setPointerCapture(e.pointerId);\n      const { clientX: x, clientY: y } = e;\n      updatePosStart(x, y);\n      updatePosEnd(x, y);\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\n    }),\n    useEventListener(target, \"pointermove\", (e) => {\n      if (!eventIsAllowed(e))\n        return;\n      if (!isPointerDown.value)\n        return;\n      const { clientX: x, clientY: y } = e;\n      updatePosEnd(x, y);\n      if (!isSwiping.value && isThresholdExceeded.value)\n        isSwiping.value = true;\n      if (isSwiping.value)\n        onSwipe == null ? void 0 : onSwipe(e);\n    }),\n    useEventListener(target, \"pointerup\", (e) => {\n      var _a, _b;\n      if (!eventIsAllowed(e))\n        return;\n      if (isSwiping.value)\n        onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\n      isPointerDown.value = false;\n      isSwiping.value = false;\n      (_b = (_a = targetRef.value) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty(\"touch-action\", \"initial\");\n    })\n  ];\n  const stop = () => stops.forEach((s) => s());\n  return {\n    isSwiping: readonly(isSwiping),\n    direction: readonly(direction),\n    posStart: readonly(posStart),\n    posEnd: readonly(posEnd),\n    distanceX,\n    distanceY,\n    stop\n  };\n}\n\nfunction usePreferredColorScheme(options) {\n  const isLight = useMediaQuery(\"(prefers-color-scheme: light)\", options);\n  const isDark = useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n  return computed(() => {\n    if (isDark.value)\n      return \"dark\";\n    if (isLight.value)\n      return \"light\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePreferredContrast(options) {\n  const isMore = useMediaQuery(\"(prefers-contrast: more)\", options);\n  const isLess = useMediaQuery(\"(prefers-contrast: less)\", options);\n  const isCustom = useMediaQuery(\"(prefers-contrast: custom)\", options);\n  return computed(() => {\n    if (isMore.value)\n      return \"more\";\n    if (isLess.value)\n      return \"less\";\n    if (isCustom.value)\n      return \"custom\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePreferredLanguages(options = {}) {\n  const { window = defaultWindow } = options;\n  if (!window)\n    return ref([\"en\"]);\n  const navigator = window.navigator;\n  const value = ref(navigator.languages);\n  useEventListener(window, \"languagechange\", () => {\n    value.value = navigator.languages;\n  });\n  return value;\n}\n\nfunction usePreferredReducedMotion(options) {\n  const isReduced = useMediaQuery(\"(prefers-reduced-motion: reduce)\", options);\n  return computed(() => {\n    if (isReduced.value)\n      return \"reduce\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePrevious(value, initialValue) {\n  const previous = shallowRef(initialValue);\n  watch(\n    toRef(value),\n    (_, oldValue) => {\n      previous.value = oldValue;\n    },\n    { flush: \"sync\" }\n  );\n  return readonly(previous);\n}\n\nfunction useScreenOrientation(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const isSupported = useSupported(() => window && \"screen\" in window && \"orientation\" in window.screen);\n  const screenOrientation = isSupported.value ? window.screen.orientation : {};\n  const orientation = ref(screenOrientation.type);\n  const angle = ref(screenOrientation.angle || 0);\n  if (isSupported.value) {\n    useEventListener(window, \"orientationchange\", () => {\n      orientation.value = screenOrientation.type;\n      angle.value = screenOrientation.angle;\n    });\n  }\n  const lockOrientation = (type) => {\n    if (!isSupported.value)\n      return Promise.reject(new Error(\"Not supported\"));\n    return screenOrientation.lock(type);\n  };\n  const unlockOrientation = () => {\n    if (isSupported.value)\n      screenOrientation.unlock();\n  };\n  return {\n    isSupported,\n    orientation,\n    angle,\n    lockOrientation,\n    unlockOrientation\n  };\n}\n\nconst topVarName = \"--vueuse-safe-area-top\";\nconst rightVarName = \"--vueuse-safe-area-right\";\nconst bottomVarName = \"--vueuse-safe-area-bottom\";\nconst leftVarName = \"--vueuse-safe-area-left\";\nfunction useScreenSafeArea() {\n  const top = ref(\"\");\n  const right = ref(\"\");\n  const bottom = ref(\"\");\n  const left = ref(\"\");\n  if (isClient) {\n    const topCssVar = useCssVar(topVarName);\n    const rightCssVar = useCssVar(rightVarName);\n    const bottomCssVar = useCssVar(bottomVarName);\n    const leftCssVar = useCssVar(leftVarName);\n    topCssVar.value = \"env(safe-area-inset-top, 0px)\";\n    rightCssVar.value = \"env(safe-area-inset-right, 0px)\";\n    bottomCssVar.value = \"env(safe-area-inset-bottom, 0px)\";\n    leftCssVar.value = \"env(safe-area-inset-left, 0px)\";\n    update();\n    useEventListener(\"resize\", useDebounceFn(update));\n  }\n  function update() {\n    top.value = getValue(topVarName);\n    right.value = getValue(rightVarName);\n    bottom.value = getValue(bottomVarName);\n    left.value = getValue(leftVarName);\n  }\n  return {\n    top,\n    right,\n    bottom,\n    left,\n    update\n  };\n}\nfunction getValue(position) {\n  return getComputedStyle(document.documentElement).getPropertyValue(position);\n}\n\nfunction useScriptTag(src, onLoaded = noop, options = {}) {\n  const {\n    immediate = true,\n    manual = false,\n    type = \"text/javascript\",\n    async = true,\n    crossOrigin,\n    referrerPolicy,\n    noModule,\n    defer,\n    document = defaultDocument,\n    attrs = {}\n  } = options;\n  const scriptTag = ref(null);\n  let _promise = null;\n  const loadScript = (waitForScriptLoad) => new Promise((resolve, reject) => {\n    const resolveWithElement = (el2) => {\n      scriptTag.value = el2;\n      resolve(el2);\n      return el2;\n    };\n    if (!document) {\n      resolve(false);\n      return;\n    }\n    let shouldAppend = false;\n    let el = document.querySelector(`script[src=\"${toValue(src)}\"]`);\n    if (!el) {\n      el = document.createElement(\"script\");\n      el.type = type;\n      el.async = async;\n      el.src = toValue(src);\n      if (defer)\n        el.defer = defer;\n      if (crossOrigin)\n        el.crossOrigin = crossOrigin;\n      if (noModule)\n        el.noModule = noModule;\n      if (referrerPolicy)\n        el.referrerPolicy = referrerPolicy;\n      Object.entries(attrs).forEach(([name, value]) => el == null ? void 0 : el.setAttribute(name, value));\n      shouldAppend = true;\n    } else if (el.hasAttribute(\"data-loaded\")) {\n      resolveWithElement(el);\n    }\n    el.addEventListener(\"error\", (event) => reject(event));\n    el.addEventListener(\"abort\", (event) => reject(event));\n    el.addEventListener(\"load\", () => {\n      el.setAttribute(\"data-loaded\", \"true\");\n      onLoaded(el);\n      resolveWithElement(el);\n    });\n    if (shouldAppend)\n      el = document.head.appendChild(el);\n    if (!waitForScriptLoad)\n      resolveWithElement(el);\n  });\n  const load = (waitForScriptLoad = true) => {\n    if (!_promise)\n      _promise = loadScript(waitForScriptLoad);\n    return _promise;\n  };\n  const unload = () => {\n    if (!document)\n      return;\n    _promise = null;\n    if (scriptTag.value)\n      scriptTag.value = null;\n    const el = document.querySelector(`script[src=\"${toValue(src)}\"]`);\n    if (el)\n      document.head.removeChild(el);\n  };\n  if (immediate && !manual)\n    tryOnMounted(load);\n  if (!manual)\n    tryOnUnmounted(unload);\n  return { scriptTag, load, unload };\n}\n\nfunction checkOverflowScroll(ele) {\n  const style = window.getComputedStyle(ele);\n  if (style.overflowX === \"scroll\" || style.overflowY === \"scroll\" || style.overflowX === \"auto\" && ele.clientWidth < ele.scrollWidth || style.overflowY === \"auto\" && ele.clientHeight < ele.scrollHeight) {\n    return true;\n  } else {\n    const parent = ele.parentNode;\n    if (!parent || parent.tagName === \"BODY\")\n      return false;\n    return checkOverflowScroll(parent);\n  }\n}\nfunction preventDefault(rawEvent) {\n  const e = rawEvent || window.event;\n  const _target = e.target;\n  if (checkOverflowScroll(_target))\n    return false;\n  if (e.touches.length > 1)\n    return true;\n  if (e.preventDefault)\n    e.preventDefault();\n  return false;\n}\nfunction useScrollLock(element, initialState = false) {\n  const isLocked = ref(initialState);\n  let stopTouchMoveListener = null;\n  let initialOverflow;\n  watch(toRef(element), (el) => {\n    if (el) {\n      const ele = el;\n      initialOverflow = ele.style.overflow;\n      if (isLocked.value)\n        ele.style.overflow = \"hidden\";\n    }\n  }, {\n    immediate: true\n  });\n  const lock = () => {\n    const ele = toValue(element);\n    if (!ele || isLocked.value)\n      return;\n    if (isIOS) {\n      stopTouchMoveListener = useEventListener(\n        ele,\n        \"touchmove\",\n        (e) => {\n          preventDefault(e);\n        },\n        { passive: false }\n      );\n    }\n    ele.style.overflow = \"hidden\";\n    isLocked.value = true;\n  };\n  const unlock = () => {\n    const ele = toValue(element);\n    if (!ele || !isLocked.value)\n      return;\n    isIOS && (stopTouchMoveListener == null ? void 0 : stopTouchMoveListener());\n    ele.style.overflow = initialOverflow;\n    isLocked.value = false;\n  };\n  tryOnScopeDispose(unlock);\n  return computed({\n    get() {\n      return isLocked.value;\n    },\n    set(v) {\n      if (v)\n        lock();\n      else\n        unlock();\n    }\n  });\n}\n\nfunction useSessionStorage(key, initialValue, options = {}) {\n  const { window = defaultWindow } = options;\n  return useStorage(key, initialValue, window == null ? void 0 : window.sessionStorage, options);\n}\n\nvar __defProp$5 = Object.defineProperty;\nvar __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$5 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$5 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$5 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$5.call(b, prop))\n      __defNormalProp$5(a, prop, b[prop]);\n  if (__getOwnPropSymbols$5)\n    for (var prop of __getOwnPropSymbols$5(b)) {\n      if (__propIsEnum$5.call(b, prop))\n        __defNormalProp$5(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useShare(shareOptions = {}, options = {}) {\n  const { navigator = defaultNavigator } = options;\n  const _navigator = navigator;\n  const isSupported = useSupported(() => _navigator && \"canShare\" in _navigator);\n  const share = async (overrideOptions = {}) => {\n    if (isSupported.value) {\n      const data = __spreadValues$5(__spreadValues$5({}, toValue(shareOptions)), toValue(overrideOptions));\n      let granted = true;\n      if (data.files && _navigator.canShare)\n        granted = _navigator.canShare({ files: data.files });\n      if (granted)\n        return _navigator.share(data);\n    }\n  };\n  return {\n    isSupported,\n    share\n  };\n}\n\nconst defaultSortFn = (source, compareFn) => source.sort(compareFn);\nconst defaultCompare = (a, b) => a - b;\nfunction useSorted(...args) {\n  var _a, _b, _c, _d;\n  const [source] = args;\n  let compareFn = defaultCompare;\n  let options = {};\n  if (args.length === 2) {\n    if (typeof args[1] === \"object\") {\n      options = args[1];\n      compareFn = (_a = options.compareFn) != null ? _a : defaultCompare;\n    } else {\n      compareFn = (_b = args[1]) != null ? _b : defaultCompare;\n    }\n  } else if (args.length > 2) {\n    compareFn = (_c = args[1]) != null ? _c : defaultCompare;\n    options = (_d = args[2]) != null ? _d : {};\n  }\n  const {\n    dirty = false,\n    sortFn = defaultSortFn\n  } = options;\n  if (!dirty)\n    return computed(() => sortFn([...toValue(source)], compareFn));\n  watchEffect(() => {\n    const result = sortFn(toValue(source), compareFn);\n    if (isRef(source))\n      source.value = result;\n    else\n      source.splice(0, source.length, ...result);\n  });\n  return source;\n}\n\nfunction useSpeechRecognition(options = {}) {\n  const {\n    interimResults = true,\n    continuous = true,\n    window = defaultWindow\n  } = options;\n  const lang = toRef(options.lang || \"en-US\");\n  const isListening = ref(false);\n  const isFinal = ref(false);\n  const result = ref(\"\");\n  const error = shallowRef(void 0);\n  const toggle = (value = !isListening.value) => {\n    isListening.value = value;\n  };\n  const start = () => {\n    isListening.value = true;\n  };\n  const stop = () => {\n    isListening.value = false;\n  };\n  const SpeechRecognition = window && (window.SpeechRecognition || window.webkitSpeechRecognition);\n  const isSupported = useSupported(() => SpeechRecognition);\n  let recognition;\n  if (isSupported.value) {\n    recognition = new SpeechRecognition();\n    recognition.continuous = continuous;\n    recognition.interimResults = interimResults;\n    recognition.lang = toValue(lang);\n    recognition.onstart = () => {\n      isFinal.value = false;\n    };\n    watch(lang, (lang2) => {\n      if (recognition && !isListening.value)\n        recognition.lang = lang2;\n    });\n    recognition.onresult = (event) => {\n      const transcript = Array.from(event.results).map((result2) => {\n        isFinal.value = result2.isFinal;\n        return result2[0];\n      }).map((result2) => result2.transcript).join(\"\");\n      result.value = transcript;\n      error.value = void 0;\n    };\n    recognition.onerror = (event) => {\n      error.value = event;\n    };\n    recognition.onend = () => {\n      isListening.value = false;\n      recognition.lang = toValue(lang);\n    };\n    watch(isListening, () => {\n      if (isListening.value)\n        recognition.start();\n      else\n        recognition.stop();\n    });\n  }\n  tryOnScopeDispose(() => {\n    isListening.value = false;\n  });\n  return {\n    isSupported,\n    isListening,\n    isFinal,\n    recognition,\n    result,\n    error,\n    toggle,\n    start,\n    stop\n  };\n}\n\nfunction useSpeechSynthesis(text, options = {}) {\n  const {\n    pitch = 1,\n    rate = 1,\n    volume = 1,\n    window = defaultWindow\n  } = options;\n  const synth = window && window.speechSynthesis;\n  const isSupported = useSupported(() => synth);\n  const isPlaying = ref(false);\n  const status = ref(\"init\");\n  const spokenText = toRef(text || \"\");\n  const lang = toRef(options.lang || \"en-US\");\n  const error = shallowRef(void 0);\n  const toggle = (value = !isPlaying.value) => {\n    isPlaying.value = value;\n  };\n  const bindEventsForUtterance = (utterance2) => {\n    utterance2.lang = toValue(lang);\n    utterance2.voice = toValue(options.voice) || null;\n    utterance2.pitch = pitch;\n    utterance2.rate = rate;\n    utterance2.volume = volume;\n    utterance2.onstart = () => {\n      isPlaying.value = true;\n      status.value = \"play\";\n    };\n    utterance2.onpause = () => {\n      isPlaying.value = false;\n      status.value = \"pause\";\n    };\n    utterance2.onresume = () => {\n      isPlaying.value = true;\n      status.value = \"play\";\n    };\n    utterance2.onend = () => {\n      isPlaying.value = false;\n      status.value = \"end\";\n    };\n    utterance2.onerror = (event) => {\n      error.value = event;\n    };\n  };\n  const utterance = computed(() => {\n    isPlaying.value = false;\n    status.value = \"init\";\n    const newUtterance = new SpeechSynthesisUtterance(spokenText.value);\n    bindEventsForUtterance(newUtterance);\n    return newUtterance;\n  });\n  const speak = () => {\n    synth.cancel();\n    utterance && synth.speak(utterance.value);\n  };\n  const stop = () => {\n    synth.cancel();\n    isPlaying.value = false;\n  };\n  if (isSupported.value) {\n    bindEventsForUtterance(utterance.value);\n    watch(lang, (lang2) => {\n      if (utterance.value && !isPlaying.value)\n        utterance.value.lang = lang2;\n    });\n    if (options.voice) {\n      watch(options.voice, () => {\n        synth.cancel();\n      });\n    }\n    watch(isPlaying, () => {\n      if (isPlaying.value)\n        synth.resume();\n      else\n        synth.pause();\n    });\n  }\n  tryOnScopeDispose(() => {\n    isPlaying.value = false;\n  });\n  return {\n    isSupported,\n    isPlaying,\n    status,\n    utterance,\n    error,\n    stop,\n    toggle,\n    speak\n  };\n}\n\nfunction useStepper(steps, initialStep) {\n  const stepsRef = ref(steps);\n  const stepNames = computed(() => Array.isArray(stepsRef.value) ? stepsRef.value : Object.keys(stepsRef.value));\n  const index = ref(stepNames.value.indexOf(initialStep != null ? initialStep : stepNames.value[0]));\n  const current = computed(() => at(index.value));\n  const isFirst = computed(() => index.value === 0);\n  const isLast = computed(() => index.value === stepNames.value.length - 1);\n  const next = computed(() => stepNames.value[index.value + 1]);\n  const previous = computed(() => stepNames.value[index.value - 1]);\n  function at(index2) {\n    if (Array.isArray(stepsRef.value))\n      return stepsRef.value[index2];\n    return stepsRef.value[stepNames.value[index2]];\n  }\n  function get(step) {\n    if (!stepNames.value.includes(step))\n      return;\n    return at(stepNames.value.indexOf(step));\n  }\n  function goTo(step) {\n    if (stepNames.value.includes(step))\n      index.value = stepNames.value.indexOf(step);\n  }\n  function goToNext() {\n    if (isLast.value)\n      return;\n    index.value++;\n  }\n  function goToPrevious() {\n    if (isFirst.value)\n      return;\n    index.value--;\n  }\n  function goBackTo(step) {\n    if (isAfter(step))\n      goTo(step);\n  }\n  function isNext(step) {\n    return stepNames.value.indexOf(step) === index.value + 1;\n  }\n  function isPrevious(step) {\n    return stepNames.value.indexOf(step) === index.value - 1;\n  }\n  function isCurrent(step) {\n    return stepNames.value.indexOf(step) === index.value;\n  }\n  function isBefore(step) {\n    return index.value < stepNames.value.indexOf(step);\n  }\n  function isAfter(step) {\n    return index.value > stepNames.value.indexOf(step);\n  }\n  return {\n    steps: stepsRef,\n    stepNames,\n    index,\n    current,\n    next,\n    previous,\n    isFirst,\n    isLast,\n    at,\n    get,\n    goTo,\n    goToNext,\n    goToPrevious,\n    goBackTo,\n    isNext,\n    isPrevious,\n    isCurrent,\n    isBefore,\n    isAfter\n  };\n}\n\nvar __defProp$4 = Object.defineProperty;\nvar __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$4 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$4 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$4 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$4.call(b, prop))\n      __defNormalProp$4(a, prop, b[prop]);\n  if (__getOwnPropSymbols$4)\n    for (var prop of __getOwnPropSymbols$4(b)) {\n      if (__propIsEnum$4.call(b, prop))\n        __defNormalProp$4(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useStorageAsync(key, initialValue, storage, options = {}) {\n  var _a;\n  const {\n    flush = \"pre\",\n    deep = true,\n    listenToStorageChanges = true,\n    writeDefaults = true,\n    mergeDefaults = false,\n    shallow,\n    window = defaultWindow,\n    eventFilter,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = options;\n  const rawInit = toValue(initialValue);\n  const type = guessSerializerType(rawInit);\n  const data = (shallow ? shallowRef : ref)(initialValue);\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\n  if (!storage) {\n    try {\n      storage = getSSRHandler(\"getDefaultStorage\", () => {\n        var _a2;\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\n      })();\n    } catch (e) {\n      onError(e);\n    }\n  }\n  async function read(event) {\n    if (!storage || event && event.key !== key)\n      return;\n    try {\n      const rawValue = event ? event.newValue : await storage.getItem(key);\n      if (rawValue == null) {\n        data.value = rawInit;\n        if (writeDefaults && rawInit !== null)\n          await storage.setItem(key, await serializer.write(rawInit));\n      } else if (mergeDefaults) {\n        const value = await serializer.read(rawValue);\n        if (typeof mergeDefaults === \"function\")\n          data.value = mergeDefaults(value, rawInit);\n        else if (type === \"object\" && !Array.isArray(value))\n          data.value = __spreadValues$4(__spreadValues$4({}, rawInit), value);\n        else\n          data.value = value;\n      } else {\n        data.value = await serializer.read(rawValue);\n      }\n    } catch (e) {\n      onError(e);\n    }\n  }\n  read();\n  if (window && listenToStorageChanges)\n    useEventListener(window, \"storage\", (e) => Promise.resolve().then(() => read(e)));\n  if (storage) {\n    watchWithFilter(\n      data,\n      async () => {\n        try {\n          if (data.value == null)\n            await storage.removeItem(key);\n          else\n            await storage.setItem(key, await serializer.write(data.value));\n        } catch (e) {\n          onError(e);\n        }\n      },\n      {\n        flush,\n        deep,\n        eventFilter\n      }\n    );\n  }\n  return data;\n}\n\nlet _id = 0;\nfunction useStyleTag(css, options = {}) {\n  const isLoaded = ref(false);\n  const {\n    document = defaultDocument,\n    immediate = true,\n    manual = false,\n    id = `vueuse_styletag_${++_id}`\n  } = options;\n  const cssRef = ref(css);\n  let stop = () => {\n  };\n  const load = () => {\n    if (!document)\n      return;\n    const el = document.getElementById(id) || document.createElement(\"style\");\n    if (!el.isConnected) {\n      el.type = \"text/css\";\n      el.id = id;\n      if (options.media)\n        el.media = options.media;\n      document.head.appendChild(el);\n    }\n    if (isLoaded.value)\n      return;\n    stop = watch(\n      cssRef,\n      (value) => {\n        el.textContent = value;\n      },\n      { immediate: true }\n    );\n    isLoaded.value = true;\n  };\n  const unload = () => {\n    if (!document || !isLoaded.value)\n      return;\n    stop();\n    document.head.removeChild(document.getElementById(id));\n    isLoaded.value = false;\n  };\n  if (immediate && !manual)\n    tryOnMounted(load);\n  if (!manual)\n    tryOnScopeDispose(unload);\n  return {\n    id,\n    css: cssRef,\n    unload,\n    load,\n    isLoaded: readonly(isLoaded)\n  };\n}\n\nfunction useSwipe(target, options = {}) {\n  const {\n    threshold = 50,\n    onSwipe,\n    onSwipeEnd,\n    onSwipeStart,\n    passive = true,\n    window = defaultWindow\n  } = options;\n  const coordsStart = reactive({ x: 0, y: 0 });\n  const coordsEnd = reactive({ x: 0, y: 0 });\n  const diffX = computed(() => coordsStart.x - coordsEnd.x);\n  const diffY = computed(() => coordsStart.y - coordsEnd.y);\n  const { max, abs } = Math;\n  const isThresholdExceeded = computed(() => max(abs(diffX.value), abs(diffY.value)) >= threshold);\n  const isSwiping = ref(false);\n  const direction = computed(() => {\n    if (!isThresholdExceeded.value)\n      return \"none\";\n    if (abs(diffX.value) > abs(diffY.value)) {\n      return diffX.value > 0 ? \"left\" : \"right\";\n    } else {\n      return diffY.value > 0 ? \"up\" : \"down\";\n    }\n  });\n  const getTouchEventCoords = (e) => [e.touches[0].clientX, e.touches[0].clientY];\n  const updateCoordsStart = (x, y) => {\n    coordsStart.x = x;\n    coordsStart.y = y;\n  };\n  const updateCoordsEnd = (x, y) => {\n    coordsEnd.x = x;\n    coordsEnd.y = y;\n  };\n  let listenerOptions;\n  const isPassiveEventSupported = checkPassiveEventSupport(window == null ? void 0 : window.document);\n  if (!passive)\n    listenerOptions = isPassiveEventSupported ? { passive: false, capture: true } : { capture: true };\n  else\n    listenerOptions = isPassiveEventSupported ? { passive: true } : { capture: false };\n  const onTouchEnd = (e) => {\n    if (isSwiping.value)\n      onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\n    isSwiping.value = false;\n  };\n  const stops = [\n    useEventListener(target, \"touchstart\", (e) => {\n      if (e.touches.length !== 1)\n        return;\n      if (listenerOptions.capture && !listenerOptions.passive)\n        e.preventDefault();\n      const [x, y] = getTouchEventCoords(e);\n      updateCoordsStart(x, y);\n      updateCoordsEnd(x, y);\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\n    }, listenerOptions),\n    useEventListener(target, \"touchmove\", (e) => {\n      if (e.touches.length !== 1)\n        return;\n      const [x, y] = getTouchEventCoords(e);\n      updateCoordsEnd(x, y);\n      if (!isSwiping.value && isThresholdExceeded.value)\n        isSwiping.value = true;\n      if (isSwiping.value)\n        onSwipe == null ? void 0 : onSwipe(e);\n    }, listenerOptions),\n    useEventListener(target, \"touchend\", onTouchEnd, listenerOptions),\n    useEventListener(target, \"touchcancel\", onTouchEnd, listenerOptions)\n  ];\n  const stop = () => stops.forEach((s) => s());\n  return {\n    isPassiveEventSupported,\n    isSwiping,\n    direction,\n    coordsStart,\n    coordsEnd,\n    lengthX: diffX,\n    lengthY: diffY,\n    stop\n  };\n}\nfunction checkPassiveEventSupport(document) {\n  if (!document)\n    return false;\n  let supportsPassive = false;\n  const optionsBlock = {\n    get passive() {\n      supportsPassive = true;\n      return false;\n    }\n  };\n  document.addEventListener(\"x\", noop, optionsBlock);\n  document.removeEventListener(\"x\", noop);\n  return supportsPassive;\n}\n\nfunction useTemplateRefsList() {\n  const refs = ref([]);\n  refs.value.set = (el) => {\n    if (el)\n      refs.value.push(el);\n  };\n  onBeforeUpdate(() => {\n    refs.value.length = 0;\n  });\n  return refs;\n}\n\nfunction useTextDirection(options = {}) {\n  const {\n    document = defaultDocument,\n    selector = \"html\",\n    observe = false,\n    initialValue = \"ltr\"\n  } = options;\n  function getValue() {\n    var _a, _b;\n    return (_b = (_a = document == null ? void 0 : document.querySelector(selector)) == null ? void 0 : _a.getAttribute(\"dir\")) != null ? _b : initialValue;\n  }\n  const dir = ref(getValue());\n  tryOnMounted(() => dir.value = getValue());\n  if (observe && document) {\n    useMutationObserver(\n      document.querySelector(selector),\n      () => dir.value = getValue(),\n      { attributes: true }\n    );\n  }\n  return computed({\n    get() {\n      return dir.value;\n    },\n    set(v) {\n      var _a, _b;\n      dir.value = v;\n      if (!document)\n        return;\n      if (dir.value)\n        (_a = document.querySelector(selector)) == null ? void 0 : _a.setAttribute(\"dir\", dir.value);\n      else\n        (_b = document.querySelector(selector)) == null ? void 0 : _b.removeAttribute(\"dir\");\n    }\n  });\n}\n\nfunction getRangesFromSelection(selection) {\n  var _a;\n  const rangeCount = (_a = selection.rangeCount) != null ? _a : 0;\n  const ranges = new Array(rangeCount);\n  for (let i = 0; i < rangeCount; i++) {\n    const range = selection.getRangeAt(i);\n    ranges[i] = range;\n  }\n  return ranges;\n}\nfunction useTextSelection(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const selection = ref(null);\n  const text = computed(() => {\n    var _a, _b;\n    return (_b = (_a = selection.value) == null ? void 0 : _a.toString()) != null ? _b : \"\";\n  });\n  const ranges = computed(() => selection.value ? getRangesFromSelection(selection.value) : []);\n  const rects = computed(() => ranges.value.map((range) => range.getBoundingClientRect()));\n  function onSelectionChange() {\n    selection.value = null;\n    if (window)\n      selection.value = window.getSelection();\n  }\n  if (window)\n    useEventListener(window.document, \"selectionchange\", onSelectionChange);\n  return {\n    text,\n    rects,\n    ranges,\n    selection\n  };\n}\n\nfunction useTextareaAutosize(options) {\n  const textarea = ref(options == null ? void 0 : options.element);\n  const input = ref(options == null ? void 0 : options.input);\n  const textareaScrollHeight = ref(1);\n  function triggerResize() {\n    var _a, _b;\n    if (!textarea.value)\n      return;\n    let height = \"\";\n    textarea.value.style.height = \"1px\";\n    textareaScrollHeight.value = (_a = textarea.value) == null ? void 0 : _a.scrollHeight;\n    if (options == null ? void 0 : options.styleTarget)\n      toValue(options.styleTarget).style.height = `${textareaScrollHeight.value}px`;\n    else\n      height = `${textareaScrollHeight.value}px`;\n    textarea.value.style.height = height;\n    (_b = options == null ? void 0 : options.onResize) == null ? void 0 : _b.call(options);\n  }\n  watch([input, textarea], () => nextTick(triggerResize), { immediate: true });\n  useResizeObserver(textarea, () => triggerResize());\n  if (options == null ? void 0 : options.watch)\n    watch(options.watch, triggerResize, { immediate: true, deep: true });\n  return {\n    textarea,\n    input,\n    triggerResize\n  };\n}\n\nvar __defProp$3 = Object.defineProperty;\nvar __defProps$1 = Object.defineProperties;\nvar __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$3 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$3 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$3 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$3.call(b, prop))\n      __defNormalProp$3(a, prop, b[prop]);\n  if (__getOwnPropSymbols$3)\n    for (var prop of __getOwnPropSymbols$3(b)) {\n      if (__propIsEnum$3.call(b, prop))\n        __defNormalProp$3(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\nfunction useThrottledRefHistory(source, options = {}) {\n  const { throttle = 200, trailing = true } = options;\n  const filter = throttleFilter(throttle, trailing);\n  const history = useRefHistory(source, __spreadProps$1(__spreadValues$3({}, options), { eventFilter: filter }));\n  return __spreadValues$3({}, history);\n}\n\nvar __defProp$2 = Object.defineProperty;\nvar __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$2 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$2 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$2.call(b, prop))\n      __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(b)) {\n      if (__propIsEnum$2.call(b, prop))\n        __defNormalProp$2(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$2.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$2.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nconst DEFAULT_UNITS = [\n  { max: 6e4, value: 1e3, name: \"second\" },\n  { max: 276e4, value: 6e4, name: \"minute\" },\n  { max: 72e6, value: 36e5, name: \"hour\" },\n  { max: 5184e5, value: 864e5, name: \"day\" },\n  { max: 24192e5, value: 6048e5, name: \"week\" },\n  { max: 28512e6, value: 2592e6, name: \"month\" },\n  { max: Infinity, value: 31536e6, name: \"year\" }\n];\nconst DEFAULT_MESSAGES = {\n  justNow: \"just now\",\n  past: (n) => n.match(/\\d/) ? `${n} ago` : n,\n  future: (n) => n.match(/\\d/) ? `in ${n}` : n,\n  month: (n, past) => n === 1 ? past ? \"last month\" : \"next month\" : `${n} month${n > 1 ? \"s\" : \"\"}`,\n  year: (n, past) => n === 1 ? past ? \"last year\" : \"next year\" : `${n} year${n > 1 ? \"s\" : \"\"}`,\n  day: (n, past) => n === 1 ? past ? \"yesterday\" : \"tomorrow\" : `${n} day${n > 1 ? \"s\" : \"\"}`,\n  week: (n, past) => n === 1 ? past ? \"last week\" : \"next week\" : `${n} week${n > 1 ? \"s\" : \"\"}`,\n  hour: (n) => `${n} hour${n > 1 ? \"s\" : \"\"}`,\n  minute: (n) => `${n} minute${n > 1 ? \"s\" : \"\"}`,\n  second: (n) => `${n} second${n > 1 ? \"s\" : \"\"}`,\n  invalid: \"\"\n};\nfunction DEFAULT_FORMATTER(date) {\n  return date.toISOString().slice(0, 10);\n}\nfunction useTimeAgo(time, options = {}) {\n  const {\n    controls: exposeControls = false,\n    updateInterval = 3e4\n  } = options;\n  const _a = useNow({ interval: updateInterval, controls: true }), { now } = _a, controls = __objRest(_a, [\"now\"]);\n  const timeAgo = computed(() => formatTimeAgo(new Date(toValue(time)), options, toValue(now)));\n  if (exposeControls) {\n    return __spreadValues$2({\n      timeAgo\n    }, controls);\n  } else {\n    return timeAgo;\n  }\n}\nfunction formatTimeAgo(from, options = {}, now = Date.now()) {\n  var _a;\n  const {\n    max,\n    messages = DEFAULT_MESSAGES,\n    fullDateFormatter = DEFAULT_FORMATTER,\n    units = DEFAULT_UNITS,\n    showSecond = false,\n    rounding = \"round\"\n  } = options;\n  const roundFn = typeof rounding === \"number\" ? (n) => +n.toFixed(rounding) : Math[rounding];\n  const diff = +now - +from;\n  const absDiff = Math.abs(diff);\n  function getValue(diff2, unit) {\n    return roundFn(Math.abs(diff2) / unit.value);\n  }\n  function format(diff2, unit) {\n    const val = getValue(diff2, unit);\n    const past = diff2 > 0;\n    const str = applyFormat(unit.name, val, past);\n    return applyFormat(past ? \"past\" : \"future\", str, past);\n  }\n  function applyFormat(name, val, isPast) {\n    const formatter = messages[name];\n    if (typeof formatter === \"function\")\n      return formatter(val, isPast);\n    return formatter.replace(\"{0}\", val.toString());\n  }\n  if (absDiff < 6e4 && !showSecond)\n    return messages.justNow;\n  if (typeof max === \"number\" && absDiff > max)\n    return fullDateFormatter(new Date(from));\n  if (typeof max === \"string\") {\n    const unitMax = (_a = units.find((i) => i.name === max)) == null ? void 0 : _a.max;\n    if (unitMax && absDiff > unitMax)\n      return fullDateFormatter(new Date(from));\n  }\n  for (const [idx, unit] of units.entries()) {\n    const val = getValue(diff, unit);\n    if (val <= 0 && units[idx - 1])\n      return format(diff, units[idx - 1]);\n    if (absDiff < unit.max)\n      return format(diff, unit);\n  }\n  return messages.invalid;\n}\n\nfunction useTimeoutPoll(fn, interval, timeoutPollOptions) {\n  const { start } = useTimeoutFn(loop, interval);\n  const isActive = ref(false);\n  async function loop() {\n    if (!isActive.value)\n      return;\n    await fn();\n    start();\n  }\n  function resume() {\n    if (!isActive.value) {\n      isActive.value = true;\n      loop();\n    }\n  }\n  function pause() {\n    isActive.value = false;\n  }\n  if (timeoutPollOptions == null ? void 0 : timeoutPollOptions.immediate)\n    resume();\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nvar __defProp$1 = Object.defineProperty;\nvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$1.call(b, prop))\n      __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(b)) {\n      if (__propIsEnum$1.call(b, prop))\n        __defNormalProp$1(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useTimestamp(options = {}) {\n  const {\n    controls: exposeControls = false,\n    offset = 0,\n    immediate = true,\n    interval = \"requestAnimationFrame\",\n    callback\n  } = options;\n  const ts = ref(timestamp() + offset);\n  const update = () => ts.value = timestamp() + offset;\n  const cb = callback ? () => {\n    update();\n    callback(ts.value);\n  } : update;\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });\n  if (exposeControls) {\n    return __spreadValues$1({\n      timestamp: ts\n    }, controls);\n  } else {\n    return ts;\n  }\n}\n\nfunction useTitle(newTitle = null, options = {}) {\n  var _a, _b;\n  const {\n    document = defaultDocument\n  } = options;\n  const title = toRef((_a = newTitle != null ? newTitle : document == null ? void 0 : document.title) != null ? _a : null);\n  const isReadonly = newTitle && typeof newTitle === \"function\";\n  function format(t) {\n    if (!(\"titleTemplate\" in options))\n      return t;\n    const template = options.titleTemplate || \"%s\";\n    return typeof template === \"function\" ? template(t) : toValue(template).replace(/%s/g, t);\n  }\n  watch(\n    title,\n    (t, o) => {\n      if (t !== o && document)\n        document.title = format(typeof t === \"string\" ? t : \"\");\n    },\n    { immediate: true }\n  );\n  if (options.observe && !options.titleTemplate && document && !isReadonly) {\n    useMutationObserver(\n      (_b = document.head) == null ? void 0 : _b.querySelector(\"title\"),\n      () => {\n        if (document && document.title !== title.value)\n          title.value = format(document.title);\n      },\n      { childList: true }\n    );\n  }\n  return title;\n}\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst _TransitionPresets = {\n  easeInSine: [0.12, 0, 0.39, 0],\n  easeOutSine: [0.61, 1, 0.88, 1],\n  easeInOutSine: [0.37, 0, 0.63, 1],\n  easeInQuad: [0.11, 0, 0.5, 0],\n  easeOutQuad: [0.5, 1, 0.89, 1],\n  easeInOutQuad: [0.45, 0, 0.55, 1],\n  easeInCubic: [0.32, 0, 0.67, 0],\n  easeOutCubic: [0.33, 1, 0.68, 1],\n  easeInOutCubic: [0.65, 0, 0.35, 1],\n  easeInQuart: [0.5, 0, 0.75, 0],\n  easeOutQuart: [0.25, 1, 0.5, 1],\n  easeInOutQuart: [0.76, 0, 0.24, 1],\n  easeInQuint: [0.64, 0, 0.78, 0],\n  easeOutQuint: [0.22, 1, 0.36, 1],\n  easeInOutQuint: [0.83, 0, 0.17, 1],\n  easeInExpo: [0.7, 0, 0.84, 0],\n  easeOutExpo: [0.16, 1, 0.3, 1],\n  easeInOutExpo: [0.87, 0, 0.13, 1],\n  easeInCirc: [0.55, 0, 1, 0.45],\n  easeOutCirc: [0, 0.55, 0.45, 1],\n  easeInOutCirc: [0.85, 0, 0.15, 1],\n  easeInBack: [0.36, 0, 0.66, -0.56],\n  easeOutBack: [0.34, 1.56, 0.64, 1],\n  easeInOutBack: [0.68, -0.6, 0.32, 1.6]\n};\nconst TransitionPresets = /* @__PURE__ */ Object.assign({}, { linear: identity }, _TransitionPresets);\nfunction createEasingFunction([p0, p1, p2, p3]) {\n  const a = (a1, a2) => 1 - 3 * a2 + 3 * a1;\n  const b = (a1, a2) => 3 * a2 - 6 * a1;\n  const c = (a1) => 3 * a1;\n  const calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\n  const getSlope = (t, a1, a2) => 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1);\n  const getTforX = (x) => {\n    let aGuessT = x;\n    for (let i = 0; i < 4; ++i) {\n      const currentSlope = getSlope(aGuessT, p0, p2);\n      if (currentSlope === 0)\n        return aGuessT;\n      const currentX = calcBezier(aGuessT, p0, p2) - x;\n      aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n  };\n  return (x) => p0 === p1 && p2 === p3 ? x : calcBezier(getTforX(x), p1, p3);\n}\nfunction lerp(a, b, alpha) {\n  return a + alpha * (b - a);\n}\nfunction toVec(t) {\n  return (typeof t === \"number\" ? [t] : t) || [];\n}\nfunction executeTransition(source, from, to, options = {}) {\n  var _a, _b;\n  const fromVal = toValue(from);\n  const toVal = toValue(to);\n  const v1 = toVec(fromVal);\n  const v2 = toVec(toVal);\n  const duration = (_a = toValue(options.duration)) != null ? _a : 1e3;\n  const startedAt = Date.now();\n  const endAt = Date.now() + duration;\n  const trans = typeof options.transition === \"function\" ? options.transition : (_b = toValue(options.transition)) != null ? _b : identity;\n  const ease = typeof trans === \"function\" ? trans : createEasingFunction(trans);\n  return new Promise((resolve) => {\n    source.value = fromVal;\n    const tick = () => {\n      var _a2;\n      if ((_a2 = options.abort) == null ? void 0 : _a2.call(options)) {\n        resolve();\n        return;\n      }\n      const now = Date.now();\n      const alpha = ease((now - startedAt) / duration);\n      const arr = toVec(source.value).map((n, i) => lerp(v1[i], v2[i], alpha));\n      if (Array.isArray(source.value))\n        source.value = arr.map((n, i) => {\n          var _a3, _b2;\n          return lerp((_a3 = v1[i]) != null ? _a3 : 0, (_b2 = v2[i]) != null ? _b2 : 0, alpha);\n        });\n      else if (typeof source.value === \"number\")\n        source.value = arr[0];\n      if (now < endAt) {\n        requestAnimationFrame(tick);\n      } else {\n        source.value = toVal;\n        resolve();\n      }\n    };\n    tick();\n  });\n}\nfunction useTransition(source, options = {}) {\n  let currentId = 0;\n  const sourceVal = () => {\n    const v = toValue(source);\n    return typeof v === \"number\" ? v : v.map(toValue);\n  };\n  const outputRef = ref(sourceVal());\n  watch(sourceVal, async (to) => {\n    var _a, _b;\n    if (toValue(options.disabled))\n      return;\n    const id = ++currentId;\n    if (options.delay)\n      await promiseTimeout(toValue(options.delay));\n    if (id !== currentId)\n      return;\n    const toVal = Array.isArray(to) ? to.map(toValue) : toValue(to);\n    (_a = options.onStarted) == null ? void 0 : _a.call(options);\n    await executeTransition(outputRef, outputRef.value, toVal, __spreadProps(__spreadValues({}, options), {\n      abort: () => {\n        var _a2;\n        return id !== currentId || ((_a2 = options.abort) == null ? void 0 : _a2.call(options));\n      }\n    }));\n    (_b = options.onFinished) == null ? void 0 : _b.call(options);\n  }, { deep: true });\n  watch(() => toValue(options.disabled), (disabled) => {\n    if (disabled) {\n      currentId++;\n      outputRef.value = sourceVal();\n    }\n  });\n  tryOnScopeDispose(() => {\n    currentId++;\n  });\n  return computed(() => toValue(options.disabled) ? sourceVal() : outputRef.value);\n}\n\nfunction useUrlSearchParams(mode = \"history\", options = {}) {\n  const {\n    initialValue = {},\n    removeNullishValues = true,\n    removeFalsyValues = false,\n    write: enableWrite = true,\n    window = defaultWindow\n  } = options;\n  if (!window)\n    return reactive(initialValue);\n  const state = reactive({});\n  function getRawParams() {\n    if (mode === \"history\") {\n      return window.location.search || \"\";\n    } else if (mode === \"hash\") {\n      const hash = window.location.hash || \"\";\n      const index = hash.indexOf(\"?\");\n      return index > 0 ? hash.slice(index) : \"\";\n    } else {\n      return (window.location.hash || \"\").replace(/^#/, \"\");\n    }\n  }\n  function constructQuery(params) {\n    const stringified = params.toString();\n    if (mode === \"history\")\n      return `${stringified ? `?${stringified}` : \"\"}${window.location.hash || \"\"}`;\n    if (mode === \"hash-params\")\n      return `${window.location.search || \"\"}${stringified ? `#${stringified}` : \"\"}`;\n    const hash = window.location.hash || \"#\";\n    const index = hash.indexOf(\"?\");\n    if (index > 0)\n      return `${hash.slice(0, index)}${stringified ? `?${stringified}` : \"\"}`;\n    return `${hash}${stringified ? `?${stringified}` : \"\"}`;\n  }\n  function read() {\n    return new URLSearchParams(getRawParams());\n  }\n  function updateState(params) {\n    const unusedKeys = new Set(Object.keys(state));\n    for (const key of params.keys()) {\n      const paramsForKey = params.getAll(key);\n      state[key] = paramsForKey.length > 1 ? paramsForKey : params.get(key) || \"\";\n      unusedKeys.delete(key);\n    }\n    Array.from(unusedKeys).forEach((key) => delete state[key]);\n  }\n  const { pause, resume } = pausableWatch(\n    state,\n    () => {\n      const params = new URLSearchParams(\"\");\n      Object.keys(state).forEach((key) => {\n        const mapEntry = state[key];\n        if (Array.isArray(mapEntry))\n          mapEntry.forEach((value) => params.append(key, value));\n        else if (removeNullishValues && mapEntry == null)\n          params.delete(key);\n        else if (removeFalsyValues && !mapEntry)\n          params.delete(key);\n        else\n          params.set(key, mapEntry);\n      });\n      write(params);\n    },\n    { deep: true }\n  );\n  function write(params, shouldUpdate) {\n    pause();\n    if (shouldUpdate)\n      updateState(params);\n    window.history.replaceState(\n      window.history.state,\n      window.document.title,\n      window.location.pathname + constructQuery(params)\n    );\n    resume();\n  }\n  function onChanged() {\n    if (!enableWrite)\n      return;\n    write(read(), true);\n  }\n  useEventListener(window, \"popstate\", onChanged, false);\n  if (mode !== \"history\")\n    useEventListener(window, \"hashchange\", onChanged, false);\n  const initial = read();\n  if (initial.keys().next().value)\n    updateState(initial);\n  else\n    Object.assign(state, initialValue);\n  return state;\n}\n\nfunction useUserMedia(options = {}) {\n  var _a, _b;\n  const enabled = ref((_a = options.enabled) != null ? _a : false);\n  const autoSwitch = ref((_b = options.autoSwitch) != null ? _b : true);\n  const constraints = ref(options.constraints);\n  const { navigator = defaultNavigator } = options;\n  const isSupported = useSupported(() => {\n    var _a2;\n    return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getUserMedia;\n  });\n  const stream = shallowRef();\n  function getDeviceOptions(type) {\n    switch (type) {\n      case \"video\": {\n        if (constraints.value)\n          return constraints.value.video || false;\n        break;\n      }\n      case \"audio\": {\n        if (constraints.value)\n          return constraints.value.audio || false;\n        break;\n      }\n    }\n  }\n  async function _start() {\n    if (!isSupported.value || stream.value)\n      return;\n    stream.value = await navigator.mediaDevices.getUserMedia({\n      video: getDeviceOptions(\"video\"),\n      audio: getDeviceOptions(\"audio\")\n    });\n    return stream.value;\n  }\n  function _stop() {\n    var _a2;\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\n    stream.value = void 0;\n  }\n  function stop() {\n    _stop();\n    enabled.value = false;\n  }\n  async function start() {\n    await _start();\n    if (stream.value)\n      enabled.value = true;\n    return stream.value;\n  }\n  async function restart() {\n    _stop();\n    return await start();\n  }\n  watch(\n    enabled,\n    (v) => {\n      if (v)\n        _start();\n      else\n        _stop();\n    },\n    { immediate: true }\n  );\n  watch(\n    constraints,\n    () => {\n      if (autoSwitch.value && stream.value)\n        restart();\n    },\n    { immediate: true }\n  );\n  return {\n    isSupported,\n    stream,\n    start,\n    stop,\n    restart,\n    constraints,\n    enabled,\n    autoSwitch\n  };\n}\n\nfunction useVModel(props, key, emit, options = {}) {\n  var _a, _b, _c, _d, _e;\n  const {\n    clone = false,\n    passive = false,\n    eventName,\n    deep = false,\n    defaultValue,\n    shouldEmit\n  } = options;\n  const vm = getCurrentInstance();\n  const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));\n  let event = eventName;\n  if (!key) {\n    if (isVue2) {\n      const modelOptions = (_e = (_d = vm == null ? void 0 : vm.proxy) == null ? void 0 : _d.$options) == null ? void 0 : _e.model;\n      key = (modelOptions == null ? void 0 : modelOptions.value) || \"value\";\n      if (!eventName)\n        event = (modelOptions == null ? void 0 : modelOptions.event) || \"input\";\n    } else {\n      key = \"modelValue\";\n    }\n  }\n  event = event || `update:${key.toString()}`;\n  const cloneFn = (val) => !clone ? val : typeof clone === \"function\" ? clone(val) : cloneFnJSON(val);\n  const getValue = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;\n  const triggerEmit = (value) => {\n    if (shouldEmit) {\n      if (shouldEmit(value))\n        _emit(event, value);\n    } else {\n      _emit(event, value);\n    }\n  };\n  if (passive) {\n    const initialValue = getValue();\n    const proxy = ref(initialValue);\n    watch(\n      () => props[key],\n      (v) => proxy.value = cloneFn(v)\n    );\n    watch(\n      proxy,\n      (v) => {\n        if (v !== props[key] || deep)\n          triggerEmit(v);\n      },\n      { deep }\n    );\n    return proxy;\n  } else {\n    return computed({\n      get() {\n        return getValue();\n      },\n      set(value) {\n        triggerEmit(value);\n      }\n    });\n  }\n}\n\nfunction useVModels(props, emit, options = {}) {\n  const ret = {};\n  for (const key in props)\n    ret[key] = useVModel(props, key, emit, options);\n  return ret;\n}\n\nfunction useVibrate(options) {\n  const {\n    pattern = [],\n    interval = 0,\n    navigator = defaultNavigator\n  } = options || {};\n  const isSupported = useSupported(() => typeof navigator !== \"undefined\" && \"vibrate\" in navigator);\n  const patternRef = toRef(pattern);\n  let intervalControls;\n  const vibrate = (pattern2 = patternRef.value) => {\n    if (isSupported.value)\n      navigator.vibrate(pattern2);\n  };\n  const stop = () => {\n    if (isSupported.value)\n      navigator.vibrate(0);\n    intervalControls == null ? void 0 : intervalControls.pause();\n  };\n  if (interval > 0) {\n    intervalControls = useIntervalFn(\n      vibrate,\n      interval,\n      {\n        immediate: false,\n        immediateCallback: false\n      }\n    );\n  }\n  return {\n    isSupported,\n    pattern,\n    intervalControls,\n    vibrate,\n    stop\n  };\n}\n\nfunction useVirtualList(list, options) {\n  const { containerStyle, wrapperProps, scrollTo, calculateRange, currentList, containerRef } = \"itemHeight\" in options ? useVerticalVirtualList(options, list) : useHorizontalVirtualList(options, list);\n  return {\n    list: currentList,\n    scrollTo,\n    containerProps: {\n      ref: containerRef,\n      onScroll: () => {\n        calculateRange();\n      },\n      style: containerStyle\n    },\n    wrapperProps\n  };\n}\nfunction useVirtualListResources(list) {\n  const containerRef = ref(null);\n  const size = useElementSize(containerRef);\n  const currentList = ref([]);\n  const source = shallowRef(list);\n  const state = ref({ start: 0, end: 10 });\n  return { state, source, currentList, size, containerRef };\n}\nfunction createGetViewCapacity(state, source, itemSize) {\n  return (containerSize) => {\n    if (typeof itemSize === \"number\")\n      return Math.ceil(containerSize / itemSize);\n    const { start = 0 } = state.value;\n    let sum = 0;\n    let capacity = 0;\n    for (let i = start; i < source.value.length; i++) {\n      const size = itemSize(i);\n      sum += size;\n      capacity = i;\n      if (sum > containerSize)\n        break;\n    }\n    return capacity - start;\n  };\n}\nfunction createGetOffset(source, itemSize) {\n  return (scrollDirection) => {\n    if (typeof itemSize === \"number\")\n      return Math.floor(scrollDirection / itemSize) + 1;\n    let sum = 0;\n    let offset = 0;\n    for (let i = 0; i < source.value.length; i++) {\n      const size = itemSize(i);\n      sum += size;\n      if (sum >= scrollDirection) {\n        offset = i;\n        break;\n      }\n    }\n    return offset + 1;\n  };\n}\nfunction createCalculateRange(type, overscan, getOffset, getViewCapacity, { containerRef, state, currentList, source }) {\n  return () => {\n    const element = containerRef.value;\n    if (element) {\n      const offset = getOffset(type === \"vertical\" ? element.scrollTop : element.scrollLeft);\n      const viewCapacity = getViewCapacity(type === \"vertical\" ? element.clientHeight : element.clientWidth);\n      const from = offset - overscan;\n      const to = offset + viewCapacity + overscan;\n      state.value = {\n        start: from < 0 ? 0 : from,\n        end: to > source.value.length ? source.value.length : to\n      };\n      currentList.value = source.value.slice(state.value.start, state.value.end).map((ele, index) => ({\n        data: ele,\n        index: index + state.value.start\n      }));\n    }\n  };\n}\nfunction createGetDistance(itemSize, source) {\n  return (index) => {\n    if (typeof itemSize === \"number\") {\n      const size2 = index * itemSize;\n      return size2;\n    }\n    const size = source.value.slice(0, index).reduce((sum, _, i) => sum + itemSize(i), 0);\n    return size;\n  };\n}\nfunction useWatchForSizes(size, list, calculateRange) {\n  watch([size.width, size.height, list], () => {\n    calculateRange();\n  });\n}\nfunction createComputedTotalSize(itemSize, source) {\n  return computed(() => {\n    if (typeof itemSize === \"number\")\n      return source.value.length * itemSize;\n    return source.value.reduce((sum, _, index) => sum + itemSize(index), 0);\n  });\n}\nconst scrollToDictionaryForElementScrollKey = {\n  horizontal: \"scrollLeft\",\n  vertical: \"scrollTop\"\n};\nfunction createScrollTo(type, calculateRange, getDistance, containerRef) {\n  return (index) => {\n    if (containerRef.value) {\n      containerRef.value[scrollToDictionaryForElementScrollKey[type]] = getDistance(index);\n      calculateRange();\n    }\n  };\n}\nfunction useHorizontalVirtualList(options, list) {\n  const resources = useVirtualListResources(list);\n  const { state, source, currentList, size, containerRef } = resources;\n  const containerStyle = { overflowX: \"auto\" };\n  const { itemWidth, overscan = 5 } = options;\n  const getViewCapacity = createGetViewCapacity(state, source, itemWidth);\n  const getOffset = createGetOffset(source, itemWidth);\n  const calculateRange = createCalculateRange(\"horizontal\", overscan, getOffset, getViewCapacity, resources);\n  const getDistanceLeft = createGetDistance(itemWidth, source);\n  const offsetLeft = computed(() => getDistanceLeft(state.value.start));\n  const totalWidth = createComputedTotalSize(itemWidth, source);\n  useWatchForSizes(size, list, calculateRange);\n  const scrollTo = createScrollTo(\"horizontal\", calculateRange, getDistanceLeft, containerRef);\n  const wrapperProps = computed(() => {\n    return {\n      style: {\n        height: \"100%\",\n        width: `${totalWidth.value - offsetLeft.value}px`,\n        marginLeft: `${offsetLeft.value}px`,\n        display: \"flex\"\n      }\n    };\n  });\n  return {\n    scrollTo,\n    calculateRange,\n    wrapperProps,\n    containerStyle,\n    currentList,\n    containerRef\n  };\n}\nfunction useVerticalVirtualList(options, list) {\n  const resources = useVirtualListResources(list);\n  const { state, source, currentList, size, containerRef } = resources;\n  const containerStyle = { overflowY: \"auto\" };\n  const { itemHeight, overscan = 5 } = options;\n  const getViewCapacity = createGetViewCapacity(state, source, itemHeight);\n  const getOffset = createGetOffset(source, itemHeight);\n  const calculateRange = createCalculateRange(\"vertical\", overscan, getOffset, getViewCapacity, resources);\n  const getDistanceTop = createGetDistance(itemHeight, source);\n  const offsetTop = computed(() => getDistanceTop(state.value.start));\n  const totalHeight = createComputedTotalSize(itemHeight, source);\n  useWatchForSizes(size, list, calculateRange);\n  const scrollTo = createScrollTo(\"vertical\", calculateRange, getDistanceTop, containerRef);\n  const wrapperProps = computed(() => {\n    return {\n      style: {\n        width: \"100%\",\n        height: `${totalHeight.value - offsetTop.value}px`,\n        marginTop: `${offsetTop.value}px`\n      }\n    };\n  });\n  return {\n    calculateRange,\n    scrollTo,\n    containerStyle,\n    wrapperProps,\n    currentList,\n    containerRef\n  };\n}\n\nfunction useWakeLock(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    document = defaultDocument\n  } = options;\n  let wakeLock;\n  const isSupported = useSupported(() => navigator && \"wakeLock\" in navigator);\n  const isActive = ref(false);\n  async function onVisibilityChange() {\n    if (!isSupported.value || !wakeLock)\n      return;\n    if (document && document.visibilityState === \"visible\")\n      wakeLock = await navigator.wakeLock.request(\"screen\");\n    isActive.value = !wakeLock.released;\n  }\n  if (document)\n    useEventListener(document, \"visibilitychange\", onVisibilityChange, { passive: true });\n  async function request(type) {\n    if (!isSupported.value)\n      return;\n    wakeLock = await navigator.wakeLock.request(type);\n    isActive.value = !wakeLock.released;\n  }\n  async function release() {\n    if (!isSupported.value || !wakeLock)\n      return;\n    await wakeLock.release();\n    isActive.value = !wakeLock.released;\n    wakeLock = null;\n  }\n  return {\n    isSupported,\n    isActive,\n    request,\n    release\n  };\n}\n\nfunction useWebNotification(defaultOptions = {}) {\n  const {\n    window = defaultWindow\n  } = defaultOptions;\n  const isSupported = useSupported(() => !!window && \"Notification\" in window);\n  const notification = ref(null);\n  const requestPermission = async () => {\n    if (!isSupported.value)\n      return;\n    if (\"permission\" in Notification && Notification.permission !== \"denied\")\n      await Notification.requestPermission();\n  };\n  const { on: onClick, trigger: clickTrigger } = createEventHook();\n  const { on: onShow, trigger: showTrigger } = createEventHook();\n  const { on: onError, trigger: errorTrigger } = createEventHook();\n  const { on: onClose, trigger: closeTrigger } = createEventHook();\n  const show = async (overrides) => {\n    if (!isSupported.value)\n      return;\n    await requestPermission();\n    const options = Object.assign({}, defaultOptions, overrides);\n    notification.value = new Notification(options.title || \"\", options);\n    notification.value.onclick = clickTrigger;\n    notification.value.onshow = showTrigger;\n    notification.value.onerror = errorTrigger;\n    notification.value.onclose = closeTrigger;\n    return notification.value;\n  };\n  const close = () => {\n    if (notification.value)\n      notification.value.close();\n    notification.value = null;\n  };\n  tryOnMounted(async () => {\n    if (isSupported.value)\n      await requestPermission();\n  });\n  tryOnScopeDispose(close);\n  if (isSupported.value && window) {\n    const document = window.document;\n    useEventListener(document, \"visibilitychange\", (e) => {\n      e.preventDefault();\n      if (document.visibilityState === \"visible\") {\n        close();\n      }\n    });\n  }\n  return {\n    isSupported,\n    notification,\n    show,\n    close,\n    onClick,\n    onShow,\n    onError,\n    onClose\n  };\n}\n\nconst DEFAULT_PING_MESSAGE = \"ping\";\nfunction resolveNestedOptions(options) {\n  if (options === true)\n    return {};\n  return options;\n}\nfunction useWebSocket(url, options = {}) {\n  const {\n    onConnected,\n    onDisconnected,\n    onError,\n    onMessage,\n    immediate = true,\n    autoClose = true,\n    protocols = []\n  } = options;\n  const data = ref(null);\n  const status = ref(\"CLOSED\");\n  const wsRef = ref();\n  const urlRef = toRef(url);\n  let heartbeatPause;\n  let heartbeatResume;\n  let explicitlyClosed = false;\n  let retried = 0;\n  let bufferedData = [];\n  let pongTimeoutWait;\n  const close = (code = 1e3, reason) => {\n    if (!wsRef.value)\n      return;\n    explicitlyClosed = true;\n    heartbeatPause == null ? void 0 : heartbeatPause();\n    wsRef.value.close(code, reason);\n  };\n  const _sendBuffer = () => {\n    if (bufferedData.length && wsRef.value && status.value === \"OPEN\") {\n      for (const buffer of bufferedData)\n        wsRef.value.send(buffer);\n      bufferedData = [];\n    }\n  };\n  const resetHeartbeat = () => {\n    clearTimeout(pongTimeoutWait);\n    pongTimeoutWait = void 0;\n  };\n  const send = (data2, useBuffer = true) => {\n    if (!wsRef.value || status.value !== \"OPEN\") {\n      if (useBuffer)\n        bufferedData.push(data2);\n      return false;\n    }\n    _sendBuffer();\n    wsRef.value.send(data2);\n    return true;\n  };\n  const _init = () => {\n    if (explicitlyClosed || typeof urlRef.value === \"undefined\")\n      return;\n    const ws = new WebSocket(urlRef.value, protocols);\n    wsRef.value = ws;\n    status.value = \"CONNECTING\";\n    ws.onopen = () => {\n      status.value = \"OPEN\";\n      onConnected == null ? void 0 : onConnected(ws);\n      heartbeatResume == null ? void 0 : heartbeatResume();\n      _sendBuffer();\n    };\n    ws.onclose = (ev) => {\n      status.value = \"CLOSED\";\n      wsRef.value = void 0;\n      onDisconnected == null ? void 0 : onDisconnected(ws, ev);\n      if (!explicitlyClosed && options.autoReconnect) {\n        const {\n          retries = -1,\n          delay = 1e3,\n          onFailed\n        } = resolveNestedOptions(options.autoReconnect);\n        retried += 1;\n        if (typeof retries === \"number\" && (retries < 0 || retried < retries))\n          setTimeout(_init, delay);\n        else if (typeof retries === \"function\" && retries())\n          setTimeout(_init, delay);\n        else\n          onFailed == null ? void 0 : onFailed();\n      }\n    };\n    ws.onerror = (e) => {\n      onError == null ? void 0 : onError(ws, e);\n    };\n    ws.onmessage = (e) => {\n      if (options.heartbeat) {\n        resetHeartbeat();\n        const {\n          message = DEFAULT_PING_MESSAGE\n        } = resolveNestedOptions(options.heartbeat);\n        if (e.data === message)\n          return;\n      }\n      data.value = e.data;\n      onMessage == null ? void 0 : onMessage(ws, e);\n    };\n  };\n  if (options.heartbeat) {\n    const {\n      message = DEFAULT_PING_MESSAGE,\n      interval = 1e3,\n      pongTimeout = 1e3\n    } = resolveNestedOptions(options.heartbeat);\n    const { pause, resume } = useIntervalFn(\n      () => {\n        send(message, false);\n        if (pongTimeoutWait != null)\n          return;\n        pongTimeoutWait = setTimeout(() => {\n          close();\n        }, pongTimeout);\n      },\n      interval,\n      { immediate: false }\n    );\n    heartbeatPause = pause;\n    heartbeatResume = resume;\n  }\n  if (autoClose) {\n    useEventListener(window, \"beforeunload\", () => close());\n    tryOnScopeDispose(close);\n  }\n  const open = () => {\n    close();\n    explicitlyClosed = false;\n    retried = 0;\n    _init();\n  };\n  if (immediate)\n    watch(urlRef, open, { immediate: true });\n  return {\n    data,\n    status,\n    close,\n    send,\n    open,\n    ws: wsRef\n  };\n}\n\nfunction useWebWorker(arg0, workerOptions, options) {\n  const {\n    window = defaultWindow\n  } = options != null ? options : {};\n  const data = ref(null);\n  const worker = shallowRef();\n  const post = (...args) => {\n    if (!worker.value)\n      return;\n    worker.value.postMessage(...args);\n  };\n  const terminate = function terminate2() {\n    if (!worker.value)\n      return;\n    worker.value.terminate();\n  };\n  if (window) {\n    if (typeof arg0 === \"string\")\n      worker.value = new Worker(arg0, workerOptions);\n    else if (typeof arg0 === \"function\")\n      worker.value = arg0();\n    else\n      worker.value = arg0;\n    worker.value.onmessage = (e) => {\n      data.value = e.data;\n    };\n    tryOnScopeDispose(() => {\n      if (worker.value)\n        worker.value.terminate();\n    });\n  }\n  return {\n    data,\n    post,\n    terminate,\n    worker\n  };\n}\n\nfunction jobRunner(userFunc) {\n  return (e) => {\n    const userFuncArgs = e.data[0];\n    return Promise.resolve(userFunc.apply(void 0, userFuncArgs)).then((result) => {\n      postMessage([\"SUCCESS\", result]);\n    }).catch((error) => {\n      postMessage([\"ERROR\", error]);\n    });\n  };\n}\n\nfunction depsParser(deps) {\n  if (deps.length === 0)\n    return \"\";\n  const depsString = deps.map((dep) => `'${dep}'`).toString();\n  return `importScripts(${depsString})`;\n}\n\nfunction createWorkerBlobUrl(fn, deps) {\n  const blobCode = `${depsParser(deps)}; onmessage=(${jobRunner})(${fn})`;\n  const blob = new Blob([blobCode], { type: \"text/javascript\" });\n  const url = URL.createObjectURL(blob);\n  return url;\n}\n\nfunction useWebWorkerFn(fn, options = {}) {\n  const {\n    dependencies = [],\n    timeout,\n    window = defaultWindow\n  } = options;\n  const worker = ref();\n  const workerStatus = ref(\"PENDING\");\n  const promise = ref({});\n  const timeoutId = ref();\n  const workerTerminate = (status = \"PENDING\") => {\n    if (worker.value && worker.value._url && window) {\n      worker.value.terminate();\n      URL.revokeObjectURL(worker.value._url);\n      promise.value = {};\n      worker.value = void 0;\n      window.clearTimeout(timeoutId.value);\n      workerStatus.value = status;\n    }\n  };\n  workerTerminate();\n  tryOnScopeDispose(workerTerminate);\n  const generateWorker = () => {\n    const blobUrl = createWorkerBlobUrl(fn, dependencies);\n    const newWorker = new Worker(blobUrl);\n    newWorker._url = blobUrl;\n    newWorker.onmessage = (e) => {\n      const { resolve = () => {\n      }, reject = () => {\n      } } = promise.value;\n      const [status, result] = e.data;\n      switch (status) {\n        case \"SUCCESS\":\n          resolve(result);\n          workerTerminate(status);\n          break;\n        default:\n          reject(result);\n          workerTerminate(\"ERROR\");\n          break;\n      }\n    };\n    newWorker.onerror = (e) => {\n      const { reject = () => {\n      } } = promise.value;\n      reject(e);\n      workerTerminate(\"ERROR\");\n    };\n    if (timeout) {\n      timeoutId.value = setTimeout(\n        () => workerTerminate(\"TIMEOUT_EXPIRED\"),\n        timeout\n      );\n    }\n    return newWorker;\n  };\n  const callWorker = (...fnArgs) => new Promise((resolve, reject) => {\n    promise.value = {\n      resolve,\n      reject\n    };\n    worker.value && worker.value.postMessage([[...fnArgs]]);\n    workerStatus.value = \"RUNNING\";\n  });\n  const workerFn = (...fnArgs) => {\n    if (workerStatus.value === \"RUNNING\") {\n      console.error(\n        \"[useWebWorkerFn] You can only run one instance of the worker at a time.\"\n      );\n      return Promise.reject();\n    }\n    worker.value = generateWorker();\n    return callWorker(...fnArgs);\n  };\n  return {\n    workerFn,\n    workerStatus,\n    workerTerminate\n  };\n}\n\nfunction useWindowFocus({ window = defaultWindow } = {}) {\n  if (!window)\n    return ref(false);\n  const focused = ref(window.document.hasFocus());\n  useEventListener(window, \"blur\", () => {\n    focused.value = false;\n  });\n  useEventListener(window, \"focus\", () => {\n    focused.value = true;\n  });\n  return focused;\n}\n\nfunction useWindowScroll({ window = defaultWindow } = {}) {\n  if (!window) {\n    return {\n      x: ref(0),\n      y: ref(0)\n    };\n  }\n  const x = ref(window.scrollX);\n  const y = ref(window.scrollY);\n  useEventListener(\n    window,\n    \"scroll\",\n    () => {\n      x.value = window.scrollX;\n      y.value = window.scrollY;\n    },\n    {\n      capture: false,\n      passive: true\n    }\n  );\n  return { x, y };\n}\n\nfunction useWindowSize(options = {}) {\n  const {\n    window = defaultWindow,\n    initialWidth = Infinity,\n    initialHeight = Infinity,\n    listenOrientation = true,\n    includeScrollbar = true\n  } = options;\n  const width = ref(initialWidth);\n  const height = ref(initialHeight);\n  const update = () => {\n    if (window) {\n      if (includeScrollbar) {\n        width.value = window.innerWidth;\n        height.value = window.innerHeight;\n      } else {\n        width.value = window.document.documentElement.clientWidth;\n        height.value = window.document.documentElement.clientHeight;\n      }\n    }\n  };\n  update();\n  tryOnMounted(update);\n  useEventListener(\"resize\", update, { passive: true });\n  if (listenOrientation) {\n    const matches = useMediaQuery(\"(orientation: portrait)\");\n    watch(matches, () => update());\n  }\n  return { width, height };\n}\n\nexport { DefaultMagicKeysAliasMap, StorageSerializers, TransitionPresets, computedAsync as asyncComputed, breakpointsAntDesign, breakpointsBootstrapV5, breakpointsMasterCss, breakpointsQuasar, breakpointsSematic, breakpointsTailwind, breakpointsVuetify, cloneFnJSON, computedAsync, computedInject, createFetch, createReusableTemplate, createTemplatePromise, createUnrefFn, customStorageEventName, defaultDocument, defaultLocation, defaultNavigator, defaultWindow, executeTransition, formatTimeAgo, getSSRHandler, mapGamepadToXbox360Controller, onClickOutside, onKeyDown, onKeyPressed, onKeyStroke, onKeyUp, onLongPress, onStartTyping, setSSRHandler, templateRef, unrefElement, useActiveElement, useAnimate, useAsyncQueue, useAsyncState, useBase64, useBattery, useBluetooth, useBreakpoints, useBroadcastChannel, useBrowserLocation, useCached, useClipboard, useCloned, useColorMode, useConfirmDialog, useCssVar, useCurrentElement, useCycleList, useDark, useDebouncedRefHistory, useDeviceMotion, useDeviceOrientation, useDevicePixelRatio, useDevicesList, useDisplayMedia, useDocumentVisibility, useDraggable, useDropZone, useElementBounding, useElementByPoint, useElementHover, useElementSize, useElementVisibility, useEventBus, useEventListener, useEventSource, useEyeDropper, useFavicon, useFetch, useFileDialog, useFileSystemAccess, useFocus, useFocusWithin, useFps, useFullscreen, useGamepad, useGeolocation, useIdle, useImage, useInfiniteScroll, useIntersectionObserver, useKeyModifier, useLocalStorage, useMagicKeys, useManualRefHistory, useMediaControls, useMediaQuery, useMemoize, useMemory, useMounted, useMouse, useMouseInElement, useMousePressed, useMutationObserver, useNavigatorLanguage, useNetwork, useNow, useObjectUrl, useOffsetPagination, useOnline, usePageLeave, useParallax, useParentElement, usePerformanceObserver, usePermission, usePointer, usePointerLock, usePointerSwipe, usePreferredColorScheme, usePreferredContrast, usePreferredDark, usePreferredLanguages, usePreferredReducedMotion, usePrevious, useRafFn, useRefHistory, useResizeObserver, useScreenOrientation, useScreenSafeArea, useScriptTag, useScroll, useScrollLock, useSessionStorage, useShare, useSorted, useSpeechRecognition, useSpeechSynthesis, useStepper, useStorage, useStorageAsync, useStyleTag, useSupported, useSwipe, useTemplateRefsList, useTextDirection, useTextSelection, useTextareaAutosize, useThrottledRefHistory, useTimeAgo, useTimeoutPoll, useTimestamp, useTitle, useTransition, useUrlSearchParams, useUserMedia, useVModel, useVModels, useVibrate, useVirtualList, useWakeLock, useWebNotification, useWebSocket, useWebWorker, useWebWorkerFn, useWindowFocus, useWindowScroll, useWindowSize };\n","<script lang=\"ts\">\nimport {\n  defineComponent,\n  h,\n  type PropType,\n  type RendererElement,\n  type SlotsType,\n  Teleport,\n} from 'vue'\n\nexport default defineComponent({\n  name: 'ComponentOrEmpty',\n  slots: Object as SlotsType<{\n    default?: Record<string, never>\n  }>,\n  props: {\n    tag: {\n      type: String,\n      default: 'div',\n    },\n    to: {\n      type: [String, Object] as PropType<string | RendererElement | null | undefined>,\n      default: null,\n    },\n    skip: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  setup(props, {slots, attrs}) {\n    return () =>\n      props.skip\n        ? slots.default?.()\n        : props.tag === 'Teleport'\n        ? h(Teleport, {to: props.to}, [slots.default?.()])\n        : h(props.tag, {...attrs}, [slots.default?.()])\n  },\n})\n</script>\n","import {computedEager} from '@vueuse/core'\nimport {type MaybeRefOrGetter, type Ref, toValue} from 'vue'\nimport type {AlignmentJustifyContent} from '../types'\n\nexport default (\n  align: MaybeRefOrGetter<AlignmentJustifyContent | undefined>\n): Readonly<Ref<string>> =>\n  computedEager(() => {\n    const value = toValue(align)\n    return !value ? '' : `justify-content-${value}`\n  })\n","import type {Booleanish} from '../types'\nimport {type MaybeRefOrGetter, type Ref, toValue} from 'vue'\nimport {resolveBooleanish} from '../utils'\nimport {computedEager} from '@vueuse/core'\n\n// function useBooleanish<T>(el: Ref<Booleanish | T>): ComputedRef<boolean | T>\n// This may possibily be used in Vue 3.3 to include Booleanish and complex types ie Booleanish | string\n/**\n * Resolves a Booleanish type reactively to type boolean\n */\nfunction useBooleanish(el: MaybeRefOrGetter<Booleanish>): Readonly<Ref<boolean>>\nfunction useBooleanish(el: MaybeRefOrGetter<Booleanish | null>): Readonly<Ref<boolean | null>>\nfunction useBooleanish(\n  el: MaybeRefOrGetter<Booleanish | undefined>\n): Readonly<Ref<boolean | undefined>>\nfunction useBooleanish(\n  el: MaybeRefOrGetter<Booleanish | undefined | null>\n): Readonly<Ref<boolean | undefined | null>>\nfunction useBooleanish(\n  el:\n    | MaybeRefOrGetter<Booleanish>\n    | MaybeRefOrGetter<Booleanish | undefined>\n    | MaybeRefOrGetter<Booleanish | null>\n    | MaybeRefOrGetter<Booleanish | undefined | null>\n):\n  | Readonly<Ref<boolean>>\n  | Readonly<Ref<boolean | undefined>>\n  | Readonly<Ref<boolean | null>>\n  | Readonly<Ref<boolean | undefined | null>> {\n  return computedEager(() => {\n    const value = toValue(el)\n    return value === undefined || value === null ? value : resolveBooleanish(value)\n  })\n}\n\nexport default useBooleanish\n","import {reactive} from 'vue'\nimport type {BreadcrumbItem} from '../types'\nimport {createGlobalState} from '@vueuse/core'\n\nexport default createGlobalState(() => {\n  const items = reactive<BreadcrumbItem[]>([])\n  const reset = (): void => {\n    items.splice(0, items.length)\n  }\n\n  return {items, reset}\n})\n","import {useColorMode, type UseColorModeOptions} from '@vueuse/core'\n\nexport interface ColorModeOptions extends UseColorModeOptions {\n  /**\n   * When set to true, useColorMode will automatically store itself and persist (default localstorage).\n   * @default false\n   */\n  persist?: boolean\n}\n\nexport default (opts: ColorModeOptions = {}) => {\n  const persist = opts.persist ?? false\n  const attribute = 'data-bs-theme'\n  const selector = 'body'\n  return useColorMode({\n    attribute,\n    selector,\n    storageKey:\n      persist === true\n        ? `bv-color-${opts.attribute ?? attribute}-${opts.selector ?? selector}`\n        : null,\n    ...opts,\n  })\n}\n","import {useIntervalFn, type UseIntervalFnOptions} from '@vueuse/core'\nimport {\n  computed,\n  type ComputedRef,\n  type MaybeRefOrGetter,\n  readonly,\n  ref,\n  type Ref,\n  toRef,\n  watch,\n  watchEffect,\n} from 'vue'\n\ntype VoidFn = () => void\n\ninterface CountdownReturn {\n  isActive: Readonly<Ref<boolean>>\n  isPaused: Readonly<Ref<boolean>>\n  restart: VoidFn\n  stop: VoidFn\n  resume: VoidFn\n  pause: VoidFn\n  value: ComputedRef<number>\n}\n\n/**\n * A simple interval timer that counts down the remaining seconds\n *\n * @param {MaybeRefOrGetter<number>} length the total amount of time to loop through in ms\n * @param {MaybeRefOrGetter<number>} interval how often the interval should refresh. Default 1000\n * @param {UseIntervalFnOptions} intervalOpts opts to pass to the interval fn. Default {}\n * @important ensure that you call `stop()` before unmount in the component\n */\nexport default (\n  length: MaybeRefOrGetter<number>,\n  interval: MaybeRefOrGetter<number> = ref(1000),\n  intervalOpts: UseIntervalFnOptions = {}\n): CountdownReturn => {\n  const resolvedLength = readonly(toRef(length))\n\n  const resolvedInterval = readonly(toRef(interval))\n\n  const isPaused = ref(false)\n\n  const intervalsPassed = ref(0)\n\n  const amountOfIntervals = computed(() => Math.ceil(resolvedLength.value / resolvedInterval.value))\n\n  const value = computed(() =>\n    isActive.value || isPaused.value\n      ? Math.round(resolvedLength.value - intervalsPassed.value * resolvedInterval.value)\n      : 0\n  )\n\n  const {pause, resume, isActive} = useIntervalFn(\n    () => {\n      intervalsPassed.value = intervalsPassed.value + 1\n    },\n    interval,\n    intervalOpts\n  )\n\n  const restart = () => {\n    isPaused.value = false\n    intervalsPassed.value = 0\n    resume()\n  }\n\n  const stop = () => {\n    isPaused.value = false\n    intervalsPassed.value = amountOfIntervals.value\n    // pause() // Only here for the sake of demonstrating the flow. It will be called in the watchEffect\n  }\n  watchEffect(() => {\n    if (intervalsPassed.value > amountOfIntervals.value) {\n      intervalsPassed.value = amountOfIntervals.value\n    }\n    if (intervalsPassed.value === amountOfIntervals.value) {\n      pause()\n    }\n  })\n\n  watch([resolvedInterval, resolvedLength], () => {\n    stop()\n    restart()\n  })\n\n  const myPause = () => {\n    if (isActive.value === false) return\n    isPaused.value = true\n    pause()\n  }\n\n  const myResume = () => {\n    if (intervalsPassed.value === amountOfIntervals.value) return\n    isPaused.value = false\n    resume()\n  }\n\n  return {\n    isActive: readonly(isActive),\n    isPaused: readonly(isPaused),\n    restart,\n    stop,\n    pause: myPause,\n    resume: myResume,\n    value,\n  }\n}\n","import type {AriaInvalid, ButtonVariant, Size} from '../types'\nimport {computed, type MaybeRefOrGetter, toValue} from 'vue'\nimport {resolveAriaInvalid} from '../utils'\n\ninterface ClassesItemsInput {\n  plain?: boolean\n  button?: boolean\n  inline?: boolean\n  switch?: boolean\n  size?: Size\n}\n\nconst getClasses = (items: MaybeRefOrGetter<ClassesItemsInput>) =>\n  computed(() => {\n    const resolvedItems = toValue(items)\n    return {\n      'form-check': resolvedItems.plain === false && resolvedItems.button === false,\n      'form-check-inline': resolvedItems.inline === true,\n      'form-switch': resolvedItems.switch === true,\n      [`form-control-${resolvedItems.size}`]:\n        resolvedItems.size !== undefined &&\n        resolvedItems.size !== 'md' &&\n        resolvedItems.button === false,\n    }\n  })\n\ninterface InputClassesItemsInput {\n  plain?: boolean\n  button?: boolean\n  state?: boolean | null\n}\n\nconst getInputClasses = (items: MaybeRefOrGetter<InputClassesItemsInput>) =>\n  computed(() => {\n    const resolvedItems = toValue(items)\n    return {\n      'form-check-input': resolvedItems.plain === false && resolvedItems.button === false,\n      'is-valid': resolvedItems.state === true,\n      'is-invalid': resolvedItems.state === false,\n      'btn-check': resolvedItems.button === true,\n    }\n  })\n\ninterface LabelClasesItemsInput {\n  plain?: boolean\n  button?: boolean\n  buttonVariant?: ButtonVariant | null\n  size?: Size\n}\n\nconst getLabelClasses = (items: MaybeRefOrGetter<LabelClasesItemsInput>) =>\n  computed(() => {\n    const resolvedItems = toValue(items)\n    return {\n      'form-check-label': resolvedItems.plain === false && resolvedItems.button === false,\n      'btn': resolvedItems.button === true,\n      [`btn-${resolvedItems.buttonVariant}`]:\n        resolvedItems.button === true &&\n        resolvedItems.buttonVariant !== undefined &&\n        resolvedItems.buttonVariant !== null,\n      [`btn-${resolvedItems.size}`]:\n        resolvedItems.button && resolvedItems.size && resolvedItems.size !== 'md',\n    }\n  })\n\ninterface GroupAttrItemsInput {\n  required?: boolean\n  ariaInvalid?: AriaInvalid\n  state?: boolean | null\n}\n\nconst getGroupAttr = (items: MaybeRefOrGetter<GroupAttrItemsInput>) =>\n  computed(() => {\n    const resolvedItems = toValue(items)\n    return {\n      'aria-invalid': resolveAriaInvalid(resolvedItems.ariaInvalid, resolvedItems.state),\n      'aria-required': resolvedItems.required === true ? true : undefined,\n    }\n  })\n\ninterface GroupClassesItemsInput {\n  validated?: boolean\n  buttons?: boolean\n  stacked?: boolean\n  size?: Size\n}\n\nconst getGroupClasses = (items: MaybeRefOrGetter<GroupClassesItemsInput>) =>\n  computed(() => {\n    const resolvedItems = toValue(items)\n    return {\n      'was-validated': resolvedItems.validated === true,\n      'btn-group': resolvedItems.buttons === true && resolvedItems.stacked === false,\n      'btn-group-vertical': resolvedItems.stacked === true && resolvedItems.buttons === true,\n      [`btn-group-${resolvedItems.size}`]: resolvedItems.size !== undefined,\n    }\n  })\n\nexport {getClasses, getInputClasses, getLabelClasses, getGroupAttr, getGroupClasses}\n","import type {AriaInvalid, Booleanish, Size} from '../types'\nimport {computed, nextTick, onActivated, onMounted, ref, watch} from 'vue'\nimport {useBooleanish, useId} from '.'\nimport {resolveAriaInvalid} from '../utils'\nimport {useFocus} from '@vueuse/core'\n\nexport interface CommonInputProps {\n  ariaInvalid?: AriaInvalid\n  autocomplete?: string\n  autofocus?: Booleanish\n  disabled?: Booleanish\n  form?: string\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  formatter?: (val: any, evt: any) => any\n  id?: string\n  lazy?: Booleanish\n  lazyFormatter?: Booleanish\n  list?: string\n  modelValue?: string | number\n  name?: string\n  number?: Booleanish\n  placeholder?: string\n  plaintext?: Booleanish\n  readonly?: Booleanish\n  required?: Booleanish\n  size?: Size\n  state?: Booleanish | null | undefined\n  trim?: Booleanish\n}\n\n// export const COMMON_INPUT_PROPS = {\n//   ariaInvalid: {\n//     type: [Boolean, String] as PropType<AriaInvalid>,\n//     default: undefined,\n//   },\n//   autocomplete: {type: String, required: false},\n//   autofocus: {type: Boolean, default: false},\n//   disabled: {type: Boolean, default: false},\n//   form: {type: String, required: false},\n//   formatter: {type: Function, required: false},\n//   id: {type: String, required: false},\n//   lazy: {type: Boolean, default: false},\n//   lazyFormatter: {type: Boolean, default: false},\n//   list: {type: String, required: false},\n//   modelValue: {type: [String, Number] as PropType<string | number>, default: ''},\n//   name: {type: String, required: false},\n//   number: {type: Boolean, default: false},\n//   placeholder: {type: String, required: false},\n//   plaintext: {type: Boolean, default: false},\n//   readonly: {type: Boolean, default: false},\n//   required: {type: Boolean, default: false},\n//   size: {type: String as PropType<Size>, required: false},\n//   state: {type: Boolean as PropType<Booleanish | null | undefined>, default: null},\n//   trim: {type: Boolean, default: false},\n// }\n\nexport default (props: Readonly<CommonInputProps>, emit: any) => {\n  const input = ref<HTMLInputElement | null>(null)\n  let inputValue: string | null = null\n  let neverFormatted = true\n  const computedId = useId(() => props.id, 'input')\n  const autofocusBoolean = useBooleanish(() => props.autofocus)\n  const disabledBoolean = useBooleanish(() => props.disabled)\n  const lazyBoolean = useBooleanish(() => props.lazy)\n  const lazyFormatterBoolean = useBooleanish(() => props.lazyFormatter)\n  const numberBoolean = useBooleanish(() => props.number)\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const plaintextBoolean = useBooleanish(() => props.plaintext)\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const readonlyBoolean = useBooleanish(() => props.readonly)\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const requiredBoolean = useBooleanish(() => props.required)\n  const stateBoolean = useBooleanish(() => props.state)\n  const trimBoolean = useBooleanish(() => props.trim)\n\n  const {focused} = useFocus(input, {\n    initialValue: autofocusBoolean.value,\n  })\n\n  const _formatValue = (value: unknown, evt: Event, force = false) => {\n    value = String(value)\n    if (typeof props.formatter === 'function' && (!lazyFormatterBoolean.value || force)) {\n      neverFormatted = false\n      return props.formatter(value, evt)\n    }\n    return value\n  }\n\n  const _getModelValue = (value: any) => {\n    if (trimBoolean.value) return value.trim()\n    if (numberBoolean.value) return Number.parseFloat(value)\n\n    return value\n  }\n\n  const handleAutofocus = () => {\n    if (autofocusBoolean.value) {\n      focused.value = true\n    }\n  }\n\n  onMounted(() => {\n    if (input.value) {\n      input.value.value = props.modelValue as string\n    }\n  })\n\n  onActivated(() => {\n    nextTick(() => {\n      handleAutofocus()\n    })\n  })\n\n  const computedAriaInvalid = computed(() =>\n    resolveAriaInvalid(props.ariaInvalid, stateBoolean.value)\n  )\n\n  const onInput = (evt: Event) => {\n    const {value} = evt.target as HTMLInputElement\n    const formattedValue = _formatValue(value, evt)\n    if (formattedValue === false || evt.defaultPrevented) {\n      evt.preventDefault()\n      return\n    }\n\n    if (lazyBoolean.value) return\n\n    const nextModel = _getModelValue(formattedValue)\n\n    if (props.modelValue !== nextModel) {\n      inputValue = value\n      emit('update:modelValue', nextModel)\n    }\n\n    emit('input', formattedValue)\n  }\n\n  const onChange = (evt: Event) => {\n    const {value} = evt.target as HTMLInputElement\n    const formattedValue = _formatValue(value, evt)\n    if (formattedValue === false || evt.defaultPrevented) {\n      evt.preventDefault()\n      return\n    }\n\n    if (!lazyBoolean.value) return\n    inputValue = value\n    emit('update:modelValue', formattedValue)\n\n    const nextModel = _getModelValue(formattedValue)\n    if (props.modelValue !== nextModel) {\n      emit('change', formattedValue)\n    }\n  }\n\n  const onBlur = (evt: FocusEvent) => {\n    emit('blur', evt)\n    if (!lazyBoolean.value && !lazyFormatterBoolean.value) return\n\n    const {value} = evt.target as HTMLInputElement\n    const formattedValue = _formatValue(value, evt, true)\n\n    inputValue = value\n    emit('update:modelValue', formattedValue)\n  }\n\n  const focus = () => {\n    if (!disabledBoolean.value) {\n      focused.value = true\n    }\n  }\n\n  const blur = () => {\n    if (!disabledBoolean.value) {\n      input.value?.blur()\n    }\n  }\n\n  watch(\n    () => props.modelValue,\n    (newValue) => {\n      if (!input.value) return\n      input.value.value = inputValue && neverFormatted ? inputValue : (newValue as string)\n      inputValue = null\n      neverFormatted = true\n    }\n  )\n\n  return {\n    input,\n    computedId,\n    computedAriaInvalid,\n    onInput,\n    onChange,\n    onBlur,\n    focus,\n    blur,\n  }\n}\n","const _getNested = (obj: any, path: string): any => {\n  if (!obj) return obj\n  if (path in obj) return obj[path]\n\n  const paths = path.split('.')\n\n  return _getNested(obj[paths[0]], paths.splice(1).join('.'))\n}\n\nconst _normalizeOption = (\n  option: any,\n  key: string | null = null,\n  componentName: string,\n  props: any\n) => {\n  if (Object.prototype.toString.call(option) === '[object Object]') {\n    const value = _getNested(option, props.valueField)\n    const text = _getNested(option, props.textField)\n    const html = _getNested(option, props.htmlField)\n    const disabled = _getNested(option, props.disabledField)\n\n    const options = option[props.optionsField] || null\n    if (options !== null) {\n      return {\n        label: String(_getNested(option, props.labelField) || text),\n        options: normalizeOptions(options, componentName, props),\n      }\n    }\n\n    return {\n      value: typeof value === 'undefined' ? key || text : value,\n      text: String(typeof text === 'undefined' ? key : text),\n      html,\n      disabled: Boolean(disabled),\n    }\n  }\n  return {\n    value: key || option,\n    text: String(option),\n    disabled: false,\n  }\n}\n\nconst normalizeOptions = (\n  options: any[],\n  componentName: string,\n  props: Record<string, unknown>\n): any => {\n  if (Array.isArray(options)) {\n    return options.map((option) => _normalizeOption(option, null, componentName, props))\n  } else if (Object.prototype.toString.call(options) === '[object Object]') {\n    // eslint-disable-next-line no-console\n    console.warn(\n      `[BootstrapVue warn]: ${componentName} - Setting prop \"options\" to an object is deprecated. Use the array format instead.`\n    )\n\n    return Object.keys(options).map((key: string) => {\n      const el: any = options[key]\n      switch (typeof el) {\n        case 'object':\n          return _normalizeOption(el.text, String(el.value), componentName, props)\n        default:\n          return _normalizeOption(el, String(key), componentName, props)\n      }\n    })\n  }\n\n  return []\n}\n\nexport default normalizeOptions\n","import {getId} from '../utils'\nimport {computed, type ComputedRef, type MaybeRefOrGetter, toValue} from 'vue'\n\nexport default (id?: MaybeRefOrGetter<string | undefined>, suffix?: string): ComputedRef<string> =>\n  computed(() => toValue(id) || getId(suffix))\n","import {\n  createSharedComposable,\n  getSSRHandler,\n  tryOnScopeDispose,\n  unrefElement,\n  useCounter,\n} from '@vueuse/core'\nimport {type Ref, watch} from 'vue'\n\nconst MODAL_OPEN_CLASS_NAME = 'modal-open'\n\nconst useSharedModalCounter = createSharedComposable(() => {\n  const {count, inc, dec} = useCounter()\n\n  const updateHTMLAttrs = getSSRHandler('updateHTMLAttrs', (selector, attribute, value) => {\n    const el =\n      typeof selector === 'string'\n        ? window?.document.querySelector(selector)\n        : unrefElement(selector)\n    if (!el) return\n\n    if (attribute === 'class') {\n      el.classList.toggle(MODAL_OPEN_CLASS_NAME, value === MODAL_OPEN_CLASS_NAME)\n    } else {\n      el.setAttribute(attribute, value)\n    }\n  })\n\n  tryOnScopeDispose(() => {\n    updateHTMLAttrs('body', 'class', '')\n  })\n\n  watch(count, (newValue) => {\n    updateHTMLAttrs('body', 'class', newValue > 0 ? MODAL_OPEN_CLASS_NAME : '')\n  })\n\n  return {inc, dec}\n})\n\nexport default (modalOpen: Ref<boolean>): void => {\n  const {inc, dec} = useSharedModalCounter()\n\n  watch(\n    modalOpen,\n    (newValue, oldValue) => {\n      if (newValue) {\n        inc()\n      } else if (oldValue && !newValue) {\n        dec()\n      }\n    },\n    {immediate: true}\n  )\n}\n","import {computed, type MaybeRefOrGetter, onMounted, readonly, ref, toRef, watch} from 'vue'\nimport {useScrollLock} from '@vueuse/core'\n\nexport default (isOpen: MaybeRefOrGetter<boolean>, bodyScroll: MaybeRefOrGetter<boolean>) => {\n  const modelValue = readonly(toRef(isOpen))\n  const bodyScrollingValue = readonly(toRef(bodyScroll))\n\n  /**\n   * We use the inverse because bodyScrolling === true means we allow scrolling, while bodyScrolling === false means we disallow\n   */\n  const inverseBodyScrollingValue = computed(() => !bodyScrollingValue.value)\n\n  const bodyRef = ref<HTMLElement | null>(null)\n\n  onMounted(() => {\n    bodyRef.value = document.body\n  })\n\n  const isLocked = useScrollLock(bodyRef, modelValue.value && inverseBodyScrollingValue.value)\n\n  watch([modelValue, inverseBodyScrollingValue], ([modelVal, bodyVal]) => {\n    isLocked.value = modelVal && bodyVal\n  })\n}\n","import {computed, type MaybeRefOrGetter, toValue} from 'vue'\n\nexport default (value: MaybeRefOrGetter<boolean | null>) =>\n  computed(() => {\n    const resolvedValue = toValue(value)\n\n    return resolvedValue === true ? 'is-valid' : resolvedValue === false ? 'is-invalid' : null\n  })\n","<template>\n  <span ref=\"placeholder\" />\n  <slot name=\"target\" v-bind=\"{show, hide: hideFn, toggle, showState}\" />\n  <!-- TODO: fix this clunky solution when https://github.com/vuejs/core/issues/6152 is fixed -->\n  <RenderComponentOrSkip :tag=\"'Teleport'\" :to=\"container\" :skip=\"!container\">\n    <div\n      v-if=\"showStateInternal\"\n      :id=\"id\"\n      v-bind=\"$attrs\"\n      ref=\"element\"\n      :class=\"computedClasses\"\n      role=\"tooltip\"\n      tabindex=\"-1\"\n      :style=\"{\n        position: strategy,\n        top: `${y}px`,\n        left: `${x}px`,\n        width: 'max-content',\n      }\"\n    >\n      <div\n        ref=\"arrow\"\n        :class=\"`${tooltipBoolean ? 'tooltip' : 'popover'}-arrow`\"\n        :style=\"arrowStyle\"\n        data-popper-arrow\n      />\n      <template v-if=\"title || $slots.title\">\n        <div v-if=\"!isHtml\" :class=\"tooltipBoolean ? 'tooltip-inner' : 'popover-header'\">\n          <slot name=\"title\">\n            {{ title }}\n          </slot>\n        </div>\n        <!-- eslint-disable vue/no-v-html -->\n        <div\n          v-else\n          :class=\"tooltipBoolean ? 'tooltip-inner' : 'popover-header'\"\n          v-html=\"sanitizedTitle\"\n        />\n        <!-- eslint-enable vue/no-v-html -->\n      </template>\n      <template v-if=\"(tooltipBoolean && !$slots.title && !title) || !tooltipBoolean\">\n        <div v-if=\"!isHtml\" :class=\"tooltipBoolean ? 'tooltip-inner' : 'popover-body'\">\n          <slot>\n            {{ content }}\n          </slot>\n        </div>\n        <!-- eslint-disable vue/no-v-html -->\n        <div\n          v-else\n          :class=\"tooltipBoolean ? 'tooltip-inner' : 'popover-body'\"\n          v-html=\"sanitizedContent\"\n        />\n        <!-- eslint-enable vue/no-v-html -->\n      </template>\n    </div>\n  </RenderComponentOrSkip>\n</template>\n\n<script setup lang=\"ts\">\nimport {\n  type Alignment,\n  arrow as arrowMiddleware,\n  autoPlacement,\n  autoUpdate,\n  flip,\n  hide as hideMiddleware,\n  inline as inlineMiddleware,\n  type Middleware,\n  offset as offsetMiddleware,\n  type Placement as OriginalPlacement,\n  shift,\n  type Strategy,\n  useFloating,\n} from '@floating-ui/vue'\nimport {\n  BvTriggerableEvent,\n  getTransitionDelay,\n  IS_BROWSER,\n  resolveBootstrapPlacement,\n} from '../utils'\nimport {DefaultAllowlist, sanitizeHtml} from '../utils/sanitizer'\nimport {onClickOutside, useMouseInElement} from '@vueuse/core'\nimport RenderComponentOrSkip from './RenderComponentOrSkip.vue'\nimport {\n  type ComponentPublicInstance,\n  computed,\n  type CSSProperties,\n  nextTick,\n  onBeforeUnmount,\n  onMounted,\n  ref,\n  type VNode,\n  watch,\n  watchEffect,\n} from 'vue'\nimport {useBooleanish, useId} from '../composables'\nimport type {Booleanish, BPopoverPlacement, ColorVariant} from '../types'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(\n  defineProps<{\n    modelValue?: Booleanish\n    container?: string | ComponentPublicInstance<HTMLElement> | HTMLElement | undefined\n    target?:\n      | (() => HTMLElement | VNode)\n      | string\n      | ComponentPublicInstance<HTMLElement>\n      | HTMLSpanElement\n      | HTMLElement\n      | null\n    reference?:\n      | (() => HTMLElement | VNode)\n      | string\n      | ComponentPublicInstance<HTMLElement>\n      | HTMLSpanElement\n      | HTMLElement\n      | null\n    content?: string\n    id?: string\n    title?: string\n    delay?:\n      | number\n      | {\n          show: number\n          hide: number\n        }\n    click?: Booleanish\n    manual?: Booleanish\n    variant?: ColorVariant | null\n    offset?: number | null\n    customClass?: string\n    placement?: BPopoverPlacement\n    strategy?: Strategy\n    floatingMiddleware?: Middleware[]\n    noFlip?: Booleanish\n    noShift?: Booleanish\n    noFade?: Booleanish\n    noAutoClose?: Booleanish\n    hide?: Booleanish\n    realtime?: Booleanish\n    inline?: Booleanish\n    tooltip?: Booleanish\n    html?: Booleanish\n  }>(),\n  {\n    floatingMiddleware: undefined,\n    title: undefined,\n    id: undefined,\n    content: undefined,\n    modelValue: false,\n    container: undefined,\n    customClass: '',\n    placement: 'top',\n    strategy: 'absolute',\n    delay: () => ({show: 100, hide: 300}),\n    click: false,\n    manual: false,\n    variant: null,\n    offset: null,\n    noFlip: false,\n    noShift: false,\n    noFade: false,\n    noAutoClose: false,\n    hide: true,\n    realtime: false,\n    inline: false,\n    tooltip: false,\n    html: false,\n    reference: null,\n    target: null,\n  }\n)\n\nconst emit = defineEmits<{\n  'show': [value: BvTriggerableEvent]\n  'shown': [value: BvTriggerableEvent]\n  'hide': [value: BvTriggerableEvent]\n  'hidden': [value: BvTriggerableEvent]\n  'hide-prevented': []\n  'show-prevented': []\n  'update:modelValue': [value: boolean]\n}>()\n\ndefineSlots<{\n  target?: (props: {\n    show: () => void\n    hide: (e: Event) => void\n    toggle: (e: Event) => void\n    showState: boolean\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  }) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  title?: (props: Record<string, never>) => any\n}>()\n\nconst modelValueBoolean = useBooleanish(() => props.modelValue)\nconst showState = ref(modelValueBoolean.value)\nconst showStateInternal = ref(modelValueBoolean.value)\nwatchEffect(() => {\n  emit('update:modelValue', showState.value)\n})\n\nwatch(modelValueBoolean, () => {\n  if (modelValueBoolean.value === showState.value) return\n  modelValueBoolean.value ? show() : hideFn(new Event('update:modelValue'))\n})\n\nconst computedId = useId(() => props.id, 'popover')\n\nconst clickBoolean = useBooleanish(() => props.click)\nconst manualBoolean = useBooleanish(() => props.manual)\nconst noShiftBoolean = useBooleanish(() => props.noShift)\nconst noFlipBoolean = useBooleanish(() => props.noFlip)\nconst noFadeBoolean = useBooleanish(() => props.noFade)\nconst noAutoCloseBoolean = useBooleanish(() => props.noAutoClose)\nconst hideBoolean = useBooleanish(() => props.hide)\nconst realtimeBoolean = useBooleanish(() => props.realtime)\nconst inlineBoolean = useBooleanish(() => props.inline)\nconst tooltipBoolean = useBooleanish(() => props.tooltip)\nconst isHtml = useBooleanish(() => props.html)\nconst hidden = ref(false)\n\nconst element = ref<HTMLElement | null>(null)\nconst targetTrigger = ref<HTMLElement | null>(null)\nconst arrow = ref<HTMLElement | null>(null)\nconst trigger = ref<HTMLElement | null>(null)\nconst placeholder = ref<HTMLElement | null>(null)\n\nconst cleanElementProp = (\n  target:\n    | (() => HTMLElement | VNode)\n    | string\n    | ComponentPublicInstance<HTMLElement>\n    | HTMLElement\n    | undefined\n): HTMLElement | string | undefined => {\n  if (typeof target === 'string') {\n    return target\n  }\n  if (target instanceof HTMLElement) {\n    return target\n    // eslint-disable-next-line\n  }\n  if (typeof target === 'function')\n    return (target() as ComponentPublicInstance<HTMLElement>).$el\n      ? (target() as ComponentPublicInstance<HTMLElement>).$el\n      : target()\n  if (typeof target !== 'undefined')\n    return (target as ComponentPublicInstance<HTMLElement>).$el as HTMLElement\n  return undefined\n}\n\nconst getElement = (element: HTMLElement | string | undefined): HTMLElement | undefined => {\n  if (!element) return undefined\n  if (typeof element === 'string') {\n    const idElement = document.getElementById(element)\n    return idElement ? idElement : undefined\n  }\n  return element\n}\n\nconst sanitizedTitle = computed(() =>\n  props.title ? sanitizeHtml(props.title, DefaultAllowlist) : ''\n)\n\nconst sanitizedContent = computed(() =>\n  props.content ? sanitizeHtml(props.content, DefaultAllowlist) : ''\n)\nconst isAutoPlacement = computed(() => props.placement.startsWith('auto'))\n\nconst floatingMiddleware = computed<Middleware[]>(() => {\n  if (props.floatingMiddleware !== undefined) {\n    return props.floatingMiddleware\n  }\n  const off = typeof props.offset === 'number' ? props.offset : tooltipBoolean.value ? 0 : 10\n  const arr: Middleware[] = [offsetMiddleware(off)]\n  if (noFlipBoolean.value === false && !isAutoPlacement.value) {\n    arr.push(flip())\n  }\n  if (isAutoPlacement.value) {\n    arr.push(\n      autoPlacement({\n        alignment: (props.placement.split('-')[1] as Alignment) || undefined,\n      })\n    )\n  }\n  if (noShiftBoolean.value === false) {\n    arr.push(shift())\n  }\n  if (hideBoolean.value === true) {\n    arr.push(hideMiddleware({padding: 10}))\n  }\n  if (inlineBoolean.value === true) {\n    arr.push(inlineMiddleware())\n  }\n  arr.push(arrowMiddleware({element: arrow, padding: 10}))\n  return arr\n})\n\nconst placementRef = computed(() =>\n  isAutoPlacement.value ? undefined : (props.placement as OriginalPlacement)\n)\n\nconst {x, y, strategy, middlewareData, placement, update} = useFloating(targetTrigger, element, {\n  placement: placementRef,\n  middleware: floatingMiddleware,\n  strategy: props.strategy,\n  whileElementsMounted: (...args) => {\n    const cleanup = autoUpdate(...args, {animationFrame: realtimeBoolean.value})\n    // Important! Always return the cleanup function.\n    return cleanup\n  },\n})\n\nconst arrowStyle = ref<CSSProperties>({position: 'absolute'})\n\nwatch(middlewareData, () => {\n  if (hideBoolean.value === true) {\n    if (middlewareData.value.hide?.referenceHidden) {\n      hidden.value = true\n    } else {\n      hidden.value = false\n    }\n  }\n  if (middlewareData.value.arrow) {\n    const {x, y} = middlewareData.value.arrow\n    arrowStyle.value = {\n      position: 'absolute',\n      top: y ? `${y}px` : '',\n      left: x ? `${x}px` : '',\n    }\n  }\n})\n\nconst computedClasses = computed(() => {\n  const type = tooltipBoolean.value ? 'tooltip' : 'popover'\n  return [\n    type,\n    `b-${type}`,\n    {\n      [`b-${type}-${props.variant}`]: props.variant !== null,\n      show: showState.value && !hidden.value,\n      ['pe-none']: !showState.value,\n      fade: !noFadeBoolean.value,\n      ['d-none']: !showState.value && noFadeBoolean.value,\n      [`${props.customClass}`]: props.customClass !== undefined,\n      [`bs-${type}-${resolveBootstrapPlacement(placement.value)}`]: placement.value !== undefined,\n    },\n  ]\n})\n\nconst {isOutside} = useMouseInElement(element)\nconst {isOutside: triggerIsOutside} = useMouseInElement(trigger)\n\nconst toggle = (e: Event) => {\n  const event = e ?? new Event('click')\n  showState.value ? hideFn(event) : show()\n}\n\nconst buildTriggerableEvent = (\n  type: string,\n  opts: Partial<BvTriggerableEvent> = {}\n): BvTriggerableEvent =>\n  new BvTriggerableEvent(type, {\n    cancelable: false,\n    target: element.value || null,\n    relatedTarget: null,\n    trigger: null,\n    ...opts,\n    componentId: computedId.value,\n  })\n\nconst show = () => {\n  const event = buildTriggerableEvent('show', {cancelable: true})\n  emit('show', event)\n  if (event.defaultPrevented) {\n    emit('show-prevented')\n    return\n  }\n  showStateInternal.value = true\n  nextTick(() => {\n    update()\n    setTimeout(\n      () => {\n        update()\n        showState.value = true\n        nextTick(() => {\n          emit('shown', buildTriggerableEvent('shown'))\n        })\n      },\n      typeof props.delay === 'number' ? props.delay : props.delay?.show || 0\n    )\n  })\n}\n\nconst hideFn = (e: Event) => {\n  const event = buildTriggerableEvent('hide', {cancelable: true})\n  emit('hide', event)\n  if (event.defaultPrevented) {\n    emit('hide-prevented')\n    return\n  }\n  const delay = typeof props.delay === 'number' ? props.delay : props.delay?.hide || 100\n  setTimeout(() => {\n    if (\n      e?.type === 'click' ||\n      (e?.type === 'update:modelValue' && manualBoolean.value) ||\n      (isOutside.value &&\n        triggerIsOutside.value &&\n        !element.value?.contains(document?.activeElement))\n    ) {\n      showState.value = false\n      nextTick(() => {\n        setTimeout(\n          () => {\n            showStateInternal.value = false\n          },\n          element.value ? getTransitionDelay(element.value) : 150\n        )\n        emit('hidden', buildTriggerableEvent('hidden'))\n      })\n    } else {\n      setTimeout(() => {\n        hideFn(e)\n      }, delay)\n    }\n  }, delay)\n}\n\ndefineExpose({\n  hideFn,\n  show,\n  toggle,\n})\n\nconst bind = () => {\n  // TODO: is this the best way to bind the events?\n  // we place a span and get the next element sibling fo rthe listeners\n  if (props.target) {\n    const elem = getElement(cleanElementProp(props.target))\n    if (elem) {\n      trigger.value = elem\n    } else {\n      // eslint-disable-next-line no-console\n      console.warn('Target element not found', props.target)\n    }\n  } else {\n    trigger.value = placeholder.value?.nextElementSibling as HTMLElement\n  }\n  if (props.reference) {\n    const elem = getElement(cleanElementProp(props.reference))\n    if (elem) {\n      targetTrigger.value = elem\n    } else {\n      // eslint-disable-next-line no-console\n      console.warn('Reference element not found', props.reference)\n    }\n  } else {\n    targetTrigger.value = trigger.value\n  }\n  if (!trigger.value || manualBoolean.value) {\n    return\n  }\n  if (!IS_BROWSER) return\n  clickBoolean.value && trigger.value.addEventListener('click', toggle)\n  !clickBoolean.value && trigger.value.addEventListener('pointerenter', show)\n  !clickBoolean.value && trigger.value.addEventListener('pointerleave', hideFn)\n  !clickBoolean.value && trigger.value.addEventListener('focus', show)\n  !clickBoolean.value && trigger.value.addEventListener('blur', hideFn)\n}\n\nconst unbind = () => {\n  if (trigger.value) {\n    trigger.value.removeEventListener('click', toggle)\n    trigger.value.removeEventListener('pointerenter', show)\n    trigger.value.removeEventListener('pointerleave', hideFn)\n    trigger.value.removeEventListener('focus', show)\n    trigger.value.removeEventListener('blur', hideFn)\n  }\n}\n\nonClickOutside(\n  element,\n  () => {\n    if (showState.value && clickBoolean.value && !noAutoCloseBoolean.value && !manualBoolean.value)\n      hideFn(new Event('clickOutside'))\n  },\n  {ignore: [trigger]}\n)\n\nwatch([() => props.click, () => props.target, () => props.reference], () => {\n  unbind()\n  bind()\n})\n\nonMounted(bind)\n\nonBeforeUnmount(unbind)\n</script>\n","import type {Placement} from '@floating-ui/vue'\nexport {autoUpdate} from '@floating-ui/vue'\n\nimport {type App, createApp, type DirectiveBinding, h, type Ref} from 'vue'\nimport {DefaultAllowlist, sanitizeHtml} from './sanitizer'\nimport BPopover from '../components/BPopover.vue'\n\n// TODO this function doesn't currently resolve with RTL in mind. Once Bootstrap finalizes their RTL, we should make this change here\n/**\n * Configures Bootstrap-like placement props to floating-ui Placement strings.\n * Top drops up, bottom drops down, end drops right, start drops left, dropend will _align_ the drop to the 'end',\n * dropstart will _align_ the drop to the 'start'. Bottom is default, so it is the last in the order. Bottom should essentially be the opposite of top\n * @param {top: boolean; bottom: boolean; start: boolean; end: boolean; dropstart: boolean; dropend: boolean}\n * @returns {Placement} Placement\n */\nexport const resolveFloatingPlacement = ({\n  top,\n  end,\n  start,\n  alignCenter,\n  alignEnd,\n}: {\n  top: boolean\n  start: boolean\n  end: boolean\n  alignCenter: boolean\n  alignEnd: boolean\n}): Placement => {\n  const direction = top ? 'top' : start ? 'left' : end ? 'right' : 'bottom'\n  const align = alignEnd ? 'end' : alignCenter ? null : 'start'\n  return `${direction}${align ? `-${align}` : ''}` as Placement\n}\n\nexport const resolveBootstrapPlacement = (placement: Placement): string => {\n  const [_placement] = placement.split('-')\n  switch (_placement) {\n    case 'left':\n      return 'start'\n    case 'right':\n      return 'end'\n    default:\n      return _placement\n  }\n}\n\nexport const resolveActiveStatus = (values: DirectiveBinding['value']): boolean =>\n  typeof values !== 'object' || values.active !== false\n\nexport const resolveContent = (\n  values: DirectiveBinding['value'],\n  el: HTMLElement\n): {title?: string; content?: string} => {\n  const isActive = resolveActiveStatus(values)\n  if (!isActive) return {}\n\n  const missingBindingValue =\n    typeof values === 'undefined' ||\n    (typeof values === 'object' && !values.title && !values.content)\n  const title = el.getAttribute('title') || el.getAttribute('data-original-title')\n  if (missingBindingValue) {\n    if (title) {\n      el.removeAttribute('title')\n      el.setAttribute('data-original-title', title)\n\n      return {\n        content: sanitizeHtml(title, DefaultAllowlist),\n      }\n    }\n    // eslint-disable-next-line no-console\n    console.warn(\n      'Review tooltip directive usage. Some uses are not defining a title in root component or a value like `v-b-tooltip=\\'{title: \"my title\"}\\'` nor `v-b-tooltip=\"\\'my title\\'\"` to define a title'\n    )\n    return {}\n  }\n  if (typeof values === 'string') {\n    return {\n      content: sanitizeHtml(values, DefaultAllowlist),\n    }\n  }\n  return {\n    title: values?.title ? sanitizeHtml(values?.title, DefaultAllowlist) : undefined,\n    content: values?.content ? sanitizeHtml(values?.content, DefaultAllowlist) : undefined,\n  }\n}\n\nexport const resolveDirectiveProps = (binding: DirectiveBinding, el: HTMLElement) => ({\n  target: () => el,\n  modelValue: binding.modifiers.show,\n  inline: binding.modifiers.inline,\n  click: binding.modifiers.click,\n  realtime: binding.modifiers.realtime,\n  placement: binding.modifiers.left\n    ? 'left'\n    : binding.modifiers.right\n    ? 'right'\n    : binding.modifiers.bottom\n    ? 'bottom'\n    : binding.modifiers.top\n    ? 'top'\n    : undefined,\n  html: true,\n  ...(typeof binding.value === 'object' ? binding.value : {}),\n  title: null,\n  content: null,\n})\n\nexport interface ElementWithPopper extends HTMLElement {\n  $__state?: Ref<{title: string; target: HTMLElement}>\n  $__app?: App\n  $__element?: HTMLElement\n}\n\nexport const bind = (el: ElementWithPopper, binding: DirectiveBinding) => {\n  const div = document.createElement('span')\n  if (binding.modifiers.body) document.body.appendChild(div)\n  else if (binding.modifiers.child) el.appendChild(div)\n  else el.parentNode?.insertBefore(div, el.nextSibling)\n  el.$__app = createApp({render: () => h(BPopover, {...el.$__state?.value})})\n  el.$__app.mount(div)\n  el.$__element = div\n}\n\nexport const unbind = (el: ElementWithPopper) => {\n  const div = el.$__element\n  el.$__app?.unmount()\n  delete el.$__app\n  delete el.$__state\n  setTimeout(() => {\n    div?.remove()\n  }, 0)\n  delete el.$__element\n}\n","import type {ConfigurationOption} from '../types'\n\nexport default <Type extends string, Base extends ConfigurationOption<Type>>(\n  options: Base,\n  values: Type[]\n): Type[] => {\n  const {all, ...others} = options\n  const valuesCopy: Partial<Record<keyof Base, boolean>> = {}\n  if (all) {\n    values.forEach((el) => {\n      valuesCopy[el] = all\n    })\n  }\n  const merge: Record<string, boolean> = {...valuesCopy, ...others}\n  return (\n    Object.entries(merge)\n      // filtering possible invalid keys\n      .filter(([name, value]) => !!value && values.includes(name as Type))\n      .map(([name]) => name as Type)\n  )\n}\n","<template>\n  <div :id=\"computedId\" class=\"accordion\" :class=\"computedClasses\">\n    <slot />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish} from '../../types'\nimport {computed, provide, readonly} from 'vue'\nimport {accordionInjectionKey} from '../../utils'\nimport {useBooleanish, useId} from '../../composables'\nimport {useVModel} from '@vueuse/core'\n\nconst props = withDefaults(\n  defineProps<{\n    flush?: Booleanish\n    free?: Booleanish\n    id?: string\n    modelValue?: string\n  }>(),\n  {\n    flush: false,\n    free: false,\n    id: undefined,\n    modelValue: undefined,\n  }\n)\n\nconst emit = defineEmits<{\n  'update:modelValue': [value: string]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst modelValue = useVModel(props, 'modelValue', emit, {passive: true})\n\nconst computedId = useId(() => props.id, 'accordion')\n\nconst flushBoolean = useBooleanish(() => props.flush)\nconst freeBoolean = useBooleanish(() => props.free)\n\nconst computedClasses = computed(() => ({\n  'accordion-flush': flushBoolean.value,\n}))\n\nprovide(accordionInjectionKey, {\n  openItem: readonly(modelValue),\n  free: freeBoolean,\n  setOpenItem: (id: string) => {\n    modelValue.value = id\n  },\n})\n</script>\n","<template>\n  <slot\n    name=\"header\"\n    v-bind=\"{visible: modelValueBoolean, toggle: toggleFn, open, close, id: computedId}\"\n  />\n  <component\n    :is=\"tag\"\n    :id=\"computedId\"\n    ref=\"element\"\n    class=\"collapse\"\n    :class=\"computedClasses\"\n    :is-nav=\"isNavBoolean\"\n    v-bind=\"$attrs\"\n  >\n    <slot v-bind=\"{visible: modelValueBoolean, toggle, open, close}\" />\n  </component>\n  <slot\n    name=\"footer\"\n    v-bind=\"{visible: modelValueBoolean, toggle: toggleFn, open, close, id: computedId}\"\n  />\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, nextTick, onMounted, provide, readonly, ref, watch} from 'vue'\nimport {useBooleanish, useId} from '../composables'\nimport {useEventListener, useVModel} from '@vueuse/core'\nimport type {Booleanish} from '../types'\nimport {BvTriggerableEvent, collapseInjectionKey, getTransitionDelay} from '../utils'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(\n  defineProps<{\n    // appear?: Booleanish\n    id?: string\n    modelValue?: Booleanish\n    tag?: string\n    toggle?: Booleanish\n    horizontal?: Booleanish\n    visible?: Booleanish\n    isNav?: Booleanish\n  }>(),\n  {\n    accordion: undefined,\n    id: undefined,\n    modelValue: false,\n    tag: 'div',\n    toggle: false,\n    horizontal: false,\n    visible: false,\n    isNav: false,\n  }\n)\n\nconst emit = defineEmits<{\n  'show': [value: BvTriggerableEvent]\n  'shown': [value: BvTriggerableEvent]\n  'hide': [value: BvTriggerableEvent]\n  'hidden': [value: BvTriggerableEvent]\n  'hide-prevented': []\n  'show-prevented': []\n  'update:modelValue': [value: boolean]\n}>()\n\ndefineSlots<{\n  header?: (props: {\n    visible: boolean\n    toggle: () => void\n    open: () => void\n    close: () => void\n    id: string\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  }) => any\n  default?: (props: {\n    visible: boolean\n    toggle: () => void\n    open: () => void\n    close: () => void\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  }) => any\n  footer?: (props: {\n    visible: boolean\n    toggle: () => void\n    open: () => void\n    close: () => void\n    id: string\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  }) => any\n}>()\n\nconst buildTriggerableEvent = (\n  type: string,\n  opts: Partial<BvTriggerableEvent> = {}\n): BvTriggerableEvent =>\n  new BvTriggerableEvent(type, {\n    cancelable: false,\n    target: element.value || null,\n    relatedTarget: null,\n    trigger: null,\n    ...opts,\n    componentId: computedId.value,\n  })\n\nconst modelValue = useVModel(props, 'modelValue', emit, {passive: true})\n\nconst modelValueBoolean = useBooleanish(modelValue)\nconst toggleBoolean = useBooleanish(() => props.toggle)\nconst horizontalBoolean = useBooleanish(() => props.horizontal)\nconst isNavBoolean = useBooleanish(() => props.isNav)\nconst visibleBoolean = useBooleanish(() => props.visible)\n\nconst computedId = useId(() => props.id, 'collapse')\n\nconst element = ref<HTMLElement | null>(null)\nconst isCollapsing = ref(false)\nconst show = ref(modelValueBoolean.value)\n\nconst computedClasses = computed(() => ({\n  'show': show.value,\n  'navbar-collapse': isNavBoolean.value,\n  'collapsing': isCollapsing.value,\n  'closing': show.value && !modelValueBoolean.value,\n  'collapse-horizontal': horizontalBoolean.value,\n}))\n\nconst close = () => {\n  modelValue.value = false\n}\nconst open = () => {\n  modelValue.value = true\n}\nconst toggleFn = () => {\n  modelValue.value = !modelValueBoolean.value\n}\n\nconst reveal = () => {\n  show.value = true\n  isCollapsing.value = true\n  const event = buildTriggerableEvent('show', {cancelable: true})\n  emit('show', event)\n  if (event.defaultPrevented) {\n    emit('show-prevented')\n    return\n  }\n  nextTick(() => {\n    if (element.value === null) return\n    if (horizontalBoolean.value) {\n      element.value.style.width = `${element.value.scrollWidth}px`\n    } else {\n      element.value.style.height = `${element.value.scrollHeight}px`\n    }\n    setTimeout(() => {\n      isCollapsing.value = false\n      emit('shown', buildTriggerableEvent('shown'))\n      if (element.value === null) return\n      element.value.style.height = ''\n      element.value.style.width = ''\n    }, getTransitionDelay(element.value))\n  })\n}\n\nconst hide = () => {\n  const event = buildTriggerableEvent('hide', {cancelable: true})\n  emit('hide', event)\n  if (event.defaultPrevented) {\n    emit('hide-prevented')\n    return\n  }\n  if (element.value === null) return\n  if (horizontalBoolean.value) {\n    element.value.style.width = `${element.value.scrollWidth}px`\n  } else {\n    element.value.style.height = `${element.value.scrollHeight}px`\n  }\n  // element.value.style.height = `${element.value.scrollHeight}px`\n  element.value.offsetHeight // force reflow\n  isCollapsing.value = true\n  nextTick(() => {\n    if (element.value === null) return\n    element.value.style.height = ``\n    element.value.style.width = ``\n    setTimeout(() => {\n      show.value = false\n      isCollapsing.value = false\n      emit('hidden', buildTriggerableEvent('hidden'))\n    }, getTransitionDelay(element.value))\n  })\n}\n\nwatch([modelValue, show], () => {\n  if (modelValueBoolean.value === true) {\n    if (show.value) return\n    reveal()\n    return\n  }\n  hide()\n})\n\nonMounted(() => {\n  if (element.value === null) return\n  if (!modelValueBoolean.value && toggleBoolean.value) {\n    nextTick(() => {\n      modelValue.value = true\n    })\n  }\n})\n\nif (visibleBoolean.value) {\n  modelValue.value = true\n  show.value = true\n}\n\nwatch(visibleBoolean, (newval) => {\n  newval ? open() : close()\n})\n\nuseEventListener(element, 'bv-toggle', () => {\n  modelValue.value = !modelValueBoolean.value\n})\n\ndefineExpose({\n  close,\n  open,\n  toggle: toggleFn,\n  visible: readonly(show),\n  isNav: isNavBoolean,\n})\n\nprovide(collapseInjectionKey, {\n  id: computedId,\n  close,\n  open,\n  toggle: toggleFn,\n  visible: readonly(show),\n  isNav: isNavBoolean,\n})\n</script>\n","<template>\n  <div class=\"accordion-item\">\n    <BCollapse\n      :id=\"computedId\"\n      v-model=\"modelValue\"\n      class=\"accordion-collapse\"\n      v-bind=\"$attrs\"\n      :aria-labelledby=\"`${computedId}-heading`\"\n      :tag=\"tag\"\n      :toggle=\"toggle\"\n      :horizontal=\"horizontal\"\n      :visible=\"visible\"\n      :is-nav=\"isNav\"\n      v-on=\"events\"\n    >\n      <template #header=\"{visible: toggleVisible, toggle: slotToggle}\">\n        <component :is=\"headerTag\" :id=\"`${computedId}-heading`\" class=\"accordion-header\">\n          <button\n            class=\"accordion-button\"\n            :class=\"{collapsed: !toggleVisible}\"\n            type=\"button\"\n            :aria-expanded=\"toggleVisible ? 'true' : 'false'\"\n            :aria-controls=\"computedId\"\n            @click=\"slotToggle\"\n          >\n            <slot name=\"title\"> {{ title }} </slot>\n          </button>\n        </component>\n      </template>\n      <div class=\"accordion-body\">\n        <slot />\n      </div>\n    </BCollapse>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport {inject, onMounted, watch} from 'vue'\nimport {useVModel} from '@vueuse/core'\nimport BCollapse from '../BCollapse.vue'\nimport {accordionInjectionKey, BvTriggerableEvent} from '../../utils'\nimport {useId} from '../../composables'\nimport type {Booleanish} from '../../types'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(\n  defineProps<{\n    id?: string\n    title?: string\n    modelValue?: Booleanish\n    headerTag?: string\n    tag?: string\n    toggle?: Booleanish\n    horizontal?: Booleanish\n    visible?: Booleanish\n    isNav?: Booleanish\n  }>(),\n  {\n    headerTag: 'h2',\n    id: undefined,\n    title: undefined,\n    tag: undefined,\n    horizontal: undefined,\n    toggle: undefined,\n    isNav: undefined,\n    modelValue: false,\n    visible: false,\n  }\n)\n\nconst emit = defineEmits<{\n  'show': [value: BvTriggerableEvent]\n  'shown': [value: BvTriggerableEvent]\n  'hide': [value: BvTriggerableEvent]\n  'hidden': [value: BvTriggerableEvent]\n  'hide-prevented': []\n  'show-prevented': []\n  'update:modelValue': [value: boolean]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  title?: (props: Record<string, never>) => any\n}>()\n\nconst events = {\n  'show': (e: BvTriggerableEvent) => emit('show', e),\n  'shown': (e: BvTriggerableEvent) => emit('shown', e),\n  'hide': (e: BvTriggerableEvent) => emit('hide', e),\n  'hidden': (e: BvTriggerableEvent) => emit('hidden', e),\n  'hide-prevented': () => emit('hide-prevented'),\n  'show-prevented': () => emit('show-prevented'),\n}\n\nconst modelValue = useVModel(props, 'modelValue', emit, {passive: true})\n\nconst parentData = inject(accordionInjectionKey, null)\n\nconst computedId = useId(() => props.id, 'accordion_item')\n\nonMounted(() => {\n  if (modelValue.value && !parentData?.free.value) {\n    parentData?.setOpenItem(computedId.value)\n  }\n  if (!modelValue.value && parentData?.openItem.value === computedId.value) {\n    modelValue.value = true\n  }\n})\n\nwatch(\n  () => parentData?.openItem.value,\n  () =>\n    (modelValue.value = parentData?.openItem.value === computedId.value && !parentData?.free.value)\n)\nwatch(modelValue, () => {\n  if (modelValue.value && !parentData?.free.value) parentData?.setOpenItem(computedId.value)\n})\n</script>\n","<template>\n  <Transition v-bind=\"computedAttrs\">\n    <slot />\n  </Transition>\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish, TransitionMode} from '../../types'\nimport {computed, type TransitionProps} from 'vue'\nimport {useBooleanish} from '../../composables'\n\nconst props = withDefaults(\n  defineProps<{\n    appear?: Booleanish\n    mode?: TransitionMode\n    noFade?: Booleanish\n    transProps?: TransitionProps\n  }>(),\n  {\n    appear: false,\n    noFade: false,\n    transProps: undefined,\n    mode: undefined,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst appearBoolean = useBooleanish(() => props.appear)\nconst noFadeBoolean = useBooleanish(() => props.noFade)\n\nconst fadeProperties = computed(() => {\n  const NO_FADE_PROPS = {\n    name: '',\n    enterActiveClass: '',\n    enterToClass: '',\n    leaveActiveClass: '',\n    leaveToClass: 'showing',\n    enterFromClass: 'showing',\n    leaveFromClass: '',\n  }\n  const FADE_PROPS = {\n    ...NO_FADE_PROPS,\n    enterActiveClass: 'fade showing',\n    leaveActiveClass: 'fade showing',\n  }\n  return noFadeBoolean.value ? NO_FADE_PROPS : FADE_PROPS\n})\n\nconst baseProperties = computed(() => ({mode: props.mode, css: true, ...fadeProperties.value}))\n\nconst computedAttrs = computed(() =>\n  props.transProps !== undefined\n    ? {\n        // Order matters here since the props.transProps would get overwritten if it came first\n        // But the goal of props.transProps is to overwrite base properties\n        ...baseProperties.value,\n        ...props.transProps,\n      }\n    : appearBoolean.value\n    ? {\n        ...baseProperties.value,\n        appear: true,\n        appearActiveClass: fadeProperties.value.enterActiveClass,\n        appearToClass: fadeProperties.value.enterToClass,\n      }\n    : baseProperties.value\n)\n</script>\n\n<style lang=\"scss\">\n.fade-enter-active,\n.fade-leave-active {\n  transition: opacity 0.25s linear;\n}\n\n.fade-enter-from,\n.fade-leave-to {\n  opacity: 0;\n}\n</style>\n","<template>\n  <button\n    :type=\"type\"\n    class=\"btn-close\"\n    :disabled=\"disabledBoolean\"\n    :class=\"computedClasses\"\n    :aria-label=\"ariaLabel\"\n    @click=\"emit('click', $event)\"\n  />\n</template>\n\n<script setup lang=\"ts\">\nimport {computed} from 'vue'\nimport type {Booleanish, ButtonType} from '../../types'\nimport {useBooleanish} from '../../composables'\n\nconst props = withDefaults(\n  defineProps<{\n    ariaLabel?: string\n    disabled?: Booleanish\n    white?: Booleanish\n    type?: ButtonType\n  }>(),\n  {\n    ariaLabel: 'Close',\n    disabled: false,\n    white: false,\n    type: 'button',\n  }\n)\n\nconst emit = defineEmits<{\n  click: [value: MouseEvent]\n}>()\n\nconst disabledBoolean = useBooleanish(() => props.disabled)\nconst whiteBoolean = useBooleanish(() => props.white)\n\nconst computedClasses = computed(() => ({\n  'btn-close-white': whiteBoolean.value,\n}))\n</script>\n","<template>\n  <component\n    :is=\"tag\"\n    :class=\"computedClasses\"\n    :role=\"label || hasLabelSlot ? role : null\"\n    :aria-hidden=\"label || hasLabelSlot ? null : true\"\n  >\n    <span v-if=\"label || hasLabelSlot\" class=\"visually-hidden\">\n      <slot name=\"label\">{{ label }}</slot>\n    </span>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, useSlots} from 'vue'\nimport type {Booleanish, ColorVariant, SpinnerType} from '../types'\nimport {useBooleanish} from '../composables'\nimport {isEmptySlot} from '../utils'\n\nconst props = withDefaults(\n  defineProps<{\n    label?: string\n    role?: string\n    small?: Booleanish\n    tag?: string\n    type?: SpinnerType\n    variant?: ColorVariant | null\n  }>(),\n  {\n    role: 'status',\n    small: false,\n    variant: null,\n    label: undefined,\n    tag: 'span',\n    type: 'border',\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  label?: (props: Record<string, never>) => any\n}>()\n\nconst slots = useSlots()\n\nconst smallBoolean = useBooleanish(() => props.small)\n\nconst computedClasses = computed(() => ({\n  'spinner-border': props.type === 'border',\n  'spinner-border-sm': props.type === 'border' && smallBoolean.value,\n  'spinner-grow': props.type === 'grow',\n  'spinner-grow-sm': props.type === 'grow' && smallBoolean.value,\n  [`text-${props.variant}`]: props.variant !== null,\n}))\n\nconst hasLabelSlot = computed(() => !isEmptySlot(slots.label))\n</script>\n","<template>\n  <component\n    :is=\"tag\"\n    v-if=\"tag === 'router-link'\"\n    v-slot=\"//@ts-ignore \n    {href: localHref, navigate, isActive}\"\n    v-bind=\"routerAttr\"\n    custom\n  >\n    <component\n      :is=\"routerTag\"\n      :href=\"localHref\"\n      :class=\"[(activeBoolean ?? isActive) && activeClass]\"\n      v-bind=\"$attrs\"\n      @click=\";[navigate($event), closeCollapse(), clicked($event)]\"\n    >\n      <slot />\n    </component>\n  </component>\n  <component :is=\"tag\" v-else :class=\"computedLinkClasses\" v-bind=\"routerAttr\" @click=\"clicked\">\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish, ColorVariant, LinkTarget} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {collapseInjectionKey, navbarInjectionKey} from '../../utils'\nimport {computed, getCurrentInstance, inject, type PropType, useAttrs} from 'vue'\nimport type {RouteLocation, RouteLocationRaw} from 'vue-router'\nimport type {BLinkProps} from '../../types/BLinkProps'\n\n// TODO this component will likely have an issue with inheritAttrs\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst props = withDefaults(defineProps<BLinkProps>(), {\n  active: undefined,\n  activeClass: 'router-link-active',\n  append: false,\n  disabled: false,\n  event: 'click',\n  href: undefined,\n  // noPrefetch: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n  // prefetch: {type: [Boolean, String] as PropType<Booleanish>, default: null},\n  rel: undefined,\n  replace: false,\n  routerComponentName: 'router-link',\n  routerTag: 'a',\n  target: '_self',\n  to: undefined,\n  variant: null,\n  opacity: undefined,\n  opacityHover: undefined,\n  underlineVariant: null,\n  underlineOffset: undefined,\n  underlineOffsetHover: undefined,\n  underlineOpacity: undefined,\n  underlineOpacityHover: undefined,\n  icon: false,\n})\n\nconst emit = defineEmits<{\n  click: [value: MouseEvent]\n}>()\n\nconst attrs = useAttrs()\n\nconst activeBoolean = useBooleanish(() => props.active)\nconst iconBoolean = useBooleanish(() => props.icon)\n// TODO\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst appendBoolean = useBooleanish(() => props.append)\nconst disabledBoolean = useBooleanish(() => props.disabled)\n// TODO\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst replaceBoolean = useBooleanish(() => props.replace)\nconst collapseData = inject(collapseInjectionKey, null)\nconst navbarData = inject(navbarInjectionKey, null)\nconst closeCollapse = () => {\n  if (navbarData !== null) {\n    collapseData?.close?.()\n  }\n}\n\nconst instance = getCurrentInstance()\n\nconst tag = computed<string>(() => {\n  const routerName = props.routerComponentName\n    .split('-')\n    .map((e) => e.charAt(0).toUpperCase() + e.slice(1))\n    .join('')\n  const hasRouter = instance?.appContext.app.component(routerName) !== undefined\n  if (!hasRouter || disabledBoolean.value || !props.to) {\n    return 'a'\n  }\n  return props.routerComponentName\n})\n\nconst computedHref = computed<string>(() => {\n  const toFallback = '#'\n  if (props.href) return props.href\n\n  if (typeof props.to === 'string') return props.to || toFallback\n\n  const to = props.to as RouteLocation\n\n  if (\n    Object.prototype.toString.call(to) === '[object Object]' &&\n    (to.path || to.query || to.hash)\n  ) {\n    const path = to.path || ''\n    const query = to.query\n      ? `?${Object.keys(to.query)\n          .map((e) => `${e}=${to.query[e]}`)\n          .join('=')}`\n      : ''\n    const hash = !to.hash || to.hash.charAt(0) === '#' ? to.hash || '' : `#${to.hash}`\n    return `${path}${query}${hash}` || toFallback\n  }\n\n  return toFallback\n})\n\nconst computedClasses = computed(() => ({\n  [`link-${props.variant}`]: props.variant !== null,\n  [`link-opacity-${props.opacity}`]: props.opacity !== undefined,\n  [`link-opacity-${props.opacityHover}-hover`]: props.opacityHover !== undefined,\n  [`link-underline-${props.underlineVariant}`]: props.underlineVariant !== null,\n  [`link-offset-${props.underlineOffset}`]: props.underlineOffset !== undefined,\n  [`link-offset-${props.underlineOffsetHover}-hover`]: props.underlineOffsetHover !== undefined,\n  [`link-underline-opacity-${props.underlineOpacity}`]: props.underlineOpacity !== undefined,\n  [`link-underline-opacity-${props.underlineOpacityHover}-hover`]:\n    props.underlineOpacityHover !== undefined,\n  'icon-link': iconBoolean.value === true,\n}))\n\nconst routerAttr = computed(() => ({\n  'class': computedClasses.value,\n  'to': props.to,\n  'href': computedHref.value,\n  'target': props.target,\n  'rel': props.target === '_blank' && props.rel === undefined ? 'noopener' : props.rel || undefined,\n  'tabindex': disabledBoolean.value\n    ? '-1'\n    : typeof attrs.tabindex === 'undefined'\n    ? null\n    : attrs.tabindex,\n  'aria-disabled': disabledBoolean.value ? true : null,\n}))\n\nconst computedLinkClasses = computed(() => ({\n  active: activeBoolean.value,\n  disabled: disabledBoolean.value,\n}))\n\nconst clicked = (e: MouseEvent): void => {\n  if (disabledBoolean.value) {\n    e.preventDefault()\n    e.stopImmediatePropagation()\n    return\n  }\n  collapseData?.close?.()\n\n  emit('click', e)\n}\n</script>\n\n<script lang=\"ts\">\n/**\n * @deprecated will be removed when BToast is refactored\n */\nexport const BLINK_PROPS = {\n  active: {type: [Boolean, String, undefined] as PropType<Booleanish>, default: undefined},\n  activeClass: {type: String, default: 'router-link-active'},\n  append: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n  disabled: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n  event: {type: [String, Array], default: 'click'},\n  href: {type: String},\n  // noPrefetch: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n  // prefetch: {type: [Boolean, String] as PropType<Booleanish>, default: null},\n  rel: {type: String, default: null},\n  replace: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n  routerComponentName: {type: String, default: 'router-link'},\n  routerTag: {type: String, default: 'a'},\n  target: {type: String as PropType<LinkTarget>, default: '_self'},\n  to: {type: [String, Object] as PropType<RouteLocationRaw>, default: null},\n  variant: {type: String as PropType<ColorVariant | null>, default: null},\n}\n</script>\n","<template>\n  <component\n    :is=\"computedTag\"\n    class=\"btn\"\n    :class=\"computedClasses\"\n    v-bind=\"computedAttrs\"\n    @click=\"clicked\"\n  >\n    <div\n      v-if=\"loadingBoolean\"\n      class=\"btn-loading\"\n      :class=\"{'mode-fill': loadingMode === 'fill', 'mode-inline': loadingMode === 'inline'}\"\n    >\n      <slot name=\"loading\">\n        <BSpinner class=\"btn-spinner\" :small=\"size !== 'lg'\" />\n      </slot>\n    </div>\n    <div\n      class=\"btn-content\"\n      :class=\"{'btn-loading-fill': loadingBoolean && loadingMode === 'fill'}\"\n    >\n      <slot />\n    </div>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed} from 'vue'\nimport BSpinner from '../BSpinner.vue'\nimport {useBooleanish} from '../../composables'\nimport type {Booleanish, ButtonType, ButtonVariant, Size} from '../../types'\nimport {isLink} from '../../utils'\nimport BLink from '../BLink/BLink.vue'\nimport {useVModel} from '@vueuse/core'\nimport type {BLinkProps} from '../../types/BLinkProps'\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  loading?: (props: Record<string, never>) => any\n}>()\n\nconst props = withDefaults(\n  defineProps<\n    {\n      pill?: Booleanish\n      pressed?: Booleanish\n      size?: Size\n      squared?: Booleanish\n      tag?: string\n      type?: ButtonType\n      variant?: ButtonVariant | null\n      loading?: Booleanish\n      loadingMode?: 'fill' | 'inline'\n      block?: Booleanish\n    } & Omit<BLinkProps, 'variant'>\n  >(),\n  {\n    active: false,\n    pill: false,\n    pressed: undefined,\n    size: 'md',\n    squared: false,\n    tag: 'button',\n    type: 'button',\n    variant: 'secondary',\n    loading: false,\n    loadingMode: 'inline',\n    block: false,\n    // Link props\n    activeClass: 'router-link-active',\n    append: false,\n    disabled: false,\n    event: 'click',\n    href: undefined,\n    // noPrefetch: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    // prefetch: {type: [Boolean, String] as PropType<Booleanish>, default: null},\n    rel: undefined,\n    replace: false,\n    routerComponentName: 'router-link',\n    routerTag: 'a',\n    target: '_self',\n    to: undefined,\n    opacity: undefined,\n    opacityHover: undefined,\n    underlineVariant: null,\n    underlineOffset: undefined,\n    underlineOffsetHover: undefined,\n    underlineOpacity: undefined,\n    underlineOpacityHover: undefined,\n    icon: false,\n    // End link props\n  }\n)\n\nconst emit = defineEmits<{\n  'click': [value: MouseEvent]\n  'update:pressed': [value: boolean]\n}>()\n\nconst pressedValue = useVModel(props, 'pressed', emit)\n\nconst activeBoolean = useBooleanish(() => props.active)\nconst blockBoolean = useBooleanish(() => props.block)\nconst disabledBoolean = useBooleanish(() => props.disabled)\nconst pillBoolean = useBooleanish(() => props.pill)\nconst pressedBoolean = useBooleanish(() => props.pressed)\nconst squaredBoolean = useBooleanish(() => props.squared)\nconst loadingBoolean = useBooleanish(() => props.loading)\n\nconst isToggle = computed<boolean>(() => typeof pressedBoolean.value === 'boolean')\nconst isButton = computed<boolean>(\n  () => props.tag === 'button' && props.href === undefined && props.to === undefined\n)\nconst computedLink = computed<boolean>(() => isLink(props))\nconst isBLink = computed<boolean>(() => props.to !== undefined)\nconst nonStandardTag = computed<boolean>(() => (props.href !== undefined ? false : !isButton.value))\n\nconst computedClasses = computed(() => [\n  [`btn-${props.size}`],\n  {\n    [`btn-${props.variant}`]: props.variant !== null,\n    'btn-block': blockBoolean.value,\n    'active': activeBoolean.value || pressedBoolean.value,\n    'rounded-pill': pillBoolean.value,\n    'rounded-0': squaredBoolean.value,\n    'disabled': disabledBoolean.value,\n  },\n])\n\nconst computedAttrs = computed(() => ({\n  'aria-disabled': nonStandardTag.value ? disabledBoolean.value : null,\n  'aria-pressed': isToggle.value ? pressedBoolean.value : null,\n  'autocomplete': isToggle.value ? 'off' : null,\n  'disabled': isButton.value ? disabledBoolean.value : null,\n  'href': props.href,\n  'rel': computedLink.value ? props.rel : null,\n  'role': nonStandardTag.value || computedLink.value ? 'button' : null,\n  'target': computedLink.value ? props.target : null,\n  'type': isButton.value ? props.type : null,\n  'to': !isButton.value ? props.to : null,\n  'append': computedLink.value ? props.append : null,\n  'activeClass': isBLink.value ? props.activeClass : null,\n  'event': isBLink.value ? props.event : null,\n  'replace': isBLink.value ? props.replace : null,\n  'routerComponentName': isBLink.value ? props.routerComponentName : null,\n  'routerTag': isBLink.value ? props.routerTag : null,\n}))\n\nconst computedTag = computed<string | typeof BLink>(() =>\n  isBLink.value ? BLink : props.href ? 'a' : props.tag\n)\n\nconst clicked = (e: MouseEvent): void => {\n  if (disabledBoolean.value) {\n    e.preventDefault()\n    e.stopPropagation()\n    return\n  }\n  emit('click', e)\n  if (isToggle.value) {\n    pressedValue.value = !pressedBoolean.value\n  }\n}\n</script>\n","<template>\n  <BTransition :no-fade=\"!fadeBoolean\" :trans-props=\"{enterToClass: 'show'}\">\n    <div\n      v-if=\"isAlertVisible\"\n      class=\"alert\"\n      role=\"alert\"\n      aria-live=\"polite\"\n      aria-atomic=\"true\"\n      :class=\"computedClasses\"\n      @mouseenter.stop=\"onMouseEnter\"\n      @mouseleave.stop=\"resume\"\n    >\n      <slot />\n      <template v-if=\"dismissibleBoolean\">\n        <!-- TODO this renders incorrectly -->\n        <BButton v-if=\"hasCloseSlot || closeContent\" v-bind=\"closeAttrs\" @click=\"closeClicked\">\n          <slot name=\"close\">\n            {{ closeContent }}\n          </slot>\n        </BButton>\n        <BCloseButton v-else :aria-label=\"dismissLabel\" v-bind=\"closeAttrs\" @click=\"closeClicked\" />\n      </template>\n    </div>\n  </BTransition>\n</template>\n\n<script setup lang=\"ts\">\nimport BTransition from '../BTransition/BTransition.vue'\nimport BCloseButton from '../BButton/BCloseButton.vue'\nimport BButton from '../BButton/BButton.vue'\nimport type {Booleanish, ButtonType, ButtonVariant, ColorVariant} from '../../types'\nimport {computed, onBeforeUnmount, useSlots, watchEffect} from 'vue'\nimport {useBooleanish, useCountdown} from '../../composables'\nimport {isEmptySlot} from '../../utils'\nimport {useVModel} from '@vueuse/core'\n\nconst props = withDefaults(\n  defineProps<{\n    noHoverPause?: Booleanish\n    dismissLabel?: string\n    dismissible?: Booleanish\n    fade?: Booleanish\n    closeVariant?: ButtonVariant | null\n    modelValue?: boolean | number\n    variant?: ColorVariant | null\n    closeContent?: string\n    immediate?: Booleanish\n    interval?: number\n    showOnPause?: Booleanish\n  }>(),\n  {\n    closeContent: undefined,\n    closeVariant: 'secondary',\n    noHoverPause: false,\n    interval: 1000,\n    dismissLabel: 'Close',\n    dismissible: false,\n    fade: false,\n    modelValue: false,\n    variant: 'info',\n    immediate: true,\n    showOnPause: true,\n  }\n)\n\nconst emit = defineEmits<{\n  'closed': []\n  'close-countdown': [value: number]\n  'update:modelValue': [value: boolean | number]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  close?: (props: Record<string, never>) => any\n}>()\n\nconst slots = useSlots()\n\nconst modelValue = useVModel(props, 'modelValue', emit)\n\nconst dismissibleBoolean = useBooleanish(() => props.dismissible)\nconst fadeBoolean = useBooleanish(() => props.fade)\nconst immediateBoolean = useBooleanish(() => props.immediate)\nconst showOnPauseBoolean = useBooleanish(() => props.showOnPause)\nconst noHoverPauseBoolean = useBooleanish(() => props.noHoverPause)\n\nconst hasCloseSlot = computed(() => !isEmptySlot(slots.close))\n\nconst countdownLength = computed(() =>\n  typeof modelValue.value === 'boolean' ? 0 : modelValue.value\n)\n\nconst computedClasses = computed(() => ({\n  [`alert-${props.variant}`]: props.variant !== null,\n  'alert-dismissible': dismissibleBoolean.value,\n}))\n\nconst {\n  isActive,\n  pause,\n  restart,\n  resume,\n  stop,\n  isPaused,\n  value: remainingMs,\n} = useCountdown(countdownLength, () => props.interval, {\n  immediate: typeof modelValue.value === 'number' && immediateBoolean.value,\n})\n\nconst isAlertVisible = computed<boolean>(() =>\n  typeof modelValue.value === 'boolean'\n    ? modelValue.value\n    : isActive.value || (showOnPauseBoolean.value && isPaused.value)\n)\n\nconst closeAttrs = computed(() => ({\n  variant: props.closeVariant,\n  type: 'button' as ButtonType,\n}))\n\nwatchEffect(() => emit('close-countdown', remainingMs.value))\n\nconst closeClicked = (): void => {\n  if (typeof modelValue.value === 'boolean') {\n    modelValue.value = false\n  } else {\n    modelValue.value = 0\n    stop()\n  }\n  emit('closed')\n}\n\n// TODO mouseleave/mouseenter could be replaced with useElementHover with a watcher\nconst onMouseEnter = () => {\n  if (noHoverPauseBoolean.value) return\n  pause()\n}\n\nonBeforeUnmount(stop)\n\ndefineExpose({pause, resume, restart, stop})\n</script>\n","<template>\n  <component\n    :is=\"computedTag\"\n    class=\"b-avatar\"\n    :class=\"computedClasses\"\n    :style=\"computedStyle\"\n    v-bind=\"computedAttrs\"\n    @click=\"clicked\"\n  >\n    <span v-if=\"hasDefaultSlot\" class=\"b-avatar-custom\">\n      <slot />\n    </span>\n    <span v-else-if=\"!!src\" class=\"b-avatar-img\">\n      <img :src=\"src\" :alt=\"alt\" @error=\"onImgError\" />\n    </span>\n    <span v-else-if=\"!!text\" class=\"b-avatar-text\" :class=\"textClasses\" :style=\"textFontStyle\">\n      {{ text }}\n    </span>\n    <span v-if=\"showBadge\" class=\"b-avatar-badge\" :class=\"badgeClasses\" :style=\"badgeStyle\">\n      <slot v-if=\"hasBadgeSlot\" name=\"badge\" />\n      <span v-else :class=\"badgeTextClasses\">{{ badgeText }}</span>\n    </span>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {\n  avatarGroupInjectionKey,\n  isEmptySlot,\n  isLink,\n  isNumeric,\n  pluckProps,\n  toFloat,\n} from '../../utils'\nimport {computed, type CSSProperties, inject, type StyleValue, useSlots} from 'vue'\nimport type {Booleanish, ButtonType, ColorVariant, Size, TextColorVariant} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport BLink from '../BLink/BLink.vue'\nimport type {BLinkProps} from '../../types/BLinkProps'\n\nconst props = withDefaults(\n  defineProps<\n    {\n      alt?: string\n      ariaLabel?: string\n      badge?: boolean | string\n      badgeLeft?: Booleanish\n      badgeOffset?: string\n      badgeTop?: Booleanish\n      badgeVariant?: ColorVariant | null\n      button?: Booleanish\n      buttonType?: ButtonType\n      disabled?: Booleanish\n      icon?: string\n      rounded?: boolean | string\n      size?: Size | string // TODO number --> compat\n      square?: Booleanish\n      src?: string\n      text?: string\n      textVariant?: TextColorVariant | null\n      variant?: ColorVariant | null\n    } & Omit<BLinkProps, 'event' | 'routerTag'>\n  >(),\n  {\n    ariaLabel: undefined,\n    badgeOffset: undefined,\n    icon: undefined,\n    size: undefined,\n    src: undefined,\n    text: undefined,\n    textVariant: null,\n    alt: 'avatar',\n    badge: false,\n    badgeLeft: false,\n    badgeTop: false,\n    badgeVariant: 'primary',\n    button: false,\n    buttonType: 'button',\n    disabled: false,\n    rounded: 'circle',\n    square: false,\n    variant: 'secondary',\n    // Link props\n    active: undefined,\n    activeClass: 'router-link-active',\n    append: false,\n    href: undefined,\n    // noPrefetch: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    // prefetch: {type: [Boolean, String] as PropType<Booleanish>, default: null},\n    rel: undefined,\n    replace: false,\n    routerComponentName: 'router-link',\n    target: '_self',\n    to: undefined,\n    opacity: undefined,\n    opacityHover: undefined,\n    underlineVariant: null,\n    underlineOffset: undefined,\n    underlineOffsetHover: undefined,\n    underlineOpacity: undefined,\n    underlineOpacityHover: undefined,\n  }\n)\n\nconst emit = defineEmits<{\n  'click': [value: MouseEvent]\n  'img-error': [value: Event]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  badge?: (props: Record<string, never>) => any\n}>()\n\nconst slots = useSlots()\n\nconst parentData = inject(avatarGroupInjectionKey, null)\n\nconst SIZES = ['sm', null, 'lg']\nconst FONT_SIZE_SCALE = 0.4\nconst BADGE_FONT_SIZE_SCALE = FONT_SIZE_SCALE * 0.7\n\nconst badgeLeftBoolean = useBooleanish(() => props.badgeLeft)\nconst badgeTopBoolean = useBooleanish(() => props.badgeTop)\nconst buttonBoolean = useBooleanish(() => props.button)\nconst disabledBoolean = useBooleanish(() => props.disabled)\nconst squareBoolean = useBooleanish(() => props.square)\n\nconst hasDefaultSlot = computed(() => !isEmptySlot(slots.default))\nconst hasBadgeSlot = computed(() => !isEmptySlot(slots.badge))\n\nconst showBadge = computed<boolean>(() => !!props.badge || props.badge === '' || hasBadgeSlot.value)\n\nconst computedLink = computed<boolean>(() => isLink(props))\n\nconst computedSize = computed<string | null>(\n  () => parentData?.size.value ?? computeSize(props.size)\n)\n\nconst computedVariant = computed<ColorVariant | null>(\n  () => parentData?.variant.value ?? props.variant\n)\n\nconst computedRounded = computed<string | boolean>(() => parentData?.rounded.value ?? props.rounded)\n\nconst computedAttrs = computed(() => ({\n  'type': buttonBoolean.value && !computedLink.value ? props.buttonType : undefined,\n  'aria-label': props.ariaLabel || null,\n  'disabled': disabledBoolean.value || null,\n  // Link props\n  ...(computedLink.value\n    ? pluckProps(props, {\n        active: true,\n        activeClass: true,\n        append: true,\n        href: true,\n        rel: true,\n        replace: true,\n        routerComponentName: true,\n        target: true,\n        to: true,\n        variant: true,\n        opacity: true,\n        opacityHover: true,\n        underlineVariant: true,\n        underlineOffset: true,\n        underlineOffsetHover: true,\n        underlineOpacity: true,\n        underlineOpacityHover: true,\n      } as Record<keyof Omit<BLinkProps, 'event' | 'routerTag'>, true>)\n    : {}),\n}))\n\nconst badgeClasses = computed(() => ({\n  [`bg-${props.badgeVariant}`]: props.badgeVariant !== null,\n}))\n\nconst badgeText = computed<string | false>(() => (props.badge === true ? '' : props.badge))\n\nconst badgeTextClasses = computed(() => ({\n  [`text-${props.badgeVariant !== null && computeContrastVariant(props.badgeVariant)}`]:\n    props.badgeVariant !== null,\n}))\n\nconst computedClasses = computed(() => ({\n  [`b-avatar-${props.size}`]: !!props.size && SIZES.indexOf(computeSize(props.size)) !== -1,\n  [`bg-${computedVariant.value}`]: computedVariant.value !== null,\n  [`badge`]: !buttonBoolean.value && computedVariant.value !== null && hasDefaultSlot.value,\n  rounded: computedRounded.value === '' || computedRounded.value === true,\n  [`rounded-circle`]: !squareBoolean.value && computedRounded.value === 'circle',\n  [`rounded-0`]: squareBoolean.value || computedRounded.value === '0',\n  [`rounded-1`]: !squareBoolean.value && computedRounded.value === 'sm',\n  [`rounded-3`]: !squareBoolean.value && computedRounded.value === 'lg',\n  [`rounded-top`]: !squareBoolean.value && computedRounded.value === 'top',\n  [`rounded-bottom`]: !squareBoolean.value && computedRounded.value === 'bottom',\n  [`rounded-start`]: !squareBoolean.value && computedRounded.value === 'left',\n  [`rounded-end`]: !squareBoolean.value && computedRounded.value === 'right',\n  btn: buttonBoolean.value,\n  [`btn-${computedVariant.value}`]: buttonBoolean.value ? computedVariant.value !== null : false,\n}))\n\nconst textClasses = computed(() => ({\n  [`text-${\n    props.textVariant ||\n    (computedVariant.value !== null && computeContrastVariant(computedVariant.value))\n  }`]: props.textVariant || computedVariant.value !== null,\n}))\n\nconst badgeStyle = computed<StyleValue>(() => {\n  const offset = props.badgeOffset || '0px'\n  const fontSize =\n    SIZES.indexOf(computedSize.value || null) === -1\n      ? `calc(${computedSize.value} * ${BADGE_FONT_SIZE_SCALE})`\n      : ''\n  return {\n    fontSize: fontSize || '',\n    top: badgeTopBoolean.value ? offset : '',\n    bottom: badgeTopBoolean.value ? '' : offset,\n    left: badgeLeftBoolean.value ? offset : '',\n    right: badgeLeftBoolean.value ? '' : offset,\n  }\n})\n\nconst textFontStyle = computed<StyleValue>(() => {\n  const fontSize =\n    SIZES.indexOf(computedSize.value || null) === -1\n      ? `calc(${computedSize.value} * ${FONT_SIZE_SCALE})`\n      : null\n  return fontSize ? {fontSize} : {}\n})\n\nconst marginStyle = computed(() => {\n  const overlapScale = parentData?.overlapScale?.value || 0\n\n  const value =\n    computedSize.value && overlapScale ? `calc(${computedSize.value} * -${overlapScale})` : null\n  return value ? {marginLeft: value, marginRight: value} : {}\n})\n\nconst computedTag = computed<typeof BLink | 'button' | 'span'>(() =>\n  computedLink.value ? BLink : buttonBoolean.value ? 'button' : 'span'\n)\n\nconst computedStyle = computed<CSSProperties>(() => ({\n  ...marginStyle.value,\n  width: computedSize.value ?? undefined,\n  height: computedSize.value ?? undefined,\n}))\n\nconst computeContrastVariant = (colorVariant: ColorVariant): 'dark' | 'light' =>\n  colorVariant === 'light' || colorVariant === 'warning' ? 'dark' : 'light'\n\nconst clicked = (e: MouseEvent): void => {\n  if (!disabledBoolean.value && (computedLink.value || buttonBoolean.value)) emit('click', e)\n}\n\nconst onImgError = (e: Event): void => emit('img-error', e)\n</script>\n\n<script lang=\"ts\">\nexport const computeSize = (value: any): string | null => {\n  const calcValue = typeof value === 'string' && isNumeric(value) ? toFloat(value, 0) : value\n  return typeof calcValue === 'number' ? `${calcValue}px` : calcValue || null\n}\n</script>\n","<template>\n  <component :is=\"tag\" class=\"b-avatar-group\" role=\"group\">\n    <div class=\"b-avatar-group-inner\" :style=\"paddingStyle\">\n      <slot />\n    </div>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, provide, readonly, type StyleValue, toRef} from 'vue'\nimport type {Booleanish, ColorVariant, Size} from '../../types'\nimport {avatarGroupInjectionKey, isNumeric, toFloat} from '../../utils'\nimport {useBooleanish} from '../../composables'\nimport {computeSize} from './BAvatar.vue'\n\nconst props = withDefaults(\n  defineProps<{\n    overlap?: number | string\n    rounded?: boolean | string\n    size?: Size | string\n    square?: Booleanish\n    tag?: string\n    variant?: ColorVariant | null\n  }>(),\n  {\n    overlap: 0.3,\n    rounded: false,\n    square: false,\n    tag: 'div',\n    size: undefined,\n    variant: null,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst squareBoolean = useBooleanish(() => props.square)\n\nconst computedSize = computed<string | null>(() => computeSize(props.size))\n\nconst overlapScale = computed<number>(\n  () => Math.min(Math.max(computeOverlap(props.overlap), 0), 1) / 2\n)\n\nconst paddingStyle = computed<StyleValue>(() => {\n  const value = computedSize.value ? `calc(${computedSize.value} * ${overlapScale.value})` : null\n  return value ? {paddingLeft: value, paddingRight: value} : {}\n})\n\nconst computeOverlap = (value: any): number =>\n  typeof value === 'string' && isNumeric(value) ? toFloat(value, 0) : value || 0\n\nprovide(avatarGroupInjectionKey, {\n  overlapScale,\n  size: readonly(toRef(props, 'size')),\n  square: squareBoolean,\n  rounded: readonly(toRef(props, 'rounded')),\n  variant: readonly(toRef(props, 'variant')),\n})\n</script>\n","<template>\n  <component :is=\"computedTag\" class=\"badge\" :class=\"computedClasses\" v-bind=\"computedLinkProps\">\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {isLink, pluckProps} from '../../utils'\nimport {useBooleanish} from '../../composables'\nimport {computed} from 'vue'\nimport type {Booleanish} from '../../types'\nimport BLink from '../BLink/BLink.vue'\nimport type {BLinkProps} from '../../types/BLinkProps'\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst props = withDefaults(\n  defineProps<\n    {\n      pill?: Booleanish\n      tag?: string\n      textIndicator?: Booleanish\n      dotIndicator?: Booleanish\n    } & Omit<BLinkProps, 'event' | 'routerTag'>\n  >(),\n  {\n    pill: false,\n    tag: 'span',\n    textIndicator: false,\n    dotIndicator: false,\n    variant: 'secondary',\n    // Link props\n    active: undefined,\n    activeClass: 'router-link-active',\n    append: false,\n    disabled: false,\n    href: undefined,\n    // noPrefetch: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    // prefetch: {type: [Boolean, String] as PropType<Booleanish>, default: null},\n    rel: undefined,\n    replace: false,\n    routerComponentName: 'router-link',\n    target: '_self',\n    to: undefined,\n    opacity: undefined,\n    opacityHover: undefined,\n    underlineVariant: null,\n    underlineOffset: undefined,\n    underlineOffsetHover: undefined,\n    underlineOpacity: undefined,\n    underlineOpacityHover: undefined,\n    icon: false,\n    // End link props\n  }\n)\n\nconst pillBoolean = useBooleanish(() => props.pill)\nconst textIndicatorBoolean = useBooleanish(() => props.textIndicator)\nconst dotIndicatorBoolean = useBooleanish(() => props.dotIndicator)\nconst activeBoolean = useBooleanish(() => props.active)\nconst disabledBoolean = useBooleanish(() => props.disabled)\n\nconst computedLink = computed<boolean>(() => isLink(props))\n\nconst computedTag = computed<string | typeof BLink>(() => (computedLink.value ? BLink : props.tag))\n\nconst computedClasses = computed(() => ({\n  [`bg-${props.variant}`]: props.variant !== null,\n  'active': activeBoolean.value,\n  'disabled': disabledBoolean.value,\n  'text-dark': props.variant !== null && ['warning', 'info', 'light'].includes(props.variant),\n  'rounded-pill': pillBoolean.value,\n  'position-absolute top-0 start-100 translate-middle':\n    textIndicatorBoolean.value || dotIndicatorBoolean.value,\n  'p-2 border border-light rounded-circle': dotIndicatorBoolean.value,\n  'text-decoration-none': computedLink.value,\n}))\n\nconst computedLinkProps = computed(() =>\n  computedLink.value\n    ? pluckProps(props, {\n        active: true,\n        activeClass: true,\n        append: true,\n        disabled: true,\n        href: true,\n        rel: true,\n        replace: true,\n        routerComponentName: true,\n        target: true,\n        to: true,\n        variant: true,\n        opacity: true,\n        opacityHover: true,\n        underlineVariant: true,\n        underlineOffset: true,\n        underlineOffsetHover: true,\n        underlineOpacity: true,\n        underlineOpacityHover: true,\n        icon: true,\n      } satisfies Record<keyof Omit<BLinkProps, 'event' | 'routerTag'>, true>)\n    : {}\n)\n</script>\n","<template>\n  <li class=\"breadcrumb-item\" :class=\"computedClasses\">\n    <component\n      :is=\"computedTag\"\n      :aria-current=\"computedAriaCurrent\"\n      v-bind=\"computedLinkProps\"\n      @click=\"clicked\"\n    >\n      <slot>\n        {{ text }}\n      </slot>\n    </component>\n  </li>\n</template>\n\n<script setup lang=\"ts\">\nimport {pluckProps} from '../../utils'\nimport {useBooleanish} from '../../composables'\nimport {computed} from 'vue'\nimport BLink from '../BLink/BLink.vue'\nimport type {BLinkProps} from '../../types/BLinkProps'\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst props = withDefaults(\n  defineProps<\n    {\n      ariaCurrent?: string\n      text?: string\n    } & Omit<BLinkProps, 'event' | 'routerTag'>\n  >(),\n  {\n    ariaCurrent: 'location',\n    text: undefined,\n    // Link props\n    active: false,\n    activeClass: 'router-link-active',\n    append: false,\n    disabled: false,\n    event: 'click',\n    href: undefined,\n    // noPrefetch: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    // prefetch: {type: [Boolean, String] as PropType<Booleanish>, default: null},\n    rel: undefined,\n    replace: false,\n    routerComponentName: 'router-link',\n    routerTag: 'a',\n    target: '_self',\n    to: undefined,\n    variant: undefined,\n    opacity: undefined,\n    opacityHover: undefined,\n    underlineVariant: null,\n    underlineOffset: undefined,\n    underlineOffsetHover: undefined,\n    underlineOpacity: undefined,\n    underlineOpacityHover: undefined,\n    icon: false,\n    // End link props\n  }\n)\n\nconst emit = defineEmits<{\n  click: [value: MouseEvent]\n}>()\n\nconst activeBoolean = useBooleanish(() => props.active)\nconst disabledBoolean = useBooleanish(() => props.disabled)\n\nconst computedClasses = computed(() => ({\n  active: activeBoolean.value,\n}))\n\nconst computedTag = computed<'span' | typeof BLink>(() => (activeBoolean.value ? 'span' : BLink))\n\nconst computedAriaCurrent = computed(() => (activeBoolean.value ? props.ariaCurrent : undefined))\n\nconst computedLinkProps = computed(() =>\n  computedTag.value !== 'span'\n    ? pluckProps(props, {\n        active: true,\n        activeClass: true,\n        append: true,\n        disabled: true,\n        href: true,\n        rel: true,\n        replace: true,\n        routerComponentName: true,\n        target: true,\n        to: true,\n        variant: true,\n        opacity: true,\n        opacityHover: true,\n        underlineVariant: true,\n        underlineOffset: true,\n        underlineOffsetHover: true,\n        underlineOpacity: true,\n        underlineOpacityHover: true,\n        icon: true,\n      } satisfies Record<keyof Omit<BLinkProps, 'event' | 'routerTag'>, true>)\n    : {}\n)\n\nconst clicked = (e: MouseEvent): void => {\n  if (disabledBoolean.value || activeBoolean.value) {\n    e.preventDefault()\n    e.stopImmediatePropagation()\n    return\n  }\n  if (!disabledBoolean.value) emit('click', e)\n}\n</script>\n","<template>\n  <nav aria-label=\"breadcrumb\">\n    <ol class=\"breadcrumb\">\n      <slot name=\"prepend\" />\n      <BBreadcrumbItem v-for=\"(item, i) in breadcrumbItemObjects\" :key=\"i\" v-bind=\"item\">\n        {{ item.text }}\n      </BBreadcrumbItem>\n      <slot />\n      <slot name=\"append\" />\n    </ol>\n  </nav>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed} from 'vue'\nimport {useBreadcrumb} from '../../composables'\nimport type {BreadcrumbItem, BreadcrumbItemObject} from '../../types'\nimport BBreadcrumbItem from './BBreadcrumbItem.vue'\n\nconst props = withDefaults(\n  defineProps<{\n    items?: BreadcrumbItem[]\n  }>(),\n  {items: undefined}\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  prepend?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  append?: (props: Record<string, never>) => any\n}>()\n\nconst breadcrumb = useBreadcrumb()\n\nconst breadcrumbItemObjects = computed<BreadcrumbItemObject[]>(() => {\n  const localItems = props.items || breadcrumb?.items || []\n  let activeDefined = false\n  const items = localItems.map((item, idx) => {\n    if (typeof item === 'string') {\n      item = {text: item}\n      if (idx < localItems.length - 1) item.href = '#'\n    }\n    if (item.active) activeDefined = true\n\n    // Auto-detect active by position in list\n    if (!item.active && !activeDefined) {\n      item.active = idx + 1 === localItems.length\n    }\n    return item\n  })\n  return items\n})\n</script>\n","<template>\n  <component :is=\"tag\" :class=\"computedClasses\" role=\"group\" :aria-label=\"ariaLabel\">\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish, Size} from '../../types'\nimport {computed} from 'vue'\nimport {useBooleanish} from '../../composables'\n\nconst props = withDefaults(\n  defineProps<{\n    ariaLabel?: string\n    size?: Size\n    tag?: string\n    vertical?: Booleanish\n  }>(),\n  {\n    ariaLabel: 'Group',\n    tag: 'div',\n    vertical: false,\n    size: 'md',\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst verticalBoolean = useBooleanish(() => props.vertical)\n\nconst computedClasses = computed(() => ({\n  'btn-group': !verticalBoolean.value,\n  [`btn-group-${props.size}`]: props.size !== 'md',\n  'btn-group-vertical': verticalBoolean.value,\n}))\n</script>\n","<template>\n  <div :class=\"computedClasses\" class=\"btn-toolbar\" :role=\"role\" :aria-label=\"ariaLabel\">\n    <slot />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish} from '../../types'\nimport {computed} from 'vue'\nimport {useBooleanish} from '../../composables'\n\nconst props = withDefaults(\n  defineProps<{\n    ariaLabel?: string\n    justify?: Booleanish\n    role?: string\n    // keyNav?: Booleanish\n  }>(),\n  {\n    role: 'toolbar',\n    ariaLabel: 'Group',\n    justify: false,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst justifyBoolean = useBooleanish(() => props.justify)\n\nconst computedClasses = computed(() => ({\n  'justify-content-between': justifyBoolean.value,\n}))\n</script>\n","<template>\n  <img :class=\"computedClasses\" v-bind=\"computedAttrs\" />\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish} from '../types'\nimport {useBooleanish} from '../composables'\nimport {computed} from 'vue'\n\nconst props = withDefaults(\n  defineProps<{\n    alt?: string\n    blank?: Booleanish\n    blankColor?: string\n    block?: Booleanish\n    center?: Booleanish\n    fluid?: Booleanish\n    lazy?: Booleanish\n    fluidGrow?: Booleanish\n    height?: number | string\n    start?: Booleanish\n    end?: Booleanish\n    rounded?: boolean | string\n    sizes?: string | string[]\n    src?: string\n    srcset?: string | string[]\n    thumbnail?: Booleanish\n    width?: number | string\n  }>(),\n  {\n    sizes: undefined,\n    src: undefined,\n    srcset: undefined,\n    width: undefined,\n    height: undefined,\n    alt: undefined,\n    blank: false,\n    lazy: false,\n    blankColor: 'transparent',\n    block: false,\n    center: false,\n    fluid: false,\n    fluidGrow: false,\n    end: false,\n    start: false,\n    rounded: false,\n    thumbnail: false,\n  }\n)\n\nconst BLANK_TEMPLATE =\n  '<svg width=\"%{w}\" height=\"%{h}\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 %{w} %{h}\" preserveAspectRatio=\"none\">' +\n  '<rect width=\"100%\" height=\"100%\" style=\"fill:%{f};\"></rect>' +\n  '</svg>'\n\nconst lazyBoolean = useBooleanish(() => props.lazy)\nconst blankBoolean = useBooleanish(() => props.blank)\nconst blockBoolean = useBooleanish(() => props.block)\nconst centerBoolean = useBooleanish(() => props.center)\nconst fluidBoolean = useBooleanish(() => props.fluid)\nconst fluidGrowBoolean = useBooleanish(() => props.fluidGrow)\nconst startBoolean = useBooleanish(() => props.start)\nconst endBoolean = useBooleanish(() => props.end)\nconst thumbnailBoolean = useBooleanish(() => props.thumbnail)\n\nconst computedSrcset = computed<string | undefined>(() =>\n  typeof props.srcset === 'string'\n    ? props.srcset\n        .split(',')\n        .filter((x) => x)\n        .join(',')\n    : Array.isArray(props.srcset)\n    ? props.srcset.filter((x) => x).join(',')\n    : undefined\n)\n\nconst computedSizes = computed<string | undefined>(() =>\n  typeof props.sizes === 'string'\n    ? props.sizes\n        .split(',')\n        .filter((x) => x)\n        .join(',')\n    : Array.isArray(props.sizes)\n    ? props.sizes.filter((x) => x).join(',')\n    : undefined\n)\n\n// TODO go through an makes number props type string | number\n// May be able to replace the internal util function with vueuse useToString/useToNumber utils\nconst computedDimentions = computed<{height: number | undefined; width: number | undefined}>(() => {\n  const parser = (str: string | number | undefined): number | undefined =>\n    str === undefined\n      ? undefined\n      : typeof str === 'number'\n      ? str\n      : Number.parseInt(str, 10) || undefined\n  const width = parser(props.width)\n  const height = parser(props.height)\n  if (blankBoolean.value) {\n    if (width !== undefined && height === undefined) {\n      return {height: width, width}\n    }\n    if (width === undefined && height !== undefined) {\n      return {height, width: height}\n    }\n    if (width === undefined && height === undefined) {\n      return {height: 1, width: 1}\n    }\n  }\n  return {\n    width,\n    height,\n  }\n})\n\nconst computedBlankImgSrc = computed(() =>\n  makeBlankImgSrc(computedDimentions.value.width, computedDimentions.value.height, props.blankColor)\n)\n\nconst computedAttrs = computed(() => ({\n  src: !blankBoolean.value ? props.src : computedBlankImgSrc.value,\n  alt: props.alt,\n  width: computedDimentions.value.width || undefined,\n  height: computedDimentions.value.height || undefined,\n  srcset: !blankBoolean.value ? computedSrcset.value : undefined,\n  sizes: !blankBoolean.value ? computedSizes.value : undefined,\n  loading: lazyBoolean.value ? 'lazy' : 'eager',\n}))\n\nconst alignment = computed<'float-start' | 'float-end' | 'mx-auto' | undefined>(() =>\n  startBoolean.value\n    ? 'float-start'\n    : endBoolean.value\n    ? 'float-end'\n    : centerBoolean.value\n    ? 'mx-auto'\n    : undefined\n)\n\nconst computedClasses = computed(() => ({\n  'img-thumbnail': thumbnailBoolean.value,\n  'img-fluid': fluidBoolean.value || fluidGrowBoolean.value,\n  'w-100': fluidGrowBoolean.value,\n  'rounded': props.rounded === '' || props.rounded === true,\n  [`rounded-${props.rounded}`]: typeof props.rounded === 'string' && props.rounded !== '',\n  [`${alignment.value}`]: alignment.value !== undefined,\n  'd-block': blockBoolean.value || centerBoolean.value,\n}))\n\nconst makeBlankImgSrc = (\n  width: number | undefined,\n  height: number | undefined,\n  color: string\n): string => {\n  const src = encodeURIComponent(\n    BLANK_TEMPLATE.replace('%{w}', String(width))\n      .replace('%{h}', String(height))\n      .replace('%{f}', color)\n  )\n  return `data:image/svg+xml;charset=UTF-8,${src}`\n}\n</script>\n","<template>\n  <BImg :class=\"baseClass\" v-bind=\"computedAttrs\" @load=\"emit('load', $event)\" />\n</template>\n\n<script setup lang=\"ts\">\nimport BImg from '../BImg.vue'\nimport type {Booleanish} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {computed} from 'vue'\n\nconst props = withDefaults(\n  defineProps<{\n    alt?: string\n    blank?: Booleanish\n    blankColor?: string\n    bottom?: Booleanish\n    lazy?: Booleanish\n    height?: number | string\n    start?: Booleanish\n    end?: Booleanish\n    sizes?: string | string[]\n    src?: string\n    srcset?: string | string[]\n    top?: Booleanish\n    width?: number | string\n  }>(),\n  {\n    sizes: undefined,\n    src: undefined,\n    height: undefined,\n    alt: undefined,\n    blankColor: undefined,\n    width: undefined,\n    srcset: undefined,\n    bottom: false,\n    end: false,\n    lazy: false,\n    start: false,\n    top: false,\n    blank: false,\n  }\n)\n\nconst emit = defineEmits<{\n  load: [value: Event]\n}>()\n\nconst bottomBoolean = useBooleanish(() => props.bottom)\nconst endBoolean = useBooleanish(() => props.end)\nconst startBoolean = useBooleanish(() => props.start)\nconst topBoolean = useBooleanish(() => props.top)\n\nconst baseClass = computed(() =>\n  topBoolean.value\n    ? 'card-img-top'\n    : endBoolean.value\n    ? 'card-img-right'\n    : bottomBoolean.value\n    ? 'card-img-bottom'\n    : startBoolean.value\n    ? 'card-img-left'\n    : 'card-img'\n)\n\n/**\n * Does not include the above baseClass used props so it does not cause potential issues\n */\nconst computedAttrs = computed(() => ({\n  alt: props.alt,\n  height: props.height,\n  src: props.src,\n  lazy: props.lazy,\n  width: props.width,\n  blank: props.blank,\n  blankColor: props.blankColor,\n  sizes: props.sizes,\n  srcset: props.srcset,\n}))\n</script>\n","<template>\n  <component :is=\"tag\" :class=\"computedClasses\">\n    <!-- eslint-disable-next-line vue/no-v-html -->\n    <div v-if=\"!!html\" v-html=\"html\" />\n    <slot v-else>\n      {{ text }}\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed} from 'vue'\nimport type {ColorVariant, TextColorVariant} from '../../types'\n\nconst props = withDefaults(\n  defineProps<{\n    text?: string\n    bgVariant?: ColorVariant | null\n    borderVariant?: ColorVariant | null\n    html?: string\n    tag?: string\n    textVariant?: TextColorVariant | null\n  }>(),\n  {\n    tag: 'div',\n    text: undefined,\n    bgVariant: null,\n    borderVariant: null,\n    html: undefined,\n    textVariant: null,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => ({\n  [`text-${props.textVariant}`]: props.textVariant !== null,\n  [`bg-${props.bgVariant}`]: props.bgVariant !== null,\n  [`border-${props.borderVariant}`]: props.borderVariant !== null,\n}))\n</script>\n","<template>\n  <component :is=\"tag\" class=\"card-subtitle mb-2\" :class=\"coomputedClasses\">\n    <slot>\n      {{ text }}\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport type {TextColorVariant} from '../../types'\nimport {computed} from 'vue'\n\nconst props = withDefaults(\n  defineProps<{\n    text?: string\n    tag?: string\n    textVariant?: TextColorVariant | null\n  }>(),\n  {\n    tag: 'h6',\n    textVariant: 'muted',\n    text: undefined,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst coomputedClasses = computed(() => ({\n  [`text-${props.textVariant}`]: props.textVariant !== null,\n}))\n</script>\n","<template>\n  <component :is=\"bodyTag\" class=\"card-body\" :class=\"computedClasses\">\n    <BCardTitle v-if=\"!!title || hasTitleSlot\" :tag=\"titleTag\">\n      <slot name=\"title\">\n        {{ title }}\n      </slot>\n    </BCardTitle>\n\n    <BCardSubtitle\n      v-if=\"!!subtitle || hasSubtitleSlot\"\n      :tag=\"subtitleTag\"\n      :text-variant=\"subtitleTextVariant\"\n    >\n      <slot name=\"subtitle\">\n        {{ subtitle }}\n      </slot>\n    </BCardSubtitle>\n\n    <slot>\n      {{ text }}\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, useSlots} from 'vue'\nimport BCardTitle from './BCardTitle.vue'\nimport {isEmptySlot} from '../../utils'\nimport BCardSubtitle from './BCardSubtitle.vue'\nimport type {Booleanish, ColorVariant, TextColorVariant} from '../../types'\nimport {useBooleanish} from '../../composables'\n\nconst props = withDefaults(\n  defineProps<{\n    bodyBgVariant?: ColorVariant | null\n    bodyTag?: string\n    bodyTextVariant?: TextColorVariant | null\n    overlay?: Booleanish\n    subtitle?: string\n    subtitleTag?: string\n    subtitleTextVariant?: TextColorVariant | null\n    title?: string\n    titleTag?: string\n    text?: string\n  }>(),\n  {\n    bodyTag: 'div',\n    overlay: false,\n    titleTag: 'h4',\n    subtitleTag: 'h4',\n    bodyBgVariant: null,\n    bodyTextVariant: null,\n    subtitleTextVariant: undefined,\n    subtitle: undefined,\n    title: undefined,\n    text: undefined,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  title?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  subtitle?: (props: Record<string, never>) => any\n}>()\n\nconst slots = useSlots()\n\nconst overlayBoolean = useBooleanish(() => props.overlay)\n\nconst hasTitleSlot = computed(() => !isEmptySlot(slots.title))\nconst hasSubtitleSlot = computed(() => !isEmptySlot(slots.subtitle))\n\nconst computedClasses = computed(() => ({\n  'card-img-overlay': overlayBoolean.value,\n  [`text-${props.bodyTextVariant}`]: props.bodyTextVariant !== null,\n  [`bg-${props.bodyBgVariant}`]: props.bodyBgVariant !== null,\n}))\n</script>\n","<template>\n  <component :is=\"tag\" class=\"card\" :class=\"computedClasses\">\n    <slot v-if=\"!imgBottomBoolean\" name=\"img\">\n      <BCardImg v-if=\"imgSrc\" v-bind=\"imgAttr\" />\n    </slot>\n    <BCardHeader\n      v-if=\"header || hasHeaderSlot || headerHtml\"\n      v-bind=\"headerAttrs\"\n      :class=\"headerClass\"\n    >\n      <slot name=\"header\">\n        {{ header }}\n      </slot>\n    </BCardHeader>\n    <BCardBody v-if=\"!noBodyBoolean\" v-bind=\"bodyAttrs\" :class=\"bodyClass\">\n      <slot>\n        {{ bodyText }}\n      </slot>\n    </BCardBody>\n    <slot v-else>\n      {{ bodyText }}\n    </slot>\n    <BCardFooter\n      v-if=\"footer || hasFooterSlot || footerHtml\"\n      v-bind=\"footerAttrs\"\n      :class=\"footerClass\"\n    >\n      <slot name=\"footer\">\n        {{ footer }}\n      </slot>\n    </BCardFooter>\n    <slot v-if=\"imgBottomBoolean\" name=\"img\">\n      <BCardImg v-if=\"imgSrc\" v-bind=\"imgAttr\" />\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport type {\n  AlignmentTextHorizontal,\n  Booleanish,\n  ClassValue,\n  ColorVariant,\n  TextColorVariant,\n} from '../../types'\nimport {isEmptySlot} from '../../utils'\nimport {computed, useSlots} from 'vue'\nimport {useBooleanish} from '../../composables'\nimport BCardImg from './BCardImg.vue'\nimport BCardHeader from './BCardHeader.vue'\nimport BCardBody from './BCardBody.vue'\nimport BCardFooter from './BCardFooter.vue'\n\nconst props = withDefaults(\n  defineProps<{\n    align?: AlignmentTextHorizontal\n    bgVariant?: ColorVariant | null\n    bodyBgVariant?: ColorVariant | null\n    bodyClass?: ClassValue\n    bodyTag?: string\n    bodyTextVariant?: TextColorVariant | null\n    borderVariant?: ColorVariant | null\n    footer?: string\n    footerBgVariant?: ColorVariant | null\n    footerBorderVariant?: ColorVariant | null\n    footerClass?: ClassValue\n    footerHtml?: string\n    footerTag?: string\n    footerTextVariant?: TextColorVariant | null\n    header?: string\n    headerBgVariant?: ColorVariant | null\n    headerBorderVariant?: ColorVariant | null\n    headerClass?: ClassValue\n    headerHtml?: string\n    headerTag?: string\n    headerTextVariant?: TextColorVariant | null\n    imgAlt?: string\n    imgBottom?: Booleanish\n    imgEnd?: Booleanish\n    imgHeight?: string | number\n    imgSrc?: string\n    imgStart?: Booleanish\n    imgTop?: Booleanish\n    imgWidth?: string | number\n    noBody?: Booleanish\n    overlay?: Booleanish\n    subtitle?: string\n    subtitleTag?: string\n    subtitleTextVariant?: TextColorVariant | null\n    tag?: string\n    textVariant?: TextColorVariant | null\n    title?: string\n    titleTag?: string\n    bodyText?: string\n  }>(),\n  {\n    align: undefined,\n    bgVariant: null,\n    bodyBgVariant: undefined,\n    bodyClass: undefined,\n    bodyTextVariant: undefined,\n    borderVariant: null,\n    footer: undefined,\n    footerBgVariant: undefined,\n    footerBorderVariant: undefined,\n    footerClass: undefined,\n    footerTextVariant: undefined,\n    header: undefined,\n    headerBgVariant: undefined,\n    headerBorderVariant: undefined,\n    headerClass: undefined,\n    textVariant: null,\n    headerTextVariant: undefined,\n    imgAlt: undefined,\n    title: undefined,\n    subtitle: undefined,\n    imgWidth: undefined,\n    imgHeight: undefined,\n    imgSrc: undefined,\n    bodyTag: 'div',\n    footerHtml: '',\n    footerTag: 'div',\n    headerHtml: '',\n    headerTag: 'div',\n    imgBottom: false,\n    imgEnd: false,\n    imgStart: false,\n    bodyText: '',\n    imgTop: false,\n    noBody: false,\n    overlay: false,\n    subtitleTag: 'h6',\n    subtitleTextVariant: 'muted',\n    tag: 'div',\n    titleTag: 'h4',\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  img?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  header?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  footer?: (props: Record<string, never>) => any\n}>()\n\nconst slots = useSlots()\n\nconst imgBottomBoolean = useBooleanish(() => props.imgBottom)\nconst imgEndBoolean = useBooleanish(() => props.imgEnd)\nconst imgStartBoolean = useBooleanish(() => props.imgStart)\nconst noBodyBoolean = useBooleanish(() => props.noBody)\n\nconst hasHeaderSlot = computed(() => !isEmptySlot(slots.header))\nconst hasFooterSlot = computed(() => !isEmptySlot(slots.footer))\n\nconst computedClasses = computed(() => ({\n  [`text-${props.align}`]: props.align !== undefined,\n  [`text-${props.textVariant}`]: props.textVariant !== null,\n  [`bg-${props.bgVariant}`]: props.bgVariant !== null,\n  [`border-${props.borderVariant}`]: props.borderVariant !== null,\n  'flex-row': imgStartBoolean.value,\n  'flex-row-reverse': imgEndBoolean.value,\n}))\n\nconst headerAttrs = computed(() => ({\n  bgVariant: props.headerBgVariant,\n  borderVariant: props.headerBorderVariant,\n  html: props.headerHtml,\n  tag: props.headerTag,\n  textVariant: props.headerTextVariant,\n}))\n\nconst bodyAttrs = computed(() => ({\n  overlay: props.overlay,\n  bodyBgVariant: props.bodyBgVariant,\n  bodyTag: props.bodyTag,\n  bodyTextVariant: props.bodyTextVariant,\n  subtitle: props.subtitle,\n  subtitleTag: props.subtitleTag,\n  subtitleTextVariant: props.subtitleTextVariant,\n  title: props.title,\n  titleTag: props.titleTag,\n}))\n\nconst footerAttrs = computed(() => ({\n  bgVariant: props.footerBgVariant,\n  borderVariant: props.footerBorderVariant,\n  html: props.footerHtml,\n  tag: props.footerTag,\n  textVariant: props.footerTextVariant,\n}))\n\nconst imgAttr = computed(() => ({\n  src: props.imgSrc,\n  alt: props.imgAlt,\n  height: props.imgHeight,\n  width: props.imgWidth,\n  bottom: props.imgBottom,\n  end: props.imgEnd,\n  start: props.imgStart,\n  top: props.imgTop,\n}))\n</script>\n","<template>\n  <component :is=\"tag\" :class=\"computedClasses\">\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed} from 'vue'\nimport type {Booleanish} from '../../types'\nimport {useBooleanish} from '../../composables'\n\nconst props = withDefaults(\n  defineProps<{\n    columns?: Booleanish\n    deck?: Booleanish\n    tag?: string\n  }>(),\n  {\n    columns: false,\n    deck: false,\n    tag: 'div',\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst columnsBoolean = useBooleanish(() => props.columns)\nconst deckBoolean = useBooleanish(() => props.deck)\n\nconst cardTypeClass = computed(() =>\n  deckBoolean.value ? 'card-deck' : columnsBoolean.value ? 'card-columns' : 'card-group'\n)\n\nconst computedClasses = computed(() => [cardTypeClass.value])\n</script>\n","<template>\n  <div\n    :id=\"computedId\"\n    ref=\"element\"\n    :class=\"computedClasses\"\n    @keydown.left=\"onKeydown(prev)\"\n    @keydown.right=\"onKeydown(next)\"\n    @mouseenter.stop=\"onMouseEnter\"\n    @mouseleave.stop=\"onMouseLeave\"\n  >\n    <div v-if=\"indicatorsBoolean\" class=\"carousel-indicators\">\n      <!-- :data-bs-target=\"`#${computedId}`\" is required since the classes target elems with that attr -->\n      <button\n        v-for=\"(_, i) in slides.length\"\n        :key=\"i\"\n        type=\"button\"\n        data-bs-target=\"\"\n        :class=\"i === modelValue ? 'active' : ''\"\n        :aria-current=\"i === modelValue ? true : undefined\"\n        :aria-label=\"`${indicatorsButtonLabel} ${i}`\"\n        @click=\"goToValue(i)\"\n      />\n    </div>\n\n    <div ref=\"relatedTarget\" class=\"carousel-inner\">\n      <TransitionGroup\n        :enter-from-class=\"enterClasses\"\n        :enter-active-class=\"enterClasses\"\n        :enter-to-class=\"enterClasses\"\n        :leave-from-class=\"leaveClasses\"\n        :leave-active-class=\"leaveClasses\"\n        :leave-to-class=\"leaveClasses\"\n        @before-leave=\"onBeforeLeave\"\n        @after-leave=\"onAfterLeave\"\n      >\n        <component\n          :is=\"slide\"\n          v-for=\"(slide, i) in slides\"\n          v-show=\"i === modelValue\"\n          :key=\"i\"\n          :class=\"{active: i === modelValue && isTransitioning === false}\"\n        />\n      </TransitionGroup>\n    </div>\n\n    <template v-if=\"controlsBoolean\">\n      <button class=\"carousel-control-prev\" type=\"button\" @click=\"prev\">\n        <span class=\"carousel-control-prev-icon\" aria-hidden=\"true\" />\n        <span class=\"visually-hidden\">{{ controlsPrevText }}</span>\n      </button>\n      <button class=\"carousel-control-next\" type=\"button\" @click=\"next\">\n        <span class=\"carousel-control-next-icon\" aria-hidden=\"true\" />\n        <span class=\"visually-hidden\">{{ controlsNextText }}</span>\n      </button>\n    </template>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport {\n  BvCarouselEvent,\n  carouselInjectionKey,\n  getSlotElements,\n  isBooleanish,\n  resolveBooleanish,\n} from '../../utils'\nimport {computed, provide, readonly, ref, toRef, useSlots, watch} from 'vue'\nimport {useBooleanish, useId} from '../../composables'\nimport type {Booleanish} from '../../types'\nimport {useIntervalFn, useSwipe, useToNumber, useVModel} from '@vueuse/core'\n\nconst props = withDefaults(\n  defineProps<{\n    ride?: true | false | 'true' | 'false' | '' | 'carousel' // Booleanish | 'carousel'\n    noHoverPause?: Booleanish\n    rideReverse?: Booleanish\n    fade?: Booleanish\n    id?: string\n    imgHeight?: string\n    imgWidth?: string\n    background?: string\n    modelValue?: number\n    controls?: Booleanish\n    indicators?: Booleanish\n    interval?: number\n    noTouch?: Booleanish\n    noWrap?: Booleanish\n    controlsPrevText?: string\n    controlsNextText?: string\n    indicatorsButtonLabel?: string\n    keyboard?: Booleanish\n    touchThreshold?: number | string\n  }>(),\n  {\n    id: undefined,\n    imgHeight: undefined,\n    imgWidth: undefined,\n    background: undefined,\n    ride: false,\n    noHoverPause: false,\n    rideReverse: false,\n    modelValue: 0,\n    fade: false,\n    controls: false,\n    indicators: false,\n    keyboard: true,\n    interval: 5000,\n    noTouch: false,\n    noWrap: false,\n    controlsNextText: 'Next',\n    controlsPrevText: 'Previous',\n    indicatorsButtonLabel: 'Slide',\n    touchThreshold: 50,\n  }\n)\n\nconst emit = defineEmits<{\n  'slid': [value: BvCarouselEvent]\n  'slide': [value: BvCarouselEvent]\n  'update:modelValue': [value: number]\n}>()\n\nconst slots = useSlots()\n\nconst computedId = useId(() => props.id, 'carousel')\n\nconst modelValue = useVModel(props, 'modelValue', emit, {passive: true})\n\nconst keyboardBoolean = useBooleanish(() => props.keyboard)\nconst rideReverseBoolean = useBooleanish(() => props.rideReverse)\nconst noHoverPauseBoolean = useBooleanish(() => props.noHoverPause)\nconst fadeBoolean = useBooleanish(() => props.fade)\nconst controlsBoolean = useBooleanish(() => props.controls)\nconst indicatorsBoolean = useBooleanish(() => props.indicators)\nconst noTouchBoolean = useBooleanish(() => props.noTouch)\nconst noWrapBoolean = useBooleanish(() => props.noWrap)\nconst touchThresholdNumber = useToNumber(() => props.touchThreshold, {\n  nanToZero: true,\n  method: 'parseInt',\n})\n\nconst isTransitioning = ref(false)\nconst rideStarted = ref(false)\nconst direction = ref(true)\nconst relatedTarget = ref<HTMLElement | null>(null)\nconst element = ref<HTMLElement | null>(null)\nconst previousModelValue = ref(modelValue.value)\n\nconst rideResolved = computed<boolean | 'carousel'>(() =>\n  isBooleanish(props.ride) ? resolveBooleanish(props.ride) : props.ride\n)\n\n// Class carousel-item is a static property\n// If you make it static, the direction can be reversed -- properly (atm it does the carousel-item-${} logic backwards for entering, a weird hack)\n// So all that would be great. However, when you do this, it will break the transition flow. Something about it breaks and I'm not sure why!\n// Try it by removing carousel-item from below and making `!direction.value` => `direction.value` for enter\n// Then reviewing the behavior\nconst enterClasses = computed(\n  () =>\n    `carousel-item carousel-item-${!direction.value ? 'next' : 'prev'} carousel-item-${\n      !direction.value ? 'start' : 'end'\n    }`\n)\nconst leaveClasses = computed(\n  () => `carousel-item active carousel-item-${direction.value ? 'start' : 'end'}`\n)\n\nconst {pause, resume} = useIntervalFn(\n  () => {\n    rideReverseBoolean.value ? prev() : next()\n  },\n  () => props.interval,\n  {immediate: rideResolved.value === 'carousel'}\n)\n\nconst isRiding = computed(\n  () =>\n    (rideResolved.value === true && rideStarted.value === true) || rideResolved.value === 'carousel'\n)\nconst slides = computed(() => getSlotElements(slots.default, 'BCarouselSlide'))\nconst computedClasses = computed(() => [\n  'carousel',\n  'slide',\n  'pointer-event',\n  {'carousel-fade': fadeBoolean.value},\n])\n// TODO a general idea of showing only slides that are in bounds\n// const localValue = computed(() =>\n//   props.modelValue >= slides.value.length\n//     ? slides.value.length - 1\n//     : props.modelValue < 0\n//     ? 0\n//     : props.modelValue\n// )\n\nconst buildBvCarouselEvent = (event: 'slid' | 'slide') =>\n  new BvCarouselEvent(event, {\n    componentId: computedId.value,\n    cancelable: false,\n    target: element.value,\n    direction: direction.value ? 'right' : 'left',\n    from: previousModelValue.value,\n    to: modelValue.value,\n    relatedTarget: relatedTarget.value?.children[modelValue.value] ?? null,\n  })\n\nconst goToValue = (value: number): void => {\n  if (isTransitioning.value === true) return\n\n  if (rideResolved.value === true) {\n    rideStarted.value = true\n  }\n  if (isRiding.value === true) {\n    resume()\n  }\n  direction.value = value < modelValue.value ? false : true\n  if (value >= slides.value.length) {\n    if (noWrapBoolean.value) return\n    modelValue.value = 0\n    return\n  }\n  if (value < 0) {\n    if (noWrapBoolean.value) return\n    modelValue.value = slides.value.length - 1\n    return\n  }\n  previousModelValue.value = modelValue.value\n  modelValue.value = value\n}\n\nconst prev = (): void => {\n  goToValue(modelValue.value - 1)\n}\nconst next = (): void => {\n  goToValue(modelValue.value + 1)\n}\n\nconst onKeydown = (fn: () => void) => {\n  if (keyboardBoolean.value === false) return\n  fn()\n}\n\nconst onMouseEnter = () => {\n  if (noHoverPauseBoolean.value) return\n  pause()\n}\nconst onMouseLeave = () => {\n  if (!isRiding.value) return\n  resume()\n}\n\nconst {lengthX} = useSwipe(element, {\n  passive: true,\n  onSwipeStart() {\n    if (noTouchBoolean.value === true) return\n    pause()\n  },\n  onSwipeEnd() {\n    if (noTouchBoolean.value === true) return\n    const resumeRiding = () => {\n      if (isRiding.value === false) return\n      resume()\n    }\n    if (lengthX.value >= touchThresholdNumber.value) {\n      next()\n      resumeRiding()\n      return\n    }\n    if (lengthX.value <= -touchThresholdNumber.value) {\n      prev()\n      resumeRiding()\n    }\n  },\n})\n\nconst onBeforeLeave = () => {\n  emit('slide', buildBvCarouselEvent('slide'))\n  isTransitioning.value = true\n}\nconst onAfterLeave = () => {\n  emit('slid', buildBvCarouselEvent('slid'))\n  isTransitioning.value = false\n}\n\nwatch(\n  () => props.ride,\n  () => {\n    rideStarted.value = false\n  }\n)\n\ndefineExpose({pause, resume, prev, next})\n\nprovide(carouselInjectionKey, {\n  background: readonly(toRef(props, 'background')),\n  width: readonly(toRef(props, 'imgWidth')),\n  height: readonly(toRef(props, 'imgHeight')),\n})\n</script>\n","<template>\n  <div class=\"carousel-item\" :style=\"computedStyle\">\n    <slot name=\"img\">\n      <BImg\n        class=\"d-block w-100\"\n        :alt=\"imgAlt\"\n        :src=\"imgSrc\"\n        :width=\"imgWidth || parentData?.width.value\"\n        :height=\"imgHeight || parentData?.height.value\"\n        :blank=\"imgBlank\"\n        :blank-color=\"imgBlankColor\"\n      />\n    </slot>\n    <component\n      :is=\"contentTag\"\n      v-if=\"hasContent\"\n      class=\"carousel-caption\"\n      :class=\"computedContentClasses\"\n    >\n      <component :is=\"captionTag\" v-if=\"hasCaption\">\n        <slot name=\"caption\">\n          <!-- eslint-disable-next-line vue/no-v-html -->\n          <span v-if=\"captionHtml\" v-html=\"captionHtml\" />\n          <span v-else>{{ caption }}</span>\n        </slot>\n      </component>\n      <component :is=\"textTag\" v-if=\"hasText\">\n        <slot name=\"text\">\n          <!-- eslint-disable-next-line vue/no-v-html -->\n          <span v-if=\"textHtml\" v-html=\"textHtml\" />\n          <span v-else>{{ text }}</span>\n        </slot>\n      </component>\n      <slot />\n    </component>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, type CSSProperties, inject, useSlots} from 'vue'\nimport type {Booleanish} from '../../types'\nimport {carouselInjectionKey, isEmptySlot} from '../../utils'\nimport BImg from '../BImg.vue'\n\n// TODO interval is unused\n// Need to add https://getbootstrap.com/docs/5.3/components/carousel/#individual-carousel-item-interval\n// Perhaps a provide/inject with next/prev values where the component can call those would work.\n\nconst props = withDefaults(\n  defineProps<{\n    imgSrc?: string\n    imgHeight?: string | number\n    imgWidth?: string | number\n    interval?: string | number\n    background?: string\n    caption?: string\n    captionHtml?: string\n    captionTag?: string\n    contentTag?: string\n    contentVisibleUp?: string\n    id?: string\n    imgAlt?: string\n    imgBlank?: Booleanish\n    imgBlankColor?: string\n    text?: string\n    textHtml?: string\n    textTag?: string\n  }>(),\n  {\n    imgSrc: undefined,\n    imgHeight: undefined,\n    imgWidth: undefined,\n    interval: undefined,\n    text: undefined,\n    textHtml: undefined,\n    id: undefined,\n    imgAlt: undefined,\n    contentVisibleUp: undefined,\n    background: undefined,\n    caption: undefined,\n    captionHtml: undefined,\n    captionTag: 'h3',\n    contentTag: 'div',\n    imgBlank: false,\n    imgBlankColor: 'transparent',\n    textTag: 'p',\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  img?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  caption?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  text?: (props: Record<string, never>) => any\n}>()\n\nconst slots = useSlots()\n\nconst parentData = inject(carouselInjectionKey, null)\n\nconst hasText = computed(() => props.text || props.textHtml || !isEmptySlot(slots.text))\nconst hasCaption = computed(() => props.caption || props.captionHtml || !isEmptySlot(slots.caption))\nconst hasContent = computed(() => hasText.value || hasCaption.value || !isEmptySlot(slots.default))\n\nconst computedStyle = computed<CSSProperties>(() => ({\n  background: `${\n    props.background || parentData?.background.value || 'rgb(171, 171, 171)'\n  } none repeat scroll 0% 0%`,\n}))\n\nconst computedContentClasses = computed(() => ({\n  'd-none': props.contentVisibleUp !== undefined,\n  [`d-${props.contentVisibleUp}-block`]: props.contentVisibleUp !== undefined,\n}))\n</script>\n","<template>\n  <component :is=\"tag\" :class=\"computedClasses\">\n    <slot />\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport {computed, defineComponent, type PropType, type SlotsType} from 'vue'\nimport type {AlignmentVertical, Booleanish} from '../types'\nimport {getBreakpointProps, getClasses} from '../utils'\nimport {useBooleanish} from '../composables'\n\nconst breakpointCol = getBreakpointProps('', [], {type: [Boolean, String, Number], default: false})\nconst breakpointOffset = getBreakpointProps('offset', [''], {type: [String, Number], default: null})\nconst breakpointOrder = getBreakpointProps('order', [''], {type: [String, Number], default: null})\n\nexport default defineComponent({\n  name: 'BCol',\n  slots: Object as SlotsType<{\n    default?: Record<string, never>\n  }>,\n  props: {\n    col: {type: [Boolean, String] as PropType<Booleanish>, default: false}, // Generic flexbox .col (xs)\n    cols: {type: [String, Number], default: null}, // .col-[1-12]|auto (xs)\n    ...breakpointCol,\n    offset: {type: [String, Number], default: null},\n    ...breakpointOffset,\n    order: {type: [String, Number], default: null},\n    ...breakpointOrder,\n    alignSelf: {type: String as PropType<AlignmentVertical | 'auto'>, default: null},\n    tag: {type: String, default: 'div'},\n  },\n  setup(props) {\n    const properties = [\n      {content: breakpointCol, propPrefix: 'cols', classPrefix: 'col'},\n      {content: breakpointOffset, propPrefix: 'offset'},\n      {content: breakpointOrder, propPrefix: 'order'},\n    ]\n\n    const colBoolean = useBooleanish(() => props.col)\n\n    const classList = computed(() =>\n      properties.flatMap((el) => getClasses(props, el.content, el.propPrefix, el.classPrefix))\n    )\n\n    const computedClasses = computed(() => [\n      classList.value,\n      {\n        col: colBoolean.value || (!classList.value.some((e) => /^col-/.test(e)) && !props.cols),\n        [`col-${props.cols}`]: !!props.cols,\n        [`offset-${props.offset}`]: !!props.offset,\n        [`order-${props.order}`]: !!props.order,\n        [`align-self-${props.alignSelf}`]: !!props.alignSelf,\n      },\n    ])\n\n    return {\n      computedClasses,\n    }\n  },\n})\n</script>\n","import type {BootstrapVueOptions, ColorVariant, ContainerPosition} from '../../types'\nimport {getId} from '../../utils'\nimport {\n  type App,\n  type ComponentPublicInstance,\n  computed,\n  type ComputedRef,\n  inject,\n  isReactive,\n  type Plugin,\n  reactive,\n  type Ref,\n  type VNode,\n} from 'vue'\n\nexport interface ToastContent {\n  title?: string\n  body?: string | VNode\n}\n\nexport interface ToastOptions {\n  autoHide?: boolean\n  delay?: number\n  id?: string\n  noCloseButton?: boolean\n  pos?: ContainerPosition\n  value?: boolean // show or hide\n  variant?: ColorVariant | null\n}\n\nexport interface Toast {\n  options: ToastOptions\n  content: ToastContent\n}\n\nexport type BodyProp = ToastContent['body']\n\n// Toast ViewModel, Each toast instance controls one view model\nexport interface ToastVM {\n  container: VMContainer | undefined\n  toasts: Toast[]\n  root: boolean\n  id: symbol\n}\n\ntype VMContainer = Ref<ComponentPublicInstance | null>\n\ninterface ToastContainers {\n  [key: symbol]: ToastVM\n}\n\nconst defaultToastOptions: ToastOptions = {\n  autoHide: true,\n  delay: 5000,\n  noCloseButton: false,\n  pos: 'top-right',\n  value: true,\n}\n\nexport class ToastInstance {\n  vm: ToastVM\n  containerPositions: ComputedRef<Set<ContainerPosition>>\n\n  constructor(vm: ToastVM) {\n    if (isReactive(vm)) {\n      this.vm = vm\n    } else {\n      this.vm = reactive(vm) as ToastVM\n    }\n\n    this.containerPositions = computed<Set<ContainerPosition>>(() => {\n      const s = new Set<ContainerPosition>([])\n      this.vm.toasts.map((toast) => {\n        if (toast.options.pos) {\n          s.add(toast.options.pos)\n        }\n      })\n      return s\n    })\n  }\n\n  toasts(position?: ContainerPosition): ComputedRef<Toast[]> {\n    if (position) {\n      return computed<Toast[]>(() =>\n        this.vm.toasts.filter((toast) => {\n          if (toast.options.pos === position && toast.options.value) {\n            return toast\n          }\n        })\n      )\n    }\n\n    return computed(() => this.vm.toasts)\n  }\n\n  remove(...forDeletion: [string]): void {\n    this.vm.toasts = this.vm.toasts.filter((item) => {\n      if (item.options.id && !forDeletion.includes(item.options.id)) {\n        return item\n      }\n    })\n  }\n\n  isRoot(): boolean {\n    return this.vm.root ?? false\n  }\n\n  show(content: ToastContent, options: ToastOptions = defaultToastOptions): Toast {\n    const topts: ToastOptions = {id: getId(), ...defaultToastOptions, ...options}\n\n    const toast: Toast = {\n      options: reactive(topts),\n      content,\n    }\n    this.vm.toasts.push(toast)\n    return toast\n  }\n\n  info(content: ToastContent, options: ToastOptions = defaultToastOptions): Toast {\n    return this.show(content, {variant: 'info', ...options})\n  }\n\n  danger(content: ToastContent, options: ToastOptions = defaultToastOptions): Toast {\n    return this.show(content, {variant: 'danger', ...options})\n  }\n\n  warning(content: ToastContent, options: ToastOptions = defaultToastOptions): Toast {\n    return this.show(content, {variant: 'warning', ...options})\n  }\n\n  success(content: ToastContent, options: ToastOptions = defaultToastOptions): Toast {\n    return this.show(content, {variant: 'success', ...options})\n  }\n\n  hide(): void {\n    //empty...\n  }\n}\n\nexport class ToastController {\n  vms: ToastContainers\n  rootInstance?: symbol\n\n  constructor() {\n    this.vms = {}\n  }\n\n  // Assume Root Vm if no parameters are passed\n  public getOrCreateViewModel(): ToastVM\n  public getOrCreateViewModel(vm?: ToastVM): ToastVM\n  public getOrCreateViewModel(vm?: any): ToastVM {\n    if (!vm) {\n      if (this.rootInstance) {\n        return this.vms[this.rootInstance]\n      }\n      const vm: ToastVM = {root: true, toasts: [], container: undefined, id: Symbol('toast')}\n      this.rootInstance = vm.id\n      this.vms[vm.id] = vm\n      return vm\n    }\n    if (vm.root) {\n      // lets see if we have a root instance\n      if (this.rootInstance) {\n        return this.vms[this.rootInstance]\n      }\n\n      this.rootInstance = vm.id\n    }\n    this.vms[vm.id] = vm\n    return vm\n  }\n\n  public getVM(): ToastVM | undefined\n  public getVM(id?: symbol): ToastVM | undefined\n  public getVM(id?: any): ToastVM | undefined {\n    if (!id && this.rootInstance) {\n      return this.vms[this.rootInstance]\n    } else if (id) {\n      return this.vms[id]\n    }\n\n    return undefined\n  }\n\n  useToast = useToast\n}\n\n// default global inject key to fetch the controller\nconst injectkey = Symbol('toast')\nconst fetchKey = Symbol('toastFetch')\n\nconst defaults = {\n  container: undefined,\n  toasts: [],\n  root: false,\n}\n\nexport function getKey(): any {\n  return inject(fetchKey)\n}\n\nexport function useToast(): ToastInstance | undefined\nexport function useToast(vm: {id: symbol}, key?: symbol): ToastInstance | undefined\nexport function useToast(\n  vm: {container: Ref<ComponentPublicInstance>; root: boolean},\n  key?: symbol\n): ToastInstance | undefined\n\nexport function useToast(vm?: any, key: symbol = injectkey): ToastInstance | undefined {\n  //let's get our controller to fetch the toast instance\n  const controller = inject(getKey()) as ToastController\n\n  // not parameters passed, use root if defined\n  if (!vm) {\n    return new ToastInstance(controller.getOrCreateViewModel())\n  }\n\n  // use toast generically\n  const vm_id = {id: Symbol('toastInstance')}\n  const local_vm: ToastVM = {...defaults, ...vm_id, ...vm}\n  const vm_instance = controller.getOrCreateViewModel(local_vm)\n  return new ToastInstance(vm_instance)\n}\n\nconst BToastPlugin: Plugin = {\n  install: (app: App, options?: BootstrapVueOptions) => {\n    const key =\n      typeof options?.BToast === 'object' ? options?.BToast?.injectkey ?? injectkey : injectkey\n    app.provide(fetchKey, key)\n    app.provide(key, new ToastController())\n  },\n}\n\nexport {BToastPlugin}\nexport default BToastPlugin\n","<script lang=\"ts\">\nimport {\n  computed,\n  defineComponent,\n  h,\n  nextTick,\n  onMounted,\n  onUnmounted,\n  type PropType,\n  ref,\n  type VNode,\n  watch,\n} from 'vue'\nimport {isLink, normalizeSlot, requestAF, toInteger} from '../../utils'\nimport {useBooleanish} from '../../composables'\nimport type {Booleanish, ColorVariant} from '../../types'\nimport BTransition from '../BTransition/BTransition.vue'\nimport BCloseButton from '../BButton/BCloseButton.vue'\nimport BLink, {BLINK_PROPS} from '../BLink/BLink.vue'\nimport type {BodyProp} from './plugin'\n\nexport const SLOT_NAME_TOAST_TITLE = 'toast-title'\nconst MIN_DURATION = 1000\n\nexport default defineComponent({\n  components: {BLink},\n  props: {\n    ...BLINK_PROPS,\n    delay: {type: Number, default: 5000},\n    bodyClass: {type: String, default: undefined},\n    body: {type: [Object, String] as PropType<BodyProp>, default: undefined},\n    headerClass: {type: String, default: undefined},\n    headerTag: {type: String, default: 'div'},\n    animation: {type: [Boolean, String] as PropType<Booleanish>, default: true},\n    id: {type: String, default: undefined},\n    // Switches role to 'status' and aria-live to 'polite'\n    isStatus: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    autoHide: {type: [Boolean, String] as PropType<Booleanish>, default: true},\n    noCloseButton: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    noFade: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    noHoverPause: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    solid: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    // Render the toast in place, rather than in a portal-target\n    static: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    title: {type: String, default: undefined},\n    modelValue: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    toastClass: {type: Array as PropType<string[]>, default: undefined},\n    variant: {type: String as PropType<ColorVariant | null>, default: null},\n  },\n  emits: ['destroyed', 'update:modelValue'],\n  setup(props, {emit, slots}) {\n    // TODO animation is never used\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const animationBoolean = useBooleanish(() => props.animation)\n    const isStatusBoolean = useBooleanish(() => props.isStatus)\n    const autoHideBoolean = useBooleanish(() => props.autoHide)\n    const noCloseButtonBoolean = useBooleanish(() => props.noCloseButton)\n    const noFadeBoolean = useBooleanish(() => props.noFade)\n    const noHoverPauseBoolean = useBooleanish(() => props.noHoverPause)\n    // TODO solid is never used\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const solidBoolean = useBooleanish(() => props.solid)\n    // TODO static is never used\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const staticBoolean = useBooleanish(() => props.static)\n    const modelValueBoolean = useBooleanish(() => props.modelValue)\n\n    const isTransitioning = ref(false)\n    const isHiding = ref(false)\n    const localShow = ref(false)\n    const classes = computed(() => ({\n      [`b-toast-${props.variant}`]: props.variant !== null,\n      show: localShow.value || isTransitioning.value,\n    }))\n\n    let dismissTimer: ReturnType<typeof setTimeout> | undefined\n    let dismissStarted: number\n    let resumeDismiss: number\n\n    const clearDismissTimer = () => {\n      if (typeof dismissTimer === 'undefined') return\n      clearTimeout(dismissTimer)\n      dismissTimer = undefined\n    }\n\n    const computedDuration = computed(() =>\n      // Minimum supported duration is 1 second\n      Math.max(toInteger(props.delay, 0), MIN_DURATION)\n    )\n\n    const hide = () => {\n      if (modelValueBoolean.value) {\n        dismissStarted = resumeDismiss = 0\n        clearDismissTimer()\n        isHiding.value = true\n        requestAF(() => {\n          localShow.value = false\n        })\n      }\n    }\n\n    const show = () => {\n      clearDismissTimer()\n      emit('update:modelValue', true)\n      dismissStarted = resumeDismiss = 0\n      isHiding.value = false\n\n      nextTick(() => {\n        // We show the toast after we have rendered the portal and b-toast wrapper\n        // so that screen readers will properly announce the toast\n        requestAF(() => {\n          localShow.value = true\n        })\n      })\n    }\n\n    const onPause = () => {\n      if (!autoHideBoolean.value || noHoverPauseBoolean.value || !dismissTimer || resumeDismiss) {\n        return\n      }\n\n      const passed = Date.now() - dismissStarted\n\n      if (passed > 0) {\n        clearDismissTimer()\n        resumeDismiss = Math.max(computedDuration.value - passed, MIN_DURATION)\n      }\n    }\n\n    const onUnPause = () => {\n      if (!autoHideBoolean.value || noHoverPauseBoolean.value || !resumeDismiss) {\n        resumeDismiss = dismissStarted = 0\n      }\n\n      startDismissTimer()\n    }\n\n    watch(modelValueBoolean, (newValue) => {\n      newValue ? show() : hide()\n    })\n\n    const startDismissTimer = () => {\n      clearDismissTimer()\n      if (autoHideBoolean.value) {\n        dismissTimer = setTimeout(hide, resumeDismiss || computedDuration.value)\n        dismissStarted = Date.now()\n        resumeDismiss = 0\n      }\n    }\n\n    const OnBeforeEnter = () => {\n      isTransitioning.value = true\n      emit('update:modelValue', true)\n    }\n\n    const OnAfterEnter = () => {\n      isTransitioning.value = false\n      startDismissTimer()\n    }\n\n    const OnBeforeLeave = () => {\n      isTransitioning.value = true\n    }\n\n    const OnAfterLeave = () => {\n      isTransitioning.value = false\n      resumeDismiss = dismissStarted = 0\n      emit('update:modelValue', false)\n    }\n\n    onUnmounted(() => {\n      //if there is time left on autoHide or no autoHide then keep toast alive\n      clearDismissTimer()\n      if (!autoHideBoolean.value) {\n        return\n      }\n\n      emit('destroyed', props.id)\n    })\n\n    onMounted(() => {\n      nextTick(() => {\n        if (modelValueBoolean.value) {\n          requestAF(() => {\n            show()\n          })\n        }\n      })\n    })\n\n    const onLinkClick = () => {\n      nextTick(() => {\n        requestAF(() => {\n          hide()\n        })\n      })\n    }\n\n    return () => {\n      const makeToast = () => {\n        const $headerContent: VNode[] = []\n\n        const $title = normalizeSlot(SLOT_NAME_TOAST_TITLE, {hide}, slots)\n\n        if ($title) {\n          $headerContent.push(h($title))\n        } else if (props.title) {\n          $headerContent.push(h('strong', {class: 'me-auto'}, props.title))\n        }\n\n        if (!noCloseButtonBoolean.value && $headerContent.length !== 0) {\n          $headerContent.push(\n            h(BCloseButton, {\n              class: ['btn-close'],\n              onClick: () => {\n                hide()\n              },\n            })\n          )\n        }\n        const $innertoast = []\n\n        if ($headerContent.length > 0) {\n          $innertoast.push(\n            h(\n              props.headerTag,\n              {\n                class: 'toast-header',\n              },\n              {default: () => $headerContent}\n            )\n          )\n        }\n        if (normalizeSlot('default', {hide}, slots) || props.body) {\n          const $body = h(\n            isLink(props) ? 'b-link' : 'div',\n            {\n              class: ['toast-body', props.bodyClass],\n              onClick: isLink(props) ? {click: onLinkClick} : {},\n            },\n            normalizeSlot('default', {hide}, slots) || props.body\n          )\n          $innertoast.push($body)\n        }\n        return h(\n          'div',\n          {\n            class: ['toast', props.toastClass, classes.value],\n            tabindex: '0',\n          },\n          $innertoast\n        )\n      }\n      //toast\n      return h(\n        'div',\n        {\n          'class': ['b-toast'],\n          'id': props.id,\n          'role': isHiding.value ? null : isStatusBoolean.value ? 'status' : 'alert',\n          'aria-live': isHiding.value ? null : isStatusBoolean.value ? 'polite' : 'assertive',\n          'aria-atomic': isHiding.value ? null : true,\n          'onmouseenter': onPause,\n          'onmouseleave': onUnPause,\n        },\n        [\n          h(\n            BTransition,\n            {\n              noFade: noFadeBoolean.value,\n              onAfterEnter: OnAfterEnter,\n              onBeforeEnter: OnBeforeEnter,\n              onAfterLeave: OnAfterLeave,\n              onBeforeLeave: OnBeforeLeave,\n            },\n            () => [localShow.value ? makeToast() : '']\n          ),\n        ]\n      )\n    }\n  },\n})\n</script>\n","<template>\n  <div :class=\"[positionClass]\" class=\"b-toaster position-fixed p-3\" style=\"z-index: 11\">\n    <BToast\n      v-for=\"toast in instance?.toasts(position).value\"\n      :id=\"toast.options.id\"\n      :key=\"toast.options.id\"\n      v-model=\"toast.options.value\"\n      :auto-hide=\"toast.options.autoHide\"\n      :delay=\"toast.options.delay\"\n      :no-close-button=\"toast.options.noCloseButton\"\n      :title=\"toast.content.title\"\n      :body=\"toast.content.body\"\n      :component=\"toast.content.body\"\n      :variant=\"toast.options.variant\"\n      @destroyed=\"handleDestroy\"\n    />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed} from 'vue'\nimport type {ContainerPosition} from '../../types'\nimport type {ToastInstance} from '../BToast/plugin'\nimport BToast from './BToast.vue'\n\nconst props = withDefaults(\n  defineProps<{\n    position?: ContainerPosition\n    instance?: ToastInstance\n    // appendToast?: Booleanish\n  }>(),\n  {\n    position: 'top-right',\n    instance: undefined,\n  }\n)\n\nconst toastPositions: Record<ContainerPosition, string> = {\n  'top-left': 'top-0 start-0',\n  'top-center': 'top-0 start-50 translate-middle-x',\n  'top-right': 'top-0 end-0',\n  'middle-left': 'top-50 start-0 translate-middle-y',\n  'middle-center': 'top-50 start-50 translate-middle',\n  'middle-right': 'top-50 end-0 translate-middle-y',\n  'bottom-left': 'bottom-0 start-0',\n  'bottom-center': 'bottom-0 start-50 translate-middle-x',\n  'bottom-right': 'bottom-0 end-0',\n}\n\nconst positionClass = computed(() => toastPositions[props.position as ContainerPosition])\n\nconst handleDestroy = (id: string) => {\n  //we made want to disable reactivity for deletes. Future Note\n  props.instance?.remove(id)\n}\n</script>\n","<script lang=\"ts\">\nimport type {Breakpoint, Position} from '../types'\nimport {\n  computed,\n  defineComponent,\n  h,\n  onMounted,\n  type PropType,\n  ref,\n  type SlotsType,\n  type VNode,\n} from 'vue'\nimport {ToastInstance, useToast} from './BToast/plugin'\nimport BToaster from './BToast/BToaster.vue'\n\nexport default defineComponent({\n  slots: Object as SlotsType<{\n    default?: Record<string, never>\n  }>,\n  props: {\n    gutterX: {type: String, default: null},\n    gutterY: {type: String, default: null},\n    fluid: {type: [Boolean, String] as PropType<boolean | Breakpoint>, default: false},\n    toast: {type: Object, default: undefined},\n    position: {type: String as PropType<Position>, default: undefined},\n  },\n  setup(props, {slots, expose}) {\n    const container = ref()\n    let toastInstance: ToastInstance | undefined\n\n    const classes = computed(() => ({\n      container: !props.fluid,\n      [`container-fluid`]: typeof props.fluid === 'boolean' && props.fluid,\n      [`container-${props.fluid}`]: typeof props.fluid === 'string',\n      [`gx-${props.gutterX}`]: props.gutterX !== null,\n      [`gy-${props.gutterY}`]: props.gutterY !== null,\n    }))\n\n    onMounted(() => {\n      if (props.toast) {\n        // toastInstance.setVmContainer(container)\n      }\n    })\n\n    // let this be the container for the toast\n    if (props.toast) {\n      toastInstance = useToast({container, root: props.toast.root})\n      expose({\n        // ...toastInstance?.useMethods,\n      })\n    }\n\n    return () => {\n      const subContainers: VNode[] = []\n\n      toastInstance?.containerPositions.value.forEach((position) => {\n        subContainers.push(h(BToaster, {key: position, instance: toastInstance, position}))\n      })\n\n      return h('div', {class: [classes.value, props.position], ref: container}, [\n        ...subContainers,\n        slots.default?.(),\n      ])\n    }\n  },\n  methods: {},\n})\n\n/* Reverted back for compat\n\n<template>\n  <component :is=\"tag\" ref=\"container\" :class=\"computedClasses\">\n    <!-- <BToaster\n      v-for=\"(pos, index) in toasts\"\n      :key=\"index\"\n      :instance=\"toastInstance\"\n      :position=\"pos\"\n    /> -->\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, ref} from 'vue'\n// import type {Position} from '../types'\n// import BToaster from './BToast/BToaster.vue'\n// import {ToastInstance} from './BToast/plugin'\n\ninterface Props {\n  gutterX?: string\n  gutterY?: string\n  fluid?: boolean | 'sm' | 'md' | 'lg' | 'xl' | 'xxl' // boolean | Breakpoint\n  // toast?: Record<string, unknown> // Make this strongly typed\n  // position?: Position\n  tag?: string\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  fluid: false,\n  tag: 'div',\n})\n\nconst container = ref()\n\nconst computedClasses = computed(() => ({\n  container: props.fluid === false,\n  [`container-fluid`]: props.fluid === true,\n  [`container-${props.fluid}`]: typeof props.fluid === 'string',\n  [`gx-${props.gutterX}`]: props.gutterX !== undefined,\n  [`gy-${props.gutterY}`]: props.gutterY !== undefined,\n}))\n\nconst toasts = computed(() => toastInstance?.containerPositions.value)\n    let toastInstance: ToastInstance | undefined\n\n    onMounted(() => {\n      if (props.toast) {\n        // toastInstance.setVmContainer(container)\n      }\n    })\n\n    // let this be the container for the toast\n    if (props.toast) {\n      toastInstance = useToast({container, root: props.toast.root})\n      expose({\n        // ...toastInstance?.useMethods,\n      })\n    }\n\n    return () => {\n      const subContainers: VNode[] = []\n\n      toastInstance?.containerPositions.value.forEach((position) => {\n        subContainers.push(h(BToaster, {key: position, instance: toastInstance, position}))\n      })\n\n      return h(props.tag, {class: [classes.value, props.position], ref: container}, [\n        ...subContainers,\n        slots.default?.(),\n      ])\n    }\n}\n\n*/\n</script>\n","<template>\n  <div :class=\"computedClasses\" class=\"btn-group\" v-bind=\"$attrs\">\n    <BButton\n      :id=\"computedId\"\n      ref=\"splitButton\"\n      :variant=\"splitVariant || variant\"\n      :size=\"size\"\n      :class=\"buttonClasses\"\n      :disabled=\"splitDisabledBoolean || disabled\"\n      :type=\"splitButtonType\"\n      v-bind=\"buttonAttr\"\n      @click=\"onSplitClick\"\n      @keydown.esc=\"modelValue = !modelValueBoolean\"\n    >\n      <slot name=\"button-content\">\n        {{ text }}\n      </slot>\n    </BButton>\n    <BButton\n      v-if=\"splitBoolean\"\n      ref=\"button\"\n      :variant=\"variant\"\n      :size=\"size\"\n      :disabled=\"disabled\"\n      :class=\"[toggleClass, ...[modelValueBoolean ? 'show' : undefined]]\"\n      class=\"dropdown-toggle-split dropdown-toggle\"\n      :aria-expanded=\"modelValueBoolean\"\n      aria-haspopup=\"menu\"\n      @click=\"onButtonClick\"\n    >\n      <span class=\"visually-hidden\">\n        <slot name=\"toggle-text\">\n          {{ toggleText }}\n        </slot>\n      </span>\n    </BButton>\n  </div>\n  <ul\n    v-if=\"!lazyBoolean || modelValueBoolean\"\n    v-show=\"lazyBoolean || modelValueBoolean\"\n    ref=\"floating\"\n    :style=\"{\n      position: strategy === 'absolute' ? undefined : 'fixed',\n      top: `${y}px`,\n      left: `${x}px`,\n      width: 'max-content',\n    }\"\n    class=\"dropdown-menu show\"\n    :class=\"dropdownMenuClasses\"\n    :aria-labelledby=\"computedId\"\n    :role=\"role\"\n    @click=\"onClickInside\"\n  >\n    <slot />\n  </ul>\n</template>\n\n<script setup lang=\"ts\">\nimport {\n  flip,\n  offset as floatingOffset,\n  type Middleware,\n  shift,\n  type Strategy,\n  useFloating,\n} from '@floating-ui/vue'\nimport {onClickOutside, useToNumber, useVModel} from '@vueuse/core'\nimport {computed, provide, ref, watch} from 'vue'\nimport {useBooleanish, useId} from '../../composables'\nimport type {Booleanish, ButtonType, ButtonVariant, ClassValue, Size} from '../../types'\nimport {BvEvent, dropdownInjectionKey, resolveFloatingPlacement} from '../../utils'\nimport BButton from '../BButton/BButton.vue'\nimport type {RouteLocationRaw} from 'vue-router'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\n// TODO add navigation through keyboard events\n// TODO standardize keydown vs keyup events globally\n\nconst props = withDefaults(\n  defineProps<{\n    ariaLabel?: string\n    id?: string\n    menuClass?: ClassValue\n    size?: Size\n    splitClass?: ClassValue\n    splitVariant?: ButtonVariant | null\n    text?: string\n    toggleClass?: ClassValue\n    autoClose?: boolean | 'inside' | 'outside'\n    block?: Booleanish\n    dark?: Booleanish\n    disabled?: Booleanish\n    isNav?: Booleanish\n    dropup?: Booleanish\n    dropend?: Booleanish\n    dropstart?: Booleanish\n    center?: Booleanish\n    end?: Booleanish\n    noFlip?: Booleanish\n    noShift?: Booleanish\n    offset?:\n      | number\n      | string\n      | {mainAxis?: number; crossAxis?: number; alignmentAxis?: number | null}\n    role?: string\n    split?: Booleanish\n    splitButtonType?: ButtonType\n    splitHref?: string\n    splitDisabled?: Booleanish\n    noCaret?: Booleanish\n    toggleText?: string\n    variant?: ButtonVariant | null\n    modelValue?: Booleanish\n    lazy?: Booleanish\n    strategy?: Strategy\n    floatingMiddleware?: Middleware[]\n    splitTo?: RouteLocationRaw\n  }>(),\n  {\n    ariaLabel: undefined,\n    id: undefined,\n    menuClass: undefined,\n    size: 'md',\n    splitClass: undefined,\n    splitVariant: undefined,\n    text: undefined,\n    toggleClass: undefined,\n    splitTo: undefined,\n    floatingMiddleware: undefined,\n    splitDisabled: undefined,\n    autoClose: true,\n    block: false,\n    dark: false,\n    disabled: false,\n    dropup: false,\n    isNav: false,\n    dropend: false,\n    dropstart: false,\n    end: false,\n    center: false,\n    lazy: false,\n    noFlip: false,\n    noShift: false,\n    offset: 0,\n    role: 'menu',\n    split: false,\n    splitButtonType: 'button',\n    splitHref: undefined,\n    noCaret: false,\n    toggleText: 'Toggle dropdown',\n    variant: 'secondary',\n    modelValue: false,\n    strategy: 'absolute',\n  }\n)\n\nconst emit = defineEmits<{\n  'show': [value: BvEvent]\n  'shown': []\n  'hide': [value: BvEvent]\n  'hidden': []\n  'hide-prevented': []\n  'show-prevented': []\n  'click': [event: MouseEvent]\n  'toggle': []\n  'update:modelValue': [value: boolean]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'default'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'button-content'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'toggle-text'?: (props: Record<string, never>) => any\n}>()\n\nconst computedId = useId(() => props.id, 'dropdown')\n\nconst modelValue = useVModel(props, 'modelValue', emit, {passive: true})\n\nconst modelValueBoolean = useBooleanish(modelValue)\nconst blockBoolean = useBooleanish(() => props.block)\nconst darkBoolean = useBooleanish(() => props.dark)\nconst dropupBoolean = useBooleanish(() => props.dropup)\nconst dropendBoolean = useBooleanish(() => props.dropend)\nconst isNavBoolean = useBooleanish(() => props.isNav)\nconst dropstartBoolean = useBooleanish(() => props.dropstart)\nconst centerBoolean = useBooleanish(() => props.center)\nconst endBoolean = useBooleanish(() => props.end)\nconst splitBoolean = useBooleanish(() => props.split)\nconst noCaretBoolean = useBooleanish(() => props.noCaret)\nconst noFlipBoolean = useBooleanish(() => props.noFlip)\nconst noShiftBoolean = useBooleanish(() => props.noShift)\nconst lazyBoolean = useBooleanish(() => props.lazy)\nconst splitDisabledBoolean = useBooleanish(() => props.splitDisabled)\n\nconst computedOffset = computed(() =>\n  typeof props.offset === 'string' || typeof props.offset === 'number' ? props.offset : NaN\n)\nconst offsetToNumber = useToNumber(computedOffset, {method: 'parseInt', nanToZero: true})\n\nconst floating = ref<HTMLElement | null>(null)\nconst button = ref<HTMLElement | null>(null)\nconst splitButton = ref<HTMLElement | null>(null)\n\nconst referencePlacement = computed(() => (!splitBoolean.value ? splitButton.value : button.value))\nconst floatingPlacement = computed(() =>\n  resolveFloatingPlacement({\n    top: dropupBoolean.value,\n    start: dropstartBoolean.value,\n    end: dropendBoolean.value,\n    alignCenter: centerBoolean.value,\n    alignEnd: endBoolean.value,\n  })\n)\nconst floatingMiddleware = computed<Middleware[]>(() => {\n  if (props.floatingMiddleware !== undefined) {\n    return props.floatingMiddleware\n  }\n  const localOffset =\n    typeof props.offset === 'string' || typeof props.offset === 'number'\n      ? offsetToNumber.value\n      : props.offset\n  const arr: Middleware[] = [floatingOffset(localOffset)]\n  if (noFlipBoolean.value === false) {\n    arr.push(flip())\n  }\n  if (noShiftBoolean.value === false) {\n    arr.push(shift())\n  }\n  return arr\n})\nconst {x, y, strategy, update} = useFloating(referencePlacement, floating, {\n  placement: floatingPlacement,\n  middleware: floatingMiddleware,\n  strategy: props.strategy,\n})\n\nconst computedClasses = computed(() => ({\n  'd-grid': blockBoolean.value,\n  'dropup': dropupBoolean.value,\n  'dropend': dropendBoolean.value,\n  'dropstart': dropstartBoolean.value,\n  'd-flex': blockBoolean.value && splitBoolean.value,\n}))\n\nconst buttonClasses = computed(() => [\n  splitBoolean.value ? props.splitClass : props.toggleClass,\n  {\n    'nav-link': isNavBoolean.value,\n    'dropdown-toggle': !splitBoolean.value,\n    'dropdown-toggle-no-caret': noCaretBoolean.value && !splitBoolean.value,\n    'w-100': splitBoolean.value && blockBoolean.value,\n    'show': splitBoolean.value ? undefined : modelValueBoolean.value,\n  },\n])\n\nconst dropdownMenuClasses = computed(() => [\n  props.menuClass,\n  {\n    'dropdown-menu-dark': darkBoolean.value,\n  },\n])\n\nconst buttonAttr = computed(() => ({\n  'aria-label': props.ariaLabel,\n  'aria-expanded': splitBoolean.value ? undefined : modelValueBoolean.value,\n  'aria-haspopup': splitBoolean.value ? undefined : 'menu',\n  'href': splitBoolean.value ? props.splitHref : undefined,\n  'to': splitBoolean.value && props.splitTo ? props.splitTo : undefined,\n}))\n\nconst onButtonClick = () => {\n  emit('toggle')\n  const currentModelValue = modelValueBoolean.value\n  const e = new BvEvent(currentModelValue ? 'hide' : 'show')\n  currentModelValue ? emit('hide', e) : emit('show', e)\n  if (e.defaultPrevented) {\n    currentModelValue ? emit('hide-prevented') : emit('show-prevented')\n    return\n  }\n  modelValue.value = !currentModelValue\n  currentModelValue ? emit('hidden') : emit('shown')\n}\n\nconst onSplitClick = (event: MouseEvent) => {\n  splitBoolean.value ? emit('click', event) : onButtonClick()\n}\n\nonClickOutside(\n  floating,\n  () => {\n    if (modelValueBoolean.value && (props.autoClose === true || props.autoClose === 'outside')) {\n      toggle()\n    }\n  },\n  {ignore: [button, splitButton]}\n)\nconst onClickInside = () => {\n  if (modelValueBoolean.value && (props.autoClose === true || props.autoClose === 'inside')) {\n    toggle()\n  }\n}\n\nconst close = () => {\n  modelValue.value = false\n}\nconst open = () => {\n  modelValue.value = true\n}\nconst toggle = () => {\n  modelValue.value = !modelValueBoolean.value\n}\n\nwatch(modelValueBoolean, update)\n\ndefineExpose({\n  close,\n  open,\n  toggle,\n})\n\nprovide(dropdownInjectionKey, {\n  id: computedId,\n  open,\n  close,\n  toggle,\n  visible: modelValueBoolean,\n  isNav: isNavBoolean,\n})\n</script>\n","<template>\n  <li role=\"presentation\">\n    <component\n      :is=\"headerTag\"\n      :id=\"headerId\"\n      class=\"dropdown-header\"\n      :class=\"computedClasses\"\n      :role=\"headerRole\"\n    >\n      <slot name=\"header\">\n        {{ header }}\n      </slot>\n    </component>\n    <ul\n      :id=\"id\"\n      role=\"group\"\n      class=\"list-unstyled\"\n      v-bind=\"$attrs\"\n      :aria-describedby=\"ariaDescribedby || headerId\"\n    >\n      <slot />\n    </ul>\n  </li>\n</template>\n\n<script setup lang=\"ts\">\nimport type {ClassValue, ColorVariant} from '../../types'\nimport {computed} from 'vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(\n  defineProps<{\n    id?: string\n    ariaDescribedby?: string\n    header?: string\n    headerClass?: ClassValue\n    headerTag?: string\n    headerVariant?: ColorVariant | null\n  }>(),\n  {\n    headerTag: 'header',\n    id: undefined,\n    ariaDescribedby: undefined,\n    header: undefined,\n    headerClass: undefined,\n    headerVariant: null,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  header?: (props: Record<string, never>) => any\n}>()\n\nconst headerId = computed<string | undefined>(() =>\n  props.id ? `${props.id}_group_dd_header` : undefined\n)\n\nconst headerRole = computed<'heading' | undefined>(() =>\n  props.headerTag === 'header' ? undefined : 'heading'\n)\n\nconst computedClasses = computed(() => [\n  props.headerClass,\n  {\n    [`text-${props.headerVariant}`]: props.headerVariant !== null,\n  },\n])\n</script>\n","<template>\n  <li role=\"presentation\" :class=\"$attrs.class\">\n    <component\n      :is=\"tag\"\n      class=\"dropdown-item\"\n      :class=\"computedClasses\"\n      v-bind=\"componentAttrs\"\n      @click=\"clicked\"\n    >\n      <slot />\n    </component>\n  </li>\n</template>\n\n<script setup lang=\"ts\">\nimport BLink from '../BLink/BLink.vue'\nimport {computed, inject, useAttrs} from 'vue'\nimport type {Booleanish, ClassValue, ColorVariant, LinkTarget} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {collapseInjectionKey, dropdownInjectionKey, navbarInjectionKey} from '../../utils'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(\n  defineProps<{\n    href?: string\n    linkClass?: ClassValue\n    active?: Booleanish\n    disabled?: Booleanish\n    rel?: string\n    target?: LinkTarget\n    variant?: ColorVariant | null\n  }>(),\n  {\n    active: false,\n    disabled: false,\n    rel: undefined,\n    target: '_self',\n    variant: null,\n    linkClass: undefined,\n    href: undefined,\n  }\n)\n\nconst emit = defineEmits<{\n  click: [value: MouseEvent]\n}>()\n\nconst activeBoolean = useBooleanish(() => props.active)\nconst disabledBoolean = useBooleanish(() => props.disabled)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst attrs = useAttrs()\n\nconst computedClasses = computed(() => [\n  props.linkClass,\n  {\n    active: activeBoolean.value,\n    disabled: disabledBoolean.value,\n    [`text-${props.variant}`]: props.variant !== null,\n  },\n])\n\nconst tag = computed<'button' | 'a' | typeof BLink>(() =>\n  props.href ? 'a' : attrs.to ? BLink : 'button'\n)\n\nconst componentAttrs = computed(() => ({\n  'disabled': disabledBoolean.value,\n  'aria-current': activeBoolean.value ? true : null,\n  'href': tag.value === 'a' ? props.href : null,\n  'rel': props.rel,\n  'type': tag.value === 'button' ? 'button' : null,\n  'target': props.target,\n  ...(attrs.to ? {activeClass: 'active', ...attrs} : attrs),\n}))\n\nconst collapseData = inject(collapseInjectionKey, null)\nconst dropdownData = inject(dropdownInjectionKey, null)\nconst navbarData = inject(navbarInjectionKey, null)\n\n// Pretty sure this emits if tag is not button and is disabled\nconst clicked = (e: MouseEvent): void => {\n  emit('click', e)\n  if (navbarData !== null) {\n    collapseData?.close?.()\n  }\n  dropdownData?.close?.()\n}\n</script>\n","<template>\n  <li role=\"presentation\" :class=\"$attrs.class\">\n    <!-- Should click be click.prevent ? -->\n    <button\n      role=\"menu\"\n      type=\"button\"\n      class=\"dropdown-item\"\n      :class=\"computedClasses\"\n      :disabled=\"disabledBoolean\"\n      @click=\"clicked\"\n    >\n      <slot />\n    </button>\n  </li>\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish, ClassValue, ColorVariant} from '../../types'\nimport {computed} from 'vue'\nimport {useBooleanish} from '../../composables'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(\n  defineProps<{\n    buttonClass?: ClassValue\n    active?: Booleanish\n    activeClass?: string\n    disabled?: Booleanish\n    variant?: ColorVariant | null\n  }>(),\n  {\n    active: false,\n    activeClass: 'active',\n    disabled: false,\n    variant: null,\n    buttonClass: undefined,\n  }\n)\n\nconst emit = defineEmits<{\n  click: [value: MouseEvent]\n}>()\n\nconst activeBoolean = useBooleanish(() => props.active)\nconst disabledBoolean = useBooleanish(() => props.disabled)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => [\n  props.buttonClass,\n  {\n    [props.activeClass]: activeBoolean.value,\n    disabled: disabledBoolean.value,\n    [`text-${props.variant}`]: props.variant !== null,\n  },\n])\n\nconst clicked = (e: MouseEvent): void => emit('click', e)\n</script>\n","<template>\n  <form\n    :id=\"id\"\n    :novalidate=\"novalidateBoolean\"\n    :class=\"computedClasses\"\n    @submit.prevent=\"submitted\"\n  >\n    <slot />\n  </form>\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {computed} from 'vue'\n\nconst props = withDefaults(\n  defineProps<{\n    id?: string\n    floating?: Booleanish\n    novalidate?: Booleanish\n    validated?: Booleanish\n  }>(),\n  {\n    floating: false,\n    id: undefined,\n    novalidate: false,\n    validated: false,\n  }\n)\n\nconst emit = defineEmits<{\n  submit: [value: Event]\n}>()\n\nconst floatingBoolean = useBooleanish(() => props.floating)\nconst novalidateBoolean = useBooleanish(() => props.novalidate)\nconst validatedBoolean = useBooleanish(() => props.validated)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => ({\n  'form-floating': floatingBoolean.value,\n  'was-validated': validatedBoolean.value,\n}))\n\nconst submitted = (e: Event): void => emit('submit', e)\n</script>\n","<template>\n  <component :is=\"tag\" :class=\"computedClasses\" v-bind=\"computedAttrs\">\n    <slot>\n      {{ text }}\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed} from 'vue'\nimport type {Booleanish} from '../../types'\nimport {useBooleanish} from '../../composables'\n\nconst props = withDefaults(\n  defineProps<{\n    ariaLive?: string\n    forceShow?: Booleanish\n    id?: string\n    text?: string\n    role?: string\n    state?: Booleanish | null\n    tag?: string\n    tooltip?: Booleanish\n  }>(),\n  {\n    id: undefined,\n    text: undefined,\n    role: undefined,\n    ariaLive: undefined,\n    forceShow: false,\n    tag: 'div',\n    state: null,\n    tooltip: false,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst forceShowBoolean = useBooleanish(() => props.forceShow)\nconst stateBoolean = useBooleanish(() => props.state)\nconst tooltipBoolean = useBooleanish(() => props.tooltip)\n\nconst computedShow = computed<boolean>(\n  () => forceShowBoolean.value === true || stateBoolean.value === false\n)\n\nconst computedClasses = computed(() => ({\n  'd-block': computedShow.value,\n  'invalid-feedback': !tooltipBoolean.value,\n  'invalid-tooltip': tooltipBoolean.value,\n}))\n\nconst computedAttrs = computed(() => ({\n  'id': props.id,\n  'role': props.role,\n  'aria-live': props.ariaLive,\n  'aria-atomic': props.ariaLive ? true : undefined,\n}))\n</script>\n","<template>\n  <component :is=\"tag\" :id=\"id\" :class=\"computedClasses\">\n    <slot>\n      {{ text }}\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed} from 'vue'\nimport type {Booleanish, TextColorVariant} from '../../types'\nimport {useBooleanish} from '../../composables'\n\nconst props = withDefaults(\n  defineProps<{\n    id?: string\n    inline?: Booleanish\n    tag?: string\n    text?: string\n    textVariant?: TextColorVariant | null\n  }>(),\n  {\n    inline: false,\n    id: undefined,\n    text: undefined,\n    tag: 'small',\n    textVariant: 'muted',\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst inlineBoolean = useBooleanish(() => props.inline)\n\nconst computedClasses = computed(() => ({\n  [`text-${props.textVariant}`]: props.textVariant !== null,\n  'form-text': !inlineBoolean.value,\n}))\n</script>\n","<template>\n  <component\n    :is=\"tag\"\n    :id=\"id\"\n    :role=\"role\"\n    :aria-live=\"ariaLive\"\n    :aria-atomic=\"computedAriaAtomic\"\n    :class=\"computedClasses\"\n  >\n    <slot>\n      {{ text }}\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed} from 'vue'\nimport type {Booleanish} from '../../types'\nimport {useBooleanish} from '../../composables'\n\nconst props = withDefaults(\n  defineProps<{\n    ariaLive?: string\n    forceShow?: Booleanish\n    id?: string\n    role?: string\n    text?: string\n    state?: Booleanish | null\n    tag?: string\n    tooltip?: Booleanish\n  }>(),\n  {\n    id: undefined,\n    role: undefined,\n    text: undefined,\n    ariaLive: undefined,\n    forceShow: false,\n    tag: 'div',\n    tooltip: false,\n    state: null,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst forceShowBoolean = useBooleanish(() => props.forceShow)\nconst stateBoolean = useBooleanish(() => props.state)\nconst tooltipBoolean = useBooleanish(() => props.tooltip)\n\nconst computedShow = computed<boolean>(\n  () => forceShowBoolean.value === true || stateBoolean.value === true\n)\n\nconst computedClasses = computed(() => ({\n  'd-block': computedShow.value,\n  'valid-feedback': !tooltipBoolean.value,\n  'valid-tooltip': tooltipBoolean.value,\n}))\n\nconst computedAriaAtomic = computed(() => (props.ariaLive ? true : undefined))\n</script>\n","<template>\n  <RenderComponentOrSkip :skip=\"isButtonGroup\" :class=\"computedClasses\">\n    <input\n      :id=\"computedId\"\n      v-bind=\"$attrs\"\n      ref=\"input\"\n      v-model=\"localValue\"\n      :class=\"inputClasses\"\n      type=\"checkbox\"\n      :disabled=\"disabledBoolean || parentData?.disabled.value\"\n      :required=\"computedRequired || undefined\"\n      :name=\"name || parentData?.name.value\"\n      :form=\"form || parentData?.form.value\"\n      :aria-label=\"ariaLabel\"\n      :aria-labelledby=\"ariaLabelledBy\"\n      :aria-required=\"computedRequired || undefined\"\n      :value=\"value\"\n      :indeterminate=\"indeterminateBoolean\"\n    />\n    <label v-if=\"hasDefaultSlot || plainBoolean === false\" :for=\"computedId\" :class=\"labelClasses\">\n      <slot />\n    </label>\n  </RenderComponentOrSkip>\n</template>\n\n<script setup lang=\"ts\">\nimport {useFocus, useVModel} from '@vueuse/core'\nimport {computed, inject, nextTick, ref, useSlots, watch} from 'vue'\nimport {getClasses, getInputClasses, getLabelClasses, useBooleanish, useId} from '../../composables'\nimport type {Booleanish, ButtonVariant, Size} from '../../types'\nimport {checkboxGroupKey, isEmptySlot} from '../../utils'\nimport RenderComponentOrSkip from '../RenderComponentOrSkip.vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(\n  defineProps<{\n    ariaLabel?: string\n    ariaLabelledBy?: string\n    form?: string\n    indeterminate?: Booleanish\n    name?: string\n    id?: string\n    autofocus?: Booleanish\n    plain?: Booleanish\n    button?: Booleanish\n    buttonGroup?: Booleanish\n    switch?: Booleanish\n    disabled?: Booleanish\n    buttonVariant?: ButtonVariant | null\n    inline?: Booleanish\n    required?: Booleanish\n    size?: Size\n    state?: Booleanish | null\n    uncheckedValue?:\n      | unknown[]\n      | Set<unknown>\n      | boolean\n      | string\n      | Record<string, unknown>\n      | number\n      | null\n    value?: unknown[] | Set<unknown> | boolean | string | Record<string, unknown> | number | null\n    modelValue?:\n      | unknown[]\n      | Set<unknown>\n      | boolean\n      | string\n      | Record<string, unknown>\n      | number\n      | null\n  }>(),\n  {\n    ariaLabel: undefined,\n    ariaLabelledBy: undefined,\n    form: undefined,\n    indeterminate: undefined,\n    name: undefined,\n    autofocus: false,\n    plain: false,\n    button: false,\n    buttonGroup: false,\n    id: undefined,\n    required: undefined,\n    state: null,\n    modelValue: undefined,\n    switch: false,\n    disabled: false,\n    buttonVariant: null,\n    inline: false,\n    size: undefined,\n    value: true,\n    uncheckedValue: false,\n  }\n)\n\nconst emit = defineEmits<{\n  'update:modelValue': [\n    value: unknown[] | Set<unknown> | boolean | string | Record<string, unknown> | number | null\n  ]\n  'input': [\n    value: unknown[] | Set<unknown> | boolean | string | Record<string, unknown> | number | null\n  ]\n  'change': [\n    value: unknown[] | Set<unknown> | boolean | string | Record<string, unknown> | number | null\n  ]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst slots = useSlots()\n\nconst modelValue = useVModel(props, 'modelValue', emit, {passive: true})\n\nconst computedId = useId(() => props.id, 'form-check')\n\nconst indeterminateBoolean = useBooleanish(() => props.indeterminate)\nconst autofocusBoolean = useBooleanish(() => props.autofocus)\nconst plainBoolean = useBooleanish(() => props.plain)\nconst buttonBoolean = useBooleanish(() => props.button)\nconst buttonGroupBoolean = useBooleanish(() => props.buttonGroup)\nconst switchBoolean = useBooleanish(() => props.switch)\nconst disabledBoolean = useBooleanish(() => props.disabled)\nconst inlineBoolean = useBooleanish(() => props.inline)\nconst requiredBoolean = useBooleanish(() => props.required)\nconst stateBoolean = useBooleanish(() => props.state)\n\nconst parentData = inject(checkboxGroupKey, null)\n\nconst input = ref<HTMLElement | null>(null)\n\nconst {focused} = useFocus(input, {\n  initialValue: autofocusBoolean.value,\n})\n\nconst hasDefaultSlot = computed(() => !isEmptySlot(slots.default))\n\nconst localValue = computed({\n  get: () =>\n    parentData !== null\n      ? parentData.modelValue.value\n          .map((el) => JSON.stringify(el))\n          .includes(JSON.stringify(props.value))\n      : JSON.stringify(modelValue.value) === JSON.stringify(props.value),\n  set: (newValue) => {\n    const updateValue = newValue ? props.value : props.uncheckedValue\n\n    emit('input', updateValue)\n    modelValue.value = updateValue\n    nextTick(() => {\n      emit('change', updateValue)\n    })\n  },\n})\n\nwatch(modelValue, (newValue) => {\n  if (parentData === null) return\n  if (newValue === false) {\n    parentData.remove(props.value)\n    return\n  }\n  parentData.set(props.value)\n})\n\nconst computedRequired = computed(\n  () =>\n    !!(props.name ?? parentData?.name.value) &&\n    (requiredBoolean.value || parentData?.required.value)\n)\n\nconst isButtonGroup = computed(\n  () => buttonGroupBoolean.value || (parentData?.buttons.value ?? false)\n)\n\nconst classesObject = computed(() => ({\n  plain: plainBoolean.value || (parentData?.plain.value ?? false),\n  button: buttonBoolean.value || (parentData?.buttons.value ?? false),\n  inline: inlineBoolean.value || (parentData?.inline.value ?? false),\n  switch: switchBoolean.value || (parentData?.switch.value ?? false),\n  state: stateBoolean.value || parentData?.state.value,\n  size: props.size !== undefined ? props.size : parentData?.size.value ?? 'md', // This is where the true default is made\n  buttonVariant:\n    props.buttonVariant !== null\n      ? props.buttonVariant\n      : parentData?.buttonVariant.value ?? 'secondary', // This is where the true default is made\n}))\nconst computedClasses = getClasses(classesObject)\nconst inputClasses = getInputClasses(classesObject)\nconst labelClasses = getLabelClasses(classesObject)\n\ndefineExpose({\n  focus: () => {\n    focused.value = true\n  },\n  blur: () => {\n    focused.value = false\n  },\n})\n</script>\n","<template>\n  <div\n    v-bind=\"computedAttrs\"\n    :id=\"computedId\"\n    ref=\"element\"\n    role=\"group\"\n    :class=\"computedClasses\"\n    class=\"bv-no-focus-ring\"\n    tabindex=\"-1\"\n  >\n    <slot name=\"first\" />\n    <BFormCheckbox v-for=\"item in normalizeOptions\" :key=\"item.self\" v-bind=\"item.props\">\n      <!-- eslint-disable-next-line vue/no-v-html -->\n      <span v-if=\"item.html\" v-html=\"item.html\" />\n      <span v-else v-text=\"item.text\" />\n    </BFormCheckbox>\n    <slot />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, nextTick, provide, readonly, ref, toRef} from 'vue'\nimport BFormCheckbox from './BFormCheckbox.vue'\nimport type {AriaInvalid, Booleanish, ButtonVariant, Size} from '../../types'\nimport {getGroupAttr, getGroupClasses, useBooleanish, useId} from '../../composables'\nimport {checkboxGroupKey} from '../../utils'\nimport {useFocus, useVModel} from '@vueuse/core'\n\nconst props = withDefaults(\n  defineProps<{\n    id?: string\n    form?: string\n    modelValue?: (\n      | unknown[]\n      | Set<unknown>\n      | boolean\n      | string\n      | Record<string, unknown>\n      | number\n      | null\n    )[]\n    ariaInvalid?: AriaInvalid\n    autofocus?: Booleanish\n    buttonVariant?: ButtonVariant | null\n    buttons?: Booleanish\n    disabled?: Booleanish\n    disabledField?: string\n    htmlField?: string\n    name?: string\n    options?: (string | number | Record<string, unknown>)[]\n    plain?: Booleanish\n    required?: Booleanish\n    size?: Size\n    stacked?: Booleanish\n    state?: Booleanish | null\n    switches?: Booleanish\n    textField?: string\n    validated?: Booleanish\n    valueField?: string\n  }>(),\n  {\n    id: undefined,\n    size: 'md',\n    name: undefined,\n    form: undefined,\n    modelValue: () => [],\n    autofocus: false,\n    buttonVariant: 'secondary',\n    buttons: false,\n    ariaInvalid: undefined,\n    state: null,\n    disabled: false,\n    disabledField: 'disabled',\n    htmlField: 'html',\n    options: () => [],\n    plain: false,\n    required: false,\n    stacked: false,\n    switches: false,\n    textField: 'text',\n    validated: false,\n    valueField: 'value',\n  }\n)\n\nconst emit = defineEmits<{\n  'input': [\n    value: (unknown[] | Set<unknown> | boolean | string | Record<string, unknown> | number | null)[]\n  ]\n  'update:modelValue': [\n    value: (unknown[] | Set<unknown> | boolean | string | Record<string, unknown> | number | null)[]\n  ]\n  'change': [\n    value: (unknown[] | Set<unknown> | boolean | string | Record<string, unknown> | number | null)[]\n  ]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  first?: (props: Record<string, never>) => any\n}>()\n\nconst modelValue = useVModel(props, 'modelValue', emit)\n\nconst computedId = useId(() => props.id, 'checkbox')\nconst computedName = useId(() => props.name, 'checkbox')\nconst autofocusBoolean = useBooleanish(() => props.autofocus)\nconst buttonsBoolean = useBooleanish(() => props.buttons)\nconst disabledBoolean = useBooleanish(() => props.disabled)\nconst plainBoolean = useBooleanish(() => props.plain)\nconst requiredBoolean = useBooleanish(() => props.required)\nconst stackedBoolean = useBooleanish(() => props.stacked)\nconst stateBoolean = useBooleanish(() => props.state)\nconst switchesBoolean = useBooleanish(() => props.switches)\nconst validatedBoolean = useBooleanish(() => props.validated)\n\nconst element = ref<HTMLElement | null>(null)\n\nconst {focused} = useFocus(element, {\n  initialValue: autofocusBoolean.value,\n})\n\nprovide(checkboxGroupKey, {\n  set: (\n    value: unknown[] | Set<unknown> | boolean | string | Record<string, unknown> | number | null\n  ) => {\n    const localValue = [...modelValue.value]\n    localValue.push(value)\n\n    emit('input', localValue)\n    modelValue.value = localValue\n    nextTick(() => {\n      emit('change', localValue)\n    })\n  },\n  remove: (\n    value: unknown[] | Set<unknown> | boolean | string | Record<string, unknown> | number | null\n  ) => {\n    const localValue = [...modelValue.value]\n    // TODO if the value is an array, set, or object, indexOf may not work correctly\n    localValue.splice(modelValue.value.indexOf(value), 1)\n\n    emit('input', localValue)\n    modelValue.value = localValue\n    nextTick(() => {\n      emit('change', localValue)\n    })\n  },\n  modelValue: computed(() => modelValue.value),\n  switch: switchesBoolean,\n  buttonVariant: readonly(toRef(props, 'buttonVariant')),\n  form: readonly(toRef(props, 'form')),\n  name: computedName,\n  state: stateBoolean,\n  plain: plainBoolean,\n  size: readonly(toRef(props, 'size')),\n  inline: computed(() => !stackedBoolean.value),\n  required: requiredBoolean,\n  buttons: buttonsBoolean,\n  disabled: disabledBoolean,\n})\n\nconst normalizeOptions = computed(() =>\n  props.options.map((el, ind) =>\n    typeof el === 'string' || typeof el === 'number'\n      ? {\n          props: {\n            value: el,\n            disabled: disabledBoolean.value,\n          },\n          text: el.toString(),\n          html: undefined,\n          self: Symbol(`checkboxGroupOptionItem${ind}`),\n        }\n      : {\n          props: {\n            value: el[props.valueField] as string | number | undefined,\n            disabled: el[props.disabledField] as boolean | undefined,\n            ...(el.props ? el.props : {}),\n          },\n          text: el[props.textField] as string | undefined,\n          html: el[props.htmlField] as string | undefined,\n          self: Symbol(`checkboxGroupOptionItem${ind}`),\n        }\n  )\n)\n\nconst classesObject = computed(() => ({\n  required: requiredBoolean.value,\n  ariaInvalid: props.ariaInvalid,\n  state: stateBoolean.value,\n  validated: validatedBoolean.value,\n  buttons: buttonsBoolean.value,\n  stacked: stackedBoolean.value,\n  size: props.size,\n}))\nconst computedAttrs = getGroupAttr(classesObject)\nconst computedClasses = getGroupClasses(classesObject)\n\ndefineExpose({\n  focus: () => {\n    focused.value = true\n  },\n  blur: () => {\n    focused.value = false\n  },\n})\n</script>\n","<template>\n  <label v-if=\"hasLabelSlot || label\" :for=\"computedId\" class=\"form-label\" :class=\"labelClasses\">\n    <slot name=\"label\">\n      {{ label }}\n    </slot>\n  </label>\n  <input\n    :id=\"computedId\"\n    v-bind=\"$attrs\"\n    ref=\"input\"\n    type=\"file\"\n    class=\"form-control\"\n    :class=\"computedClasses\"\n    :form=\"form\"\n    :name=\"name\"\n    :multiple=\"multipleBoolean\"\n    :disabled=\"disabledBoolean\"\n    :capture=\"computedCapture\"\n    :accept=\"computedAccept || undefined\"\n    :required=\"requiredBoolean || undefined\"\n    :aria-required=\"requiredBoolean || undefined\"\n    :directory=\"directoryBoolean\"\n    :webkitdirectory=\"directoryBoolean\"\n    @change=\"onChange\"\n    @drop=\"onDrop\"\n  />\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, ref, useSlots, watch} from 'vue'\nimport {useFocus, useVModel} from '@vueuse/core'\nimport type {Booleanish, ClassValue, Size} from '../../types'\nimport {useBooleanish, useId, useStateClass} from '../../composables'\nimport {isEmptySlot, resolveBooleanish} from '../../utils'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  label?: (props: Record<string, never>) => any\n}>()\n\nconst props = withDefaults(\n  defineProps<{\n    accept?: string | string[]\n    autofocus?: Booleanish\n    capture?: boolean | 'true' | 'false' | '' | 'user' | 'environment' // Booleanish | 'user' | 'environment'\n    directory?: Booleanish\n    disabled?: Booleanish\n    form?: string\n    id?: string\n    multiple?: Booleanish\n    name?: string\n    noDrop?: Booleanish\n    noTraverse?: Booleanish\n    required?: Booleanish\n    size?: Size\n    state?: Booleanish | null\n    modelValue?: File[] | File | null\n    label?: string\n    labelClasses?: ClassValue\n  }>(),\n  {\n    accept: '',\n    autofocus: false,\n    capture: false,\n    directory: false,\n    disabled: false,\n    form: undefined,\n    id: undefined,\n    multiple: false,\n    name: undefined,\n    noDrop: false,\n    noTraverse: false,\n    required: false,\n    size: undefined,\n    state: null,\n    modelValue: null,\n    label: '',\n    labelClasses: undefined,\n  }\n)\n\nconst emit = defineEmits<{\n  'update:modelValue': [value: File | File[] | null]\n  'change': [value: Event]\n}>()\n\nconst slots = useSlots()\n\nconst modelValue = useVModel(props, 'modelValue', emit)\nconst computedId = useId(() => props.id)\n\nconst autofocusBoolean = useBooleanish(() => props.autofocus)\nconst directoryBoolean = useBooleanish(() => props.directory)\nconst disabledBoolean = useBooleanish(() => props.disabled)\nconst multipleBoolean = useBooleanish(() => props.multiple)\nconst noDropBoolean = useBooleanish(() => props.noDrop)\n// TODO not implemented yet\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst noTraverseBoolean = useBooleanish(() => props.noTraverse)\nconst requiredBoolean = useBooleanish(() => props.required)\nconst stateBoolean = useBooleanish(() => props.state)\n\nconst stateClass = useStateClass(stateBoolean)\n\nconst input = ref<HTMLInputElement | null>(null)\n\nconst {focused} = useFocus(input, {initialValue: autofocusBoolean.value})\n\nconst hasLabelSlot = computed(() => !isEmptySlot(slots['label']))\nconst computedAccept = computed(() =>\n  typeof props.accept === 'string' ? props.accept : props.accept.join(',')\n)\nconst computedCapture = computed(() =>\n  props.capture === 'user' || props.capture === 'environment'\n    ? props.capture\n    : resolveBooleanish(props.capture)\n)\n\nconst computedClasses = computed(() => [\n  stateClass.value,\n  {\n    [`form-control-${props.size}`]: props.size !== undefined,\n  },\n])\n\nconst onChange = (e: Event) => {\n  const value =\n    input.value?.files === null || input.value?.files === undefined ? null : [...input.value.files]\n  modelValue.value = value === null ? null : multipleBoolean.value === true ? value : value[0]\n  emit('change', e)\n}\n\nconst onDrop = (e: Event) => {\n  if (noDropBoolean.value === true) {\n    e.preventDefault()\n  }\n}\n\n/**\n * Reset the form input\n */\nconst reset = () => {\n  modelValue.value = null\n}\n\nwatch(modelValue, (newValue) => {\n  if (newValue === null && input.value !== null) {\n    input.value.value = ''\n  }\n})\n\ndefineExpose({\n  focus: () => {\n    focused.value = true\n  },\n  blur: () => {\n    focused.value = false\n  },\n  reset,\n})\n</script>\n","<script lang=\"ts\">\nimport {useBooleanish, useId, useStateClass} from '../../composables'\nimport {RX_SPACE_SPLIT} from '../../constants/regex'\nimport {\n  attemptFocus,\n  cssEscape,\n  getAttr,\n  getId,\n  IS_BROWSER,\n  isVisible,\n  normalizeSlot,\n  removeAttr,\n  resolveAriaInvalid,\n  select,\n  selectAll,\n  setAttr,\n  stringToInteger,\n  suffixPropName,\n} from '../../utils'\nimport {computed, defineComponent, h, nextTick, onMounted, type PropType, ref, watch} from 'vue'\nimport BCol from '../BCol.vue'\nimport BFormInvalidFeedback from '../BForm/BFormInvalidFeedback.vue'\nimport BFormRow from '../BForm/BFormRow.vue'\nimport BFormText from '../BForm/BFormText.vue'\nimport BFormValidFeedback from '../BForm/BFormValidFeedback.vue'\nimport type {AriaInvalid, Booleanish} from '../../types'\n\nconst INPUTS = ['input', 'select', 'textarea']\n// Selector for finding first input in the form group\nconst INPUT_SELECTOR = INPUTS.map((v) => `${v}:not([disabled])`).join()\n\n// A list of interactive elements (tag names) inside `<BFormGroup>`'s legend\nconst LEGEND_INTERACTIVE_ELEMENTS = [...INPUTS, 'a', 'button', 'label']\n\nexport const SLOT_NAME_LABEL = 'label'\nexport const SLOT_NAME_INVALID_FEEDBACK = 'invalid-feedback'\nexport const SLOT_NAME_VALID_FEEDBACK = 'valid-feedback'\nexport const SLOT_NAME_DESCRIPTION = 'description'\nexport const SLOT_NAME_DEFAULT = 'default'\n\nexport default defineComponent({\n  components: {BCol, BFormInvalidFeedback, BFormRow, BFormText, BFormValidFeedback},\n  props: {\n    contentCols: {type: [Boolean, String, Number], default: undefined},\n    contentColsLg: {type: [Boolean, String, Number], default: undefined},\n    contentColsMd: {type: [Boolean, String, Number], default: undefined},\n    contentColsSm: {type: [Boolean, String, Number], default: undefined},\n    contentColsXl: {type: [Boolean, String, Number], default: undefined},\n    description: {type: [String], default: undefined},\n    disabled: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    feedbackAriaLive: {type: String, default: 'assertive'},\n    id: {type: String, default: undefined},\n    invalidFeedback: {type: String, default: undefined},\n    label: {type: String, default: undefined},\n    labelAlign: {type: [Boolean, String, Number], default: undefined},\n    labelAlignLg: {type: [Boolean, String, Number], default: undefined},\n    labelAlignMd: {type: [Boolean, String, Number], default: undefined},\n    labelAlignSm: {type: [Boolean, String, Number], default: undefined},\n    labelAlignXl: {type: [Boolean, String, Number], default: undefined},\n    labelClass: {type: [Array, Object, String], default: undefined},\n    labelCols: {type: [Boolean, String, Number], default: undefined},\n    labelColsLg: {type: [Boolean, String, Number], default: undefined},\n    labelColsMd: {type: [Boolean, String, Number], default: undefined},\n    labelColsSm: {type: [Boolean, String, Number], default: undefined},\n    labelColsXl: {type: [Boolean, String, Number], default: undefined},\n    labelFor: {type: String, default: undefined},\n    labelSize: {type: String, default: undefined},\n    labelSrOnly: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    state: {type: [Boolean, String] as PropType<Booleanish | null>, default: null},\n    tooltip: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    validFeedback: {type: String, default: undefined},\n    validated: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    floating: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n  },\n  setup(props, {attrs}) {\n    const disabledBoolean = useBooleanish(() => props.disabled)\n    const labelSrOnlyBoolean = useBooleanish(() => props.labelSrOnly)\n    const stateBoolean = useBooleanish(() => props.state)\n    const tooltipBoolean = useBooleanish(() => props.tooltip)\n    const validatedBoolean = useBooleanish(() => props.validated)\n    const floatingBoolean = useBooleanish(() => props.floating)\n\n    const ariaDescribedby: string | null = null as string | null\n    const breakPoints = ['xs', 'sm', 'md', 'lg', 'xl']\n\n    const getAlignClasses = (props: any, prefix: string) =>\n      breakPoints.reduce((result: string[], breakpoint) => {\n        const suffix = suffixPropName(breakpoint === 'xs' ? '' : breakpoint, `${prefix}Align`)\n        const propValue: string = props[suffix] || null\n        if (propValue) {\n          breakpoint === 'xs'\n            ? result.push(`text-${propValue}`)\n            : result.push(`text-${breakpoint}-${propValue}`)\n        }\n\n        return result\n      }, [])\n\n    const getColProps = (props: any, prefix: string) =>\n      breakPoints.reduce((result: any, breakpoint: string) => {\n        const suffix = suffixPropName(breakpoint === 'xs' ? '' : breakpoint, `${prefix}Cols`)\n        let propValue = props[suffix]\n        // Handle case where the prop's value is an empty string,\n        // which represents `true`\n        propValue = propValue === '' ? true : propValue || false\n\n        if (!(typeof propValue === 'boolean') && propValue !== 'auto') {\n          // Convert to column size to number\n          propValue = stringToInteger(propValue, 0)\n          // Ensure column size is greater than `0`\n          propValue = propValue > 0 ? propValue : false\n        }\n\n        // Add the prop to the list of props to give to `</BCol>`\n        // If breakpoint is '' (`${prefix}Cols` is `true`), then we use\n        // the 'col' prop to make equal width at 'xs'\n        if (propValue) {\n          // Extra care is required for xs since it does not have a BCol breakpoint prop\n          // Xs breakpoint is simply 'cols'\n          if (breakpoint === 'xs') {\n            result[typeof propValue === 'boolean' ? 'col' : 'cols'] = propValue\n          } else {\n            result[breakpoint || (typeof propValue === 'boolean' ? 'col' : 'cols')] = propValue\n          }\n        }\n        return result\n      }, {})\n\n    const content = ref()\n\n    // Sets the `aria-describedby` attribute on the input if `labelFor` is set\n    // Optionally accepts a string of Ids to remove as the second parameter\n    // Preserves any `aria-describedby` value(s) user may have on input\n    const updateAriaDescribedby = (newValue: string | null, oldValue: string | null = null) => {\n      if (IS_BROWSER && props.labelFor) {\n        // We need to escape `labelFor` since it can be user-provided\n        const $input = select(`#${cssEscape(props.labelFor)}`, content)\n        if ($input) {\n          const attr = 'aria-describedby'\n          const newIds = (newValue || '').split(RX_SPACE_SPLIT)\n          const oldIds = (oldValue || '').split(RX_SPACE_SPLIT)\n\n          // Update Id list, preserving any original Ids\n          // and ensuring the Id's are unique\n          const ids = (getAttr($input, attr) || '')\n            .split(RX_SPACE_SPLIT)\n            .filter((id) => !oldIds.includes(id))\n            .concat(newIds)\n            .filter((id, index, ids) => ids.indexOf(id) === index)\n            .filter((x) => x)\n            .join(' ')\n            .trim()\n\n          if (ids) {\n            setAttr($input, attr, ids)\n          } else {\n            removeAttr($input, attr)\n          }\n        }\n      }\n    }\n\n    const contentColProps = computed(() => getColProps(props, 'content'))\n    const labelAlignClasses = computed(() => getAlignClasses(props, 'label'))\n    const labelColProps = computed(() => getColProps(props, 'label'))\n    const isHorizontal = computed(\n      () =>\n        // Determine if the form group will be rendered horizontal\n        // based on the existence of 'content-col' or 'label-col' props\n        Object.keys(contentColProps.value).length > 0 || Object.keys(labelColProps.value).length > 0\n    )\n\n    const stateClass = useStateClass(stateBoolean)\n\n    const computedAriaInvalid = computed(() =>\n      resolveAriaInvalid(attrs.ariaInvalid as unknown as AriaInvalid, stateBoolean.value)\n    )\n\n    watch(\n      () => ariaDescribedby,\n      (newValue: string | null, oldValue: string | null) => {\n        if (newValue !== oldValue) {\n          updateAriaDescribedby(newValue, oldValue)\n        }\n      }\n    )\n\n    onMounted(() => {\n      nextTick(() => {\n        // Set `aria-describedby` on the input specified by `labelFor`\n        // We do this in a `$nextTick()` to ensure the children have finished rendering\n        updateAriaDescribedby(ariaDescribedby)\n      })\n    })\n\n    const onLegendClick = (event: MouseEvent) => {\n      // Don't do anything if `labelFor` is set\n      if (props.labelFor) {\n        return\n      }\n\n      const {target} = event\n      const tagName = target ? (target as HTMLElement).tagName : ''\n\n      // If clicked an interactive element inside legend,\n      // we just let the default happen\n      if (LEGEND_INTERACTIVE_ELEMENTS.indexOf(tagName) !== -1) {\n        return\n      }\n\n      // If only a single input, focus it, emulating label behaviour\n      const inputs = selectAll(INPUT_SELECTOR, content).filter(isVisible)\n      if (inputs.length === 1) {\n        attemptFocus(inputs[0])\n      }\n    }\n\n    return {\n      disabledBoolean,\n      labelSrOnlyBoolean,\n      stateBoolean,\n      tooltipBoolean,\n      validatedBoolean,\n      floatingBoolean,\n      ariaDescribedby,\n      computedAriaInvalid,\n      contentColProps,\n      isHorizontal,\n      labelAlignClasses,\n      labelColProps,\n      onLegendClick,\n      stateClass,\n    }\n  },\n  render() {\n    const props = this.$props\n    const slots = this.$slots\n\n    const id = useId()\n    const isFieldset = !props.labelFor\n\n    let $label: any = null\n    const labelContent = normalizeSlot(SLOT_NAME_LABEL, {}, slots) || props.label\n    const labelId = labelContent ? getId('_BV_label_') : null\n\n    if (labelContent || this.isHorizontal) {\n      const labelTag: 'legend' | 'label' = isFieldset ? 'legend' : 'label'\n      if (this.labelSrOnlyBoolean) {\n        if (labelContent) {\n          $label = h(\n            labelTag,\n            {\n              class: 'visually-hidden',\n              id: labelId,\n              for: props.labelFor || null,\n            },\n            labelContent\n          )\n        }\n        if (this.isHorizontal) {\n          $label = h(BCol, this.labelColProps, {default: () => $label})\n        } else {\n          $label = h('div', {}, [$label])\n        }\n      } else {\n        const renderProps = {\n          onClick: isFieldset ? this.onLegendClick : null,\n          ...(this.isHorizontal ? this.labelColProps : {}),\n          tag: this.isHorizontal ? labelTag : null,\n          id: labelId,\n          for: props.labelFor || null,\n          tabIndex: isFieldset ? '-1' : null,\n          class: [\n            this.isHorizontal ? 'col-form-label' : 'form-label',\n            {\n              'bv-no-focus-ring': isFieldset,\n              'col-form-label': this.isHorizontal || isFieldset,\n              'pt-0': !this.isHorizontal && isFieldset,\n              'd-block': !this.isHorizontal && !isFieldset,\n              [`col-form-label-${props.labelSize}`]: !!props.labelSize,\n            },\n            this.labelAlignClasses,\n            props.labelClass,\n          ],\n        }\n        if (this.isHorizontal) {\n          $label = h(BCol, renderProps, {default: () => labelContent})\n        } else {\n          $label = h(labelTag, renderProps, labelContent)\n        }\n      }\n    }\n\n    let $invalidFeedback = null\n    const invalidFeedbackContent =\n      normalizeSlot(SLOT_NAME_INVALID_FEEDBACK, {}, slots) || this.invalidFeedback\n    const invalidFeedbackId = invalidFeedbackContent ? getId('_BV_feedback_invalid_') : undefined\n\n    if (invalidFeedbackContent) {\n      $invalidFeedback = h(\n        BFormInvalidFeedback,\n        {\n          ariaLive: props.feedbackAriaLive,\n          id: invalidFeedbackId,\n          state: this.stateBoolean,\n          tooltip: this.tooltipBoolean,\n        },\n        {default: () => invalidFeedbackContent}\n      )\n    }\n\n    let $validFeedback = null\n    const validFeedbackContent =\n      normalizeSlot(SLOT_NAME_VALID_FEEDBACK, {}, slots) || this.validFeedback\n    const validFeedbackId = validFeedbackContent ? getId('_BV_feedback_valid_') : undefined\n\n    if (validFeedbackContent) {\n      $validFeedback = h(\n        BFormValidFeedback,\n        {\n          ariaLive: props.feedbackAriaLive,\n          id: validFeedbackId,\n          state: this.stateBoolean,\n          tooltip: this.tooltipBoolean,\n        },\n        {default: () => validFeedbackContent}\n        // validFeedbackContent\n      )\n    }\n\n    let $description = null\n    const descriptionContent = normalizeSlot(SLOT_NAME_DESCRIPTION, {}, slots) || this.description\n    const descriptionId = descriptionContent ? getId('_BV_description_') : undefined\n    if (descriptionContent) {\n      $description = h(\n        BFormText,\n        {\n          id: descriptionId,\n        },\n        {default: () => descriptionContent}\n      )\n    }\n\n    // Update `ariaDescribedby`\n    // Screen readers will read out any content linked to by `aria-describedby`\n    // even if the content is hidden with `display: none;`, hence we only include\n    // feedback Ids if the form group's state is explicitly valid or invalid\n    const ariaDescribedby = (this.ariaDescribedby =\n      [\n        descriptionId,\n        this.stateBoolean === false ? invalidFeedbackId : null,\n        this.stateBoolean === true ? validFeedbackId : null,\n      ]\n        .filter((x) => x)\n        .join(' ') || null)\n\n    const contentBlocks = [\n      normalizeSlot(SLOT_NAME_DEFAULT, {ariaDescribedby, descriptionId, id, labelId}, slots) || '',\n      $invalidFeedback,\n      $validFeedback,\n      $description,\n    ]\n    if (!this.isHorizontal && this.floatingBoolean) contentBlocks.push($label)\n\n    let $content = h(\n      'div',\n      {\n        ref: 'content',\n        class: [\n          {\n            'form-floating': !this.isHorizontal && this.floatingBoolean,\n          },\n        ],\n      },\n      contentBlocks\n    )\n    if (this.isHorizontal) {\n      $content = h(BCol, {ref: 'content', ...this.contentColProps}, {default: () => contentBlocks})\n    }\n\n    // Return it wrapped in a form group\n    // Note: Fieldsets do not support adding `row` or `form-row` directly\n    // to them due to browser specific render issues, so we move the `form-row`\n    // to an inner wrapper div when horizontal and using a fieldset\n    const rowProps = {\n      'class': [\n        this.stateClass,\n        {\n          'was-validated': this.validatedBoolean,\n        },\n      ],\n      'id': useId(() => props.id).value,\n      'disabled': isFieldset ? this.disabledBoolean : null,\n      'role': isFieldset ? null : 'group',\n      'aria-invalid': this.computedAriaInvalid,\n      // Only apply `aria-labelledby` if we are a horizontal fieldset\n      // as the legend is no longer a direct child of fieldset\n      'aria-labelledby': isFieldset && this.isHorizontal ? labelId : null,\n    }\n\n    if (this.isHorizontal && !isFieldset) {\n      return h(BFormRow, rowProps, {default: () => [$label, $content]})\n    }\n\n    return h(\n      isFieldset ? 'fieldset' : 'div',\n      rowProps,\n      this.isHorizontal && isFieldset\n        ? [h(BFormRow, null, {default: () => [$label, $content]})]\n        : this.isHorizontal || !this.floatingBoolean\n        ? [$label, $content]\n        : [$content]\n    )\n  },\n})\n</script>\n","<template>\n  <input\n    :id=\"computedId\"\n    ref=\"input\"\n    :class=\"computedClasses\"\n    :name=\"name || undefined\"\n    :form=\"form || undefined\"\n    :type=\"type\"\n    :disabled=\"disabledBoolean\"\n    :placeholder=\"placeholder\"\n    :required=\"requiredBoolean || undefined\"\n    :autocomplete=\"autocomplete || undefined\"\n    :readonly=\"readonlyBoolean || plaintextBoolean\"\n    :min=\"min\"\n    :max=\"max\"\n    :step=\"step\"\n    :list=\"type !== 'password' ? list : undefined\"\n    :aria-required=\"requiredBoolean || undefined\"\n    :aria-invalid=\"computedAriaInvalid\"\n    @input=\"onInput($event)\"\n    @change=\"onChange($event)\"\n    @blur=\"onBlur($event)\"\n  />\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, ref} from 'vue'\nimport {useBooleanish, useFormInput, useStateClass} from '../../composables'\nimport type {CommonInputProps} from '../../composables/useFormInput'\nimport type {InputType} from '../../types'\n\nconst props = withDefaults(\n  defineProps<\n    {\n      // debounce: {type: [String, Number], default: 0}, TODO: not implemented yet\n      // The above is likely a CommonInputProp\n      max?: string | number\n      min?: string | number\n      // noWheel: {type: [Boolean, String] as PropType<Booleanish>, default: false}, TODO: not implemented yet\n      step?: string | number\n      type?: InputType\n    } & CommonInputProps\n  >(),\n  {\n    max: undefined,\n    min: undefined,\n    step: undefined,\n    type: 'text',\n    // CommonInputProps\n    ariaInvalid: undefined,\n    autocomplete: undefined,\n    autofocus: false,\n    disabled: false,\n    form: undefined,\n    formatter: undefined,\n    id: undefined,\n    lazy: false,\n    lazyFormatter: false,\n    list: undefined,\n    modelValue: '',\n    name: undefined,\n    number: false,\n    placeholder: undefined,\n    plaintext: false,\n    readonly: false,\n    required: false,\n    size: undefined,\n    state: null,\n    trim: false,\n  }\n)\n\nconst emit = defineEmits<{\n  'update:modelValue': [val: any]\n  'change': [val: any]\n  'blur': [val: any]\n  'input': [val: any]\n}>()\n\nconst {input, computedId, computedAriaInvalid, onInput, onChange, onBlur, focus, blur} =\n  useFormInput(props, emit)\n\nconst disabledBoolean = useBooleanish(() => props.disabled)\nconst requiredBoolean = useBooleanish(() => props.required)\nconst readonlyBoolean = useBooleanish(() => props.readonly)\nconst plaintextBoolean = useBooleanish(() => props.plaintext)\nconst stateBoolean = useBooleanish(() => props.state)\n\nconst stateClass = useStateClass(stateBoolean)\n\nconst isHighlighted = ref(false)\n\nconst computedClasses = computed(() => {\n  const isRange = props.type === 'range'\n  const isColor = props.type === 'color'\n  return [\n    stateClass.value,\n    {\n      'form-control-highlighted': isHighlighted.value,\n      'form-range': isRange,\n      'form-control': isColor || (!props.plaintext && !isRange),\n      'form-control-color': isColor,\n      'form-control-plaintext': props.plaintext && !isRange && !isColor,\n      [`form-control-${props.size}`]: !!props.size,\n    },\n  ]\n})\n\ndefineExpose({\n  focus,\n  blur,\n})\n\n// const highlight = () => {\n//   if (isHighlighted.value === true) return\n//   isHighlighted.value = true\n//   setTimeout(() => {\n//     isHighlighted.value = false\n//   }, 2000)\n// }\n</script>\n","<template>\n  <RenderComponentOrSkip :skip=\"isButtonGroup\" :class=\"computedClasses\">\n    <input\n      :id=\"computedId\"\n      v-bind=\"$attrs\"\n      ref=\"input\"\n      v-model=\"localValue\"\n      :checked=\"localValue\"\n      :class=\"inputClasses\"\n      type=\"radio\"\n      :disabled=\"disabledBoolean || parentData?.disabled.value\"\n      :required=\"computedRequired || undefined\"\n      :name=\"name || parentData?.name.value\"\n      :form=\"form || parentData?.form.value\"\n      :aria-label=\"ariaLabel\"\n      :aria-labelledby=\"ariaLabelledby\"\n      :value=\"value\"\n      :aria-required=\"computedRequired || undefined\"\n    />\n    <label v-if=\"hasDefaultSlot || plainBoolean === false\" :for=\"computedId\" :class=\"labelClasses\">\n      <slot />\n    </label>\n  </RenderComponentOrSkip>\n</template>\n\n<script setup lang=\"ts\">\nimport {useFocus, useVModel} from '@vueuse/core'\nimport {computed, inject, nextTick, ref, useSlots, watch} from 'vue'\nimport {getClasses, getInputClasses, getLabelClasses, useBooleanish, useId} from '../../composables'\nimport type {Booleanish, ButtonVariant, Size} from '../../types'\nimport {isEmptySlot, radioGroupKey} from '../../utils'\nimport RenderComponentOrSkip from '../RenderComponentOrSkip.vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(\n  defineProps<{\n    ariaLabel?: string\n    ariaLabelledby?: string\n    form?: string\n    id?: string\n    name?: string\n    size?: Size\n    autofocus?: Booleanish\n    modelValue?: boolean | string | unknown[] | Record<string, unknown> | number | null\n    plain?: Booleanish\n    button?: Booleanish\n    buttonGroup?: Booleanish\n    disabled?: Booleanish\n    buttonVariant?: ButtonVariant | null\n    inline?: Booleanish\n    required?: Booleanish\n    state?: Booleanish | null\n    value?: string | boolean | Record<string, unknown> | number\n  }>(),\n  {\n    ariaLabel: undefined,\n    ariaLabelledby: undefined,\n    form: undefined,\n    id: undefined,\n    name: undefined,\n    autofocus: false,\n    plain: false,\n    button: false,\n    buttonGroup: false,\n    disabled: false,\n    modelValue: undefined,\n    state: null,\n    size: undefined,\n    buttonVariant: null,\n    inline: false,\n    required: false,\n    value: true,\n  }\n)\n\nconst emit = defineEmits<{\n  'input': [value: boolean | string | unknown[] | Record<string, unknown> | number | null]\n  'change': [value: boolean | string | unknown[] | Record<string, unknown> | number | null]\n  'update:modelValue': [\n    value: boolean | string | unknown[] | Record<string, unknown> | number | null\n  ]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst slots = useSlots()\n\nconst modelValue = useVModel(props, 'modelValue', emit, {passive: true})\n\nconst computedId = useId(() => props.id, 'form-check')\n\nconst autofocusBoolean = useBooleanish(() => props.autofocus)\nconst plainBoolean = useBooleanish(() => props.plain)\nconst buttonBoolean = useBooleanish(() => props.button)\nconst buttonGroupBoolean = useBooleanish(() => props.buttonGroup)\nconst disabledBoolean = useBooleanish(() => props.disabled)\nconst inlineBoolean = useBooleanish(() => props.inline)\nconst requiredBoolean = useBooleanish(() => props.required)\nconst stateBoolean = useBooleanish(() => props.state)\n\nconst parentData = inject(radioGroupKey, null)\n\nconst input = ref<HTMLElement | null>(null)\n\nconst {focused} = useFocus(input, {\n  initialValue: autofocusBoolean.value,\n})\n\nconst hasDefaultSlot = computed(() => !isEmptySlot(slots.default))\n\nconst localValue = computed({\n  get: () =>\n    parentData !== null\n      ? JSON.stringify(parentData.modelValue.value) === JSON.stringify(props.value)\n      : JSON.stringify(modelValue.value) === JSON.stringify(props.value),\n  set: (newValue: string | boolean | unknown[] | Record<string, unknown> | number | null) => {\n    const updateValue = newValue || newValue === '' || newValue === 0 ? props.value : false\n\n    emit('input', updateValue)\n    modelValue.value = updateValue\n    nextTick(() => {\n      emit('change', updateValue)\n    })\n  },\n})\n\nwatch(\n  () => parentData?.modelValue.value,\n  (newValue) => {\n    const isEqual = JSON.stringify(newValue) === JSON.stringify(props.value)\n    if (isEqual === true) return\n    localValue.value = false\n  }\n)\n\nwatch(modelValue, (newValue) => {\n  if (parentData === null || newValue === false) return\n  parentData.set(props.value)\n})\n\nconst computedRequired = computed(\n  () =>\n    !!(props.name ?? parentData?.name.value) &&\n    (requiredBoolean.value || parentData?.required.value)\n)\n\nconst isButtonGroup = computed(\n  () => buttonGroupBoolean.value || (parentData?.buttons.value ?? false)\n)\n\nconst classesObject = computed(() => ({\n  plain: plainBoolean.value || (parentData?.plain.value ?? false),\n  button: buttonBoolean.value || (parentData?.buttons.value ?? false),\n  inline: inlineBoolean.value || (parentData?.inline.value ?? false),\n  state: stateBoolean.value || parentData?.state.value,\n  size: props.size !== undefined ? props.size : parentData?.size.value ?? 'md', // This is where the true default is made\n  buttonVariant:\n    props.buttonVariant !== null\n      ? props.buttonVariant\n      : parentData?.buttonVariant.value ?? 'secondary', // This is where the true default is made\n}))\nconst computedClasses = getClasses(classesObject)\nconst inputClasses = getInputClasses(classesObject)\nconst labelClasses = getLabelClasses(classesObject)\n\ndefineExpose({\n  focus: () => {\n    focused.value = true\n  },\n  blur: () => {\n    focused.value = false\n  },\n})\n</script>\n","<template>\n  <div\n    v-bind=\"computedAttrs\"\n    :id=\"computedId\"\n    ref=\"element\"\n    role=\"radiogroup\"\n    :class=\"computedClasses\"\n    class=\"bv-no-focus-ring\"\n    tabindex=\"-1\"\n  >\n    <slot name=\"first\" />\n    <BFormRadio v-for=\"item in normalizeOptions\" :key=\"item.self\" v-bind=\"item.props\">\n      <!-- eslint-disable-next-line vue/no-v-html -->\n      <span v-if=\"item.html\" v-html=\"item.html\" />\n      <span v-else v-text=\"item.text\" />\n    </BFormRadio>\n    <slot />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport type {AriaInvalid, Booleanish, ButtonVariant, Size} from '../../types'\nimport {computed, nextTick, provide, readonly, ref, toRef} from 'vue'\nimport {radioGroupKey} from '../../utils'\nimport BFormRadio from './BFormRadio.vue'\nimport {getGroupAttr, getGroupClasses, useBooleanish, useId} from '../../composables'\nimport {useFocus, useVModel} from '@vueuse/core'\n\nconst props = withDefaults(\n  defineProps<{\n    size?: Size\n    form?: string\n    id?: string\n    name?: string\n    modelValue?: string | boolean | unknown[] | Record<string, unknown> | number | null\n    ariaInvalid?: AriaInvalid\n    autofocus?: Booleanish\n    buttonVariant?: ButtonVariant | null\n    buttons?: Booleanish\n    disabled?: Booleanish\n    disabledField?: string\n    htmlField?: string\n    options?: (string | number | Record<string, unknown>)[]\n    plain?: Booleanish\n    required?: Booleanish\n    stacked?: Booleanish\n    state?: Booleanish | null\n    textField?: string\n    validated?: Booleanish\n    valueField?: string\n  }>(),\n  {\n    size: 'md',\n    form: undefined,\n    id: undefined,\n    name: undefined,\n    modelValue: null,\n    autofocus: false,\n    buttonVariant: 'secondary',\n    buttons: false,\n    ariaInvalid: undefined,\n    state: null,\n    disabled: false,\n    disabledField: 'disabled',\n    htmlField: 'html',\n    options: () => [],\n    plain: false,\n    required: false,\n    stacked: false,\n    textField: 'text',\n    validated: false,\n    valueField: 'value',\n  }\n)\n\nconst emit = defineEmits<{\n  'input': [value: string | boolean | unknown[] | Record<string, unknown> | number | null]\n  'update:modelValue': [\n    value: string | boolean | unknown[] | Record<string, unknown> | number | null\n  ]\n  'change': [value: string | boolean | unknown[] | Record<string, unknown> | number | null]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  first?: (props: Record<string, never>) => any\n}>()\n\nconst modelValue = useVModel(props, 'modelValue', emit)\n\nconst computedId = useId(() => props.id, 'radio')\nconst computedName = useId(() => props.name, 'checkbox')\n\nconst autofocusBoolean = useBooleanish(() => props.autofocus)\nconst buttonsBoolean = useBooleanish(() => props.buttons)\nconst disabledBoolean = useBooleanish(() => props.disabled)\nconst plainBoolean = useBooleanish(() => props.plain)\nconst requiredBoolean = useBooleanish(() => props.required)\nconst stackedBoolean = useBooleanish(() => props.stacked)\nconst stateBoolean = useBooleanish(() => props.state)\nconst validatedBoolean = useBooleanish(() => props.validated)\n\nconst element = ref<HTMLElement | null>(null)\n\nconst {focused} = useFocus(element, {\n  initialValue: autofocusBoolean.value,\n})\n\nprovide(radioGroupKey, {\n  set: (value: string | boolean | unknown[] | Record<string, unknown> | number | null) => {\n    emit('input', value)\n    modelValue.value = value\n    nextTick(() => {\n      emit('change', value)\n    })\n  },\n  modelValue: computed(() => modelValue.value),\n  buttonVariant: readonly(toRef(props, 'buttonVariant')),\n  form: readonly(toRef(props, 'form')),\n  name: computedName,\n  buttons: buttonsBoolean,\n  state: stateBoolean,\n  plain: plainBoolean,\n  size: readonly(toRef(props, 'size')),\n  inline: computed(() => !stackedBoolean.value),\n  required: requiredBoolean,\n  disabled: disabledBoolean,\n})\n\nconst normalizeOptions = computed(() =>\n  props.options.map((el, ind) =>\n    typeof el === 'string' || typeof el === 'number'\n      ? {\n          props: {\n            value: el,\n            disabled: disabledBoolean.value,\n          },\n          text: el.toString(),\n          html: undefined,\n          self: Symbol(`radioGroupOptionItem${ind}`),\n        }\n      : {\n          props: {\n            value: el[props.valueField] as string | undefined,\n            disabled: el[props.disabledField] as boolean | undefined,\n            ...(el.props ? el.props : {}),\n          },\n          text: el[props.textField] as string | undefined,\n          html: el[props.htmlField] as string | undefined,\n          self: Symbol(`radioGroupOptionItem${ind}`),\n        }\n  )\n)\n\nconst classesObject = computed(() => ({\n  required: requiredBoolean.value,\n  ariaInvalid: props.ariaInvalid,\n  state: stateBoolean.value,\n  validated: validatedBoolean.value,\n  buttons: buttonsBoolean.value,\n  stacked: stackedBoolean.value,\n  size: props.size,\n}))\nconst computedAttrs = getGroupAttr(classesObject)\nconst computedClasses = getGroupClasses(classesObject)\n\ndefineExpose({\n  focus: () => {\n    focused.value = true\n  },\n  blur: () => {\n    focused.value = false\n  },\n})\n</script>\n","<template>\n  <option :value=\"value\" :disabled=\"disabledBoolean\">\n    <slot />\n  </option>\n</template>\n\n<script setup lang=\"ts\">\nimport {useBooleanish} from '../../composables'\nimport type {Booleanish} from '../../types'\n\nconst props = withDefaults(\n  defineProps<{\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    value?: any\n    disabled?: Booleanish\n  }>(),\n  {\n    disabled: false,\n    value: undefined,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst disabledBoolean = useBooleanish(() => props.disabled)\n</script>\n","<template>\n  <optgroup :label=\"label\">\n    <slot name=\"first\" />\n    <!-- eslint-disable vue/no-v-text-v-html-on-component -->\n    <!-- eslint-disable vue/no-v-html -->\n    <!-- TODO these options don't seem right for the component -->\n    <BFormSelectOption\n      v-for=\"(option, index) in formOptions\"\n      :key=\"index\"\n      :value=\"(option as any).value\"\n      :disabled=\"(option as any).disabled\"\n      v-bind=\"$attrs\"\n      v-html=\"(option as any).html || (option as any).text\"\n    />\n    <!--eslint-enable-->\n    <slot />\n  </optgroup>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed} from 'vue'\nimport BFormSelectOption from './BFormSelectOption.vue'\nimport {normalizeOptions} from '../../composables'\n\nconst props = withDefaults(\n  defineProps<{\n    label?: string\n    disabledField?: string\n    htmlField?: string\n    options?: unknown[] | Record<string, unknown>\n    textField?: string\n    valueField?: string\n  }>(),\n  {\n    disabledField: 'disabled',\n    label: undefined,\n    htmlField: 'html',\n    options: () => [],\n    textField: 'text',\n    valueField: 'value',\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  first?: (props: Record<string, never>) => any\n}>()\n\n// TODO this needs to be redone to fit the structure of BFormCheckboxGroup\nconst formOptions = computed(() =>\n  normalizeOptions(props.options as any[], 'BFormSelectOptionGroup', props)\n)\n</script>\n","<template>\n  <select\n    :id=\"computedId\"\n    ref=\"input\"\n    v-bind=\"$attrs\"\n    v-model=\"localValue\"\n    :class=\"computedClasses\"\n    :name=\"name\"\n    :form=\"form || undefined\"\n    :multiple=\"multipleBoolean || undefined\"\n    :size=\"computedSelectSize\"\n    :disabled=\"disabledBoolean\"\n    :required=\"requiredBoolean || undefined\"\n    :aria-required=\"requiredBoolean || undefined\"\n    :aria-invalid=\"computedAriaInvalid\"\n  >\n    <slot name=\"first\" />\n    <template v-for=\"(option, index) in formOptions\" :key=\"index\">\n      <BFormSelectOptionGroup\n        v-if=\"Array.isArray((option as any).options)\"\n        :label=\"(option as any).label\"\n        :options=\"(option as any).options\"\n      />\n      <!-- eslint-disable vue/no-v-text-v-html-on-component -->\n      <!-- eslint-disable vue/no-v-html -->\n      <BFormSelectOption\n        v-else\n        :value=\"(option as any).value\"\n        :disabled=\"(option as any).disabled\"\n        v-html=\"(option as any).html || (option as any).text\"\n      />\n      <!--eslint-enable-->\n    </template>\n    <slot />\n  </select>\n</template>\n\n<script setup lang=\"ts\">\nimport {resolveAriaInvalid} from '../../utils'\nimport type {AriaInvalid, Booleanish, Size} from '../../types'\nimport {computed, nextTick, ref} from 'vue'\nimport BFormSelectOption from './BFormSelectOption.vue'\nimport BFormSelectOptionGroup from './BFormSelectOptionGroup.vue'\nimport {normalizeOptions, useBooleanish, useId, useStateClass} from '../../composables'\nimport {useFocus, useVModel} from '@vueuse/core'\n\nconst props = withDefaults(\n  defineProps<{\n    ariaInvalid?: AriaInvalid\n    autofocus?: Booleanish\n    disabled?: Booleanish\n    disabledField?: string\n    form?: string\n    htmlField?: string\n    id?: string\n    labelField?: string\n    multiple?: Booleanish\n    name?: string\n    options?: unknown[] | Record<string, unknown>\n    optionsField?: string\n    plain?: Booleanish\n    required?: Booleanish\n    selectSize?: number\n    size?: Size\n    state?: Booleanish | null\n    textField?: string\n    valueField?: string\n    modelValue?: string | unknown[] | Record<string, unknown> | number | null\n  }>(),\n  {\n    form: undefined,\n    id: undefined,\n    name: undefined,\n    size: 'md',\n    ariaInvalid: undefined,\n    autofocus: false,\n    disabled: false,\n    disabledField: 'disabled',\n    htmlField: 'html',\n    state: null,\n    labelField: 'label',\n    multiple: false,\n    options: () => [],\n    optionsField: 'options',\n    plain: false,\n    required: false,\n    selectSize: 0,\n    textField: 'text',\n    valueField: 'value',\n    modelValue: '',\n  }\n)\n\nconst emit = defineEmits<{\n  'input': [value: unknown]\n  'update:modelValue': [value: unknown]\n  'change': [value: unknown]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  first?: (props: Record<string, never>) => any\n}>()\n\nconst modelValue = useVModel(props, 'modelValue', emit)\n\nconst computedId = useId(() => props.id, 'input')\n\nconst autofocusBoolean = useBooleanish(() => props.autofocus)\nconst disabledBoolean = useBooleanish(() => props.disabled)\nconst multipleBoolean = useBooleanish(() => props.multiple)\nconst plainBoolean = useBooleanish(() => props.plain)\nconst requiredBoolean = useBooleanish(() => props.required)\nconst stateBoolean = useBooleanish(() => props.state)\n\nconst stateClass = useStateClass(stateBoolean)\n\nconst input = ref<HTMLElement>()\n\nconst {focused} = useFocus(input, {\n  initialValue: autofocusBoolean.value,\n})\n\nconst computedClasses = computed(() => [\n  stateClass.value,\n  {\n    'form-control': plainBoolean.value,\n    [`form-control-${props.size}`]: props.size !== 'md' && plainBoolean.value,\n    'form-select': !plainBoolean.value,\n    [`form-select-${props.size}`]: props.size !== 'md' && !plainBoolean.value,\n  },\n])\n\nconst computedSelectSize = computed<number | undefined>(() =>\n  props.selectSize || plainBoolean.value ? props.selectSize : undefined\n)\n\nconst computedAriaInvalid = computed(() =>\n  resolveAriaInvalid(props.ariaInvalid, stateBoolean.value)\n)\n\n// TODO this needs to be redone to fit the structure of BFormCheckboxGroup\n// It also doesn't work for array syntaxes. Review second example from https://bootstrap-vue.org/docs/components/form-select\n// For more info on how it should behave\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst formOptions = computed(() => normalizeOptions(props.options as any[], 'BFormSelect', props))\nconst localValue = computed({\n  get: () => modelValue.value,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  set: (newValue: any) => {\n    emit('input', newValue)\n    modelValue.value = newValue\n    nextTick(() => {\n      emit('change', newValue)\n    })\n  },\n})\n\ndefineExpose({\n  focus: () => {\n    focused.value = true\n  },\n  blur: () => {\n    focused.value = false\n  },\n})\n</script>\n","import {RX_STRIP_LOCALE_MODS} from '../constants/regex'\nimport {toString} from './stringUtils'\n\n// Languages that are RTL\nconst RTL_LANGS = [\n  'ar',\n  'az',\n  'ckb',\n  'fa',\n  'he',\n  'ks',\n  'lrc',\n  'mzn',\n  'ps',\n  'sd',\n  'te',\n  'ug',\n  'ur',\n  'yi',\n].map((locale) => locale.toLowerCase())\n\n// Returns true if the locale is RTL\nexport const isLocaleRTL = (locale: string) => {\n  // Determines if the locale is RTL (only single locale supported)\n  const parts = toString(locale).toLowerCase().replace(RX_STRIP_LOCALE_MODS, '').split('-')\n  const locale1 = parts.slice(0, 2).join('-')\n  const [locale2] = parts\n  return RTL_LANGS.includes(locale1) || RTL_LANGS.includes(locale2)\n}\n","import {HAS_PASSIVE_EVENT_SUPPORT} from './env'\nimport {isObject} from './inspect'\n\n// Normalize event options based on support of passive option\n// Exported only for testing purposes\nexport const parseEventOptions = (options: any): boolean | EventListenerOptions | undefined => {\n  /* istanbul ignore else: can't test in JSDOM, as it supports passive */\n  if (HAS_PASSIVE_EVENT_SUPPORT) {\n    return isObject(options) ? options : {capture: !!options || false}\n  }\n  // Need to translate to actual Boolean value\n  return !!(isObject(options) ? options.capture : options)\n}\n\n// Attach an event listener to an element\nexport const eventOn = (\n  el: Element,\n  eventName: string,\n  handler: EventListener,\n  options: boolean | EventListenerOptions | undefined\n) => {\n  if (el && el.addEventListener) {\n    el.addEventListener(eventName, handler, parseEventOptions(options))\n  }\n}\n\n// Remove an event listener from an element\nexport const eventOff = (\n  el: Element,\n  eventName: string,\n  handler: EventListener,\n  options: boolean | EventListenerOptions | undefined\n) => {\n  if (el && el.removeEventListener) {\n    el.removeEventListener(eventName, handler, options)\n  }\n}\n\n// Utility method to add/remove a event listener based on first argument (boolean)\n// It passes all other arguments to the `eventOn()` or `eventOff` method\nexport const eventOnOff = (on: boolean, eventParams: Parameters<typeof eventOff>) => {\n  const method = on ? eventOn : eventOff\n  method(...eventParams)\n}\n\n// Utility method to prevent the default event handling and propagation\nexport const stopEvent = (\n  event: Event,\n  {preventDefault = true, propagation = true, immediatePropagation = false} = {}\n) => {\n  if (preventDefault) {\n    event.preventDefault()\n  }\n  if (propagation) {\n    event.stopPropagation()\n  }\n  if (immediatePropagation) {\n    event.stopImmediatePropagation()\n  }\n}\n","export const CODE_BACKSPACE = 'Backspace'\nexport const CODE_BREAK = 19\nexport const CODE_DELETE = 46\nexport const CODE_DOWN = 'ArrowDown'\nexport const CODE_END = 'End'\nexport const CODE_ENTER = 13\nexport const CODE_ESC = 27\nexport const CODE_HOME = 'Home'\nexport const CODE_LEFT = 37\nexport const CODE_PAGEDOWN = 'PageDown'\nexport const CODE_PAGEUP = 'PageUp'\nexport const CODE_RIGHT = 39\nexport const CODE_SPACE = 32\nexport const CODE_UP = 'ArrowUp'\n","<script lang=\"ts\">\nimport {computed, defineComponent, h, type PropType, ref, type Ref} from 'vue'\nimport type {Booleanish} from '../../types'\nimport {toFloat, toInteger} from '../../utils/number'\nimport {isLocaleRTL} from '../../utils/locale'\nimport {eventOnOff, stopEvent} from '../../utils/event'\nimport {normalizeSlot} from '../../utils'\n// import {attemptBlur, attemptFocus, normalizeSlot} from '../../utils'\n//TODO alias\n\nimport {\n  CODE_DOWN,\n  CODE_END,\n  CODE_HOME,\n  CODE_PAGEDOWN,\n  CODE_PAGEUP,\n  CODE_UP,\n} from '../../constants/codes'\nimport {useVModel} from '@vueuse/core'\n\n// Default for spin button range and step\nconst DEFAULT_MIN = 1\nconst DEFAULT_MAX = 100\nconst DEFAULT_STEP = 1\n\n// Delay before auto-repeat in ms\nconst DEFAULT_REPEAT_DELAY = 500\n// Repeat interval in ms\nconst DEFAULT_REPEAT_INTERVAL = 100\n// Repeat rate increased after number of repeats\nconst DEFAULT_REPEAT_THRESHOLD = 10\n// Repeat speed multiplier (step multiplier, must be an integer)\nconst DEFAULT_REPEAT_MULTIPLIER = 4\n\nconst KEY_CODES = [CODE_UP, CODE_DOWN, CODE_HOME, CODE_END, CODE_PAGEUP, CODE_PAGEDOWN]\n\nexport default defineComponent({\n  props: {\n    ariaControls: {type: String, default: undefined},\n    ariaLabel: {type: String, default: undefined},\n    labelIncrement: {type: String, default: 'Increment'},\n    labelDecrement: {type: String, default: 'Decrement'},\n    modelValue: {type: Number as PropType<number | null>, default: null}, // V-model prop\n    name: {type: String, default: 'BFormSpinButton'},\n    disabled: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    placeholder: {type: String, default: undefined},\n    locale: {type: String, default: 'locale'},\n    form: {type: String, default: undefined},\n    inline: {type: Boolean, default: false},\n    size: {type: String, default: undefined},\n    formatterFn: {\n      type: Function as PropType<(value: number) => any>,\n      default: undefined,\n    },\n    readonly: {type: Boolean, default: false},\n    vertical: {type: Boolean, default: false},\n    repeatDelay: {\n      type: [String, Number] as PropType<number | string>,\n      default: DEFAULT_REPEAT_DELAY,\n    },\n    repeatInterval: {\n      type: [String, Number] as PropType<number | string>,\n      default: DEFAULT_REPEAT_INTERVAL,\n    },\n    repeatStepMultiplier: {\n      type: [String, Number] as PropType<number | string>,\n      default: DEFAULT_REPEAT_MULTIPLIER,\n    },\n    repeatThreshold: {\n      type: [String, Number] as PropType<number | string>,\n      default: DEFAULT_REPEAT_THRESHOLD,\n    },\n    required: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    step: {type: [String, Number] as PropType<number | string>, default: DEFAULT_STEP},\n    min: {type: [String, Number] as PropType<number | string>, default: DEFAULT_MIN},\n    max: {type: [String, Number] as PropType<number | string>, default: DEFAULT_MAX},\n    wrap: {type: Boolean, default: false},\n    state: {type: [Boolean, String] as PropType<Booleanish | null>, default: null},\n  },\n  emits: ['update:modelValue', 'change'],\n  setup(props, {emit}) {\n    const modelValue = useVModel(props, 'modelValue', emit)\n\n    const hasFocus = ref(false)\n    const spinId = computed(() => 1) //TODO\n\n    const emitChange = () => {\n      emit('change', localValue.value)\n    }\n\n    // due to modelValue being optional we will need to store changes locally\n    const lvalue: Ref<null | number> = ref(null)\n\n    const localValue = computed({\n      get: () => (modelValue.value === null ? lvalue.value : modelValue.value),\n      set: (newValue) => {\n        if (modelValue.value === null) {\n          lvalue.value = newValue\n        } else {\n          modelValue.value = newValue\n        }\n      },\n    })\n    //non reactive properties\n    let $_autoDelayTimer: ReturnType<typeof setTimeout> | undefined\n    let $_autoRepeatTimer: ReturnType<typeof setTimeout> | undefined\n    let $_keyIsDown = false\n\n    // const computedInline = computed(() => props.inline && !props.vertical)\n\n    // const computedReadonly = computed(() => props.readonly && !props.disabled)\n\n    const computedStep = computed(() => toFloat(props.step, DEFAULT_STEP))\n\n    const computedMin = computed(() => toFloat(props.min, DEFAULT_MIN))\n\n    const computedMax = computed(() => {\n      const max = toFloat(props.max, DEFAULT_MAX)\n      const step = computedStep.value\n      const min = computedMin.value\n      return Math.floor((max - min) / step) * step + min\n    })\n\n    const computedDelay = computed(() => {\n      const delay = toInteger(props.repeatDelay as number, 0)\n      return delay > 0 ? delay : DEFAULT_REPEAT_DELAY\n    })\n\n    const computedInterval = computed(() => {\n      const interval = toInteger(props.repeatInterval as number, 0)\n      return interval > 0 ? interval : DEFAULT_REPEAT_INTERVAL\n    })\n\n    const computedThreshold = computed(() =>\n      Math.max(toInteger(props.repeatThreshold as number, DEFAULT_REPEAT_THRESHOLD), 1)\n    )\n\n    const computedStepMultiplier = computed(() =>\n      Math.max(toInteger(props.repeatStepMultiplier as number, DEFAULT_REPEAT_MULTIPLIER), 1)\n    )\n\n    const computedPrecision = computed(() => {\n      const step = computedStep.value\n      return Math.floor(step) === step ? 0 : (step.toString().split('.')[1] || '').length\n    })\n\n    const computedMultiplier = computed(() => Math.pow(10, computedPrecision.value || 0))\n\n    const valueAsFixed = computed(() => {\n      const {value} = localValue\n      return value === null ? '' : value.toFixed(computedPrecision.value)\n    })\n\n    const computedLocale = computed(() => {\n      //todo\n      const locales = [props.locale]\n      const nf = new Intl.NumberFormat(locales)\n      return nf.resolvedOptions().locale\n    })\n\n    const computedRTL = computed(() =>\n      //todo\n      isLocaleRTL(computedLocale.value)\n    )\n\n    const defaultFormatter = () => {\n      //locale needs to be resolved\n      // Returns and `Intl.NumberFormat` formatter method reference\n      const precision = computedPrecision.value\n      const nf = new Intl.NumberFormat(computedLocale.value, {\n        style: 'decimal',\n        useGrouping: false,\n        minimumIntegerDigits: 1,\n        minimumFractionDigits: precision,\n        maximumFractionDigits: precision,\n        notation: 'standard',\n      })\n\n      return nf.format\n    }\n    //TODO allow for prop formatter function\n    const computedFormatter = computed(() => props.formatterFn ?? defaultFormatter())\n\n    const computedAttrs = computed(() => ({\n      role: 'group',\n      lang: computedLocale.value,\n      tabindex: props.disabled ? null : '-1',\n      title: props.ariaLabel,\n    }))\n    const hasValue = computed(() => modelValue.value !== null || lvalue.value !== null)\n\n    const computedSpinAttrs = computed(() => ({\n      'dir': computedRTL.value,\n      'spinId': spinId.value,\n      'tabindex': props.disabled ? null : '0',\n      'role': 'spinbutton',\n      'aria-live': 'off',\n      'aria-label': props.ariaLabel || null,\n      'aria-controls': props.ariaControls || null,\n      'aria-invalid': props.state === false || (!hasValue.value && props.required) ? true : null,\n      'aria-required': props.required ? true : null,\n      'aria-valuemin': computedMin.value,\n      'aria-valuemax': computedMax.value,\n      'aria-valuenow': localValue.value !== null ? localValue.value : null,\n      'aria-valuetext':\n        localValue.value !== null ? computedFormatter.value(localValue.value) : null,\n    }))\n\n    // methods\n\n    const stepValue = (direction: number) => {\n      // Sets a new incremented or decremented value, supporting optional wrapping\n      // Direction is either +1 or -1 (or a multiple thereof)\n      let {value} = localValue\n      if (!props.disabled && value !== null) {\n        const step = computedStep.value * direction\n        const min = computedMin.value\n        const max = computedMax.value\n        const multiplier = computedMultiplier.value\n        const {wrap} = props\n        // We ensure that the value steps like a native input\n        value = Math.round((value - min) / step) * step + min + step\n        // We ensure that precision is maintained (decimals)\n        value = Math.round(value * multiplier) / multiplier\n        // Handle if wrapping is enabled\n        localValue.value =\n          value > max ? (wrap ? min : max) : value < min ? (wrap ? max : min) : value\n      }\n    }\n    // const onFocusBlur = (event: FocusEvent) => {\n    //   hasFocus.value = props.disabled ? false : event.type === 'focus'\n    // }\n\n    const stepUp = (multiplier = 1) => {\n      if (localValue.value === null) {\n        localValue.value = computedMin.value\n      } else {\n        stepValue(+1 * multiplier)\n      }\n    }\n    const stepDown = (multiplier = 1) => {\n      if (localValue.value === null) {\n        localValue.value = props.wrap ? computedMax.value : computedMin.value\n      } else {\n        stepValue(-1 * multiplier)\n      }\n    }\n\n    const onKeydown = (event: KeyboardEvent) => {\n      const {code, altKey, ctrlKey, metaKey} = event\n\n      /* istanbul ignore if */\n      if (props.disabled || props.readonly || altKey || ctrlKey || metaKey) {\n        return\n      }\n\n      if (KEY_CODES.includes(code)) {\n        // https://w3c.github.io/aria-practices/#spinbutton\n        stopEvent(event, {propagation: false})\n        /* istanbul ignore if */\n        if ($_keyIsDown) {\n          // Keypress is already in progress\n          return\n        }\n\n        resetTimers()\n        if ([CODE_UP, CODE_DOWN].includes(code)) {\n          // The following use the custom auto-repeat handling\n\n          $_keyIsDown = true\n          if (code === CODE_UP) {\n            handleStepRepeat(event, stepUp)\n          } else if (code === CODE_DOWN) {\n            handleStepRepeat(event, stepDown)\n          }\n        } else {\n          // These use native OS key repeating\n          if (code === CODE_PAGEUP) {\n            stepUp(computedStepMultiplier.value)\n          } else if (code === CODE_PAGEDOWN) {\n            stepDown(computedStepMultiplier.value)\n          } else if (code === CODE_HOME) {\n            localValue.value = computedMin.value\n          } else if (code === CODE_END) {\n            localValue.value = computedMax.value\n          }\n        }\n      }\n    }\n    const onKeyup = (event: KeyboardEvent) => {\n      // Emit a change event when the keyup happens\n\n      const {code, altKey, ctrlKey, metaKey} = event\n\n      /* istanbul ignore if */\n      if (props.disabled || props.readonly || altKey || ctrlKey || metaKey) {\n        return\n      }\n      if (KEY_CODES.includes(code)) {\n        stopEvent(event, {propagation: false})\n        resetTimers()\n        $_keyIsDown = false\n        emitChange()\n      }\n    }\n\n    // takes in a mount or Keyboard Event\n    const handleStepRepeat = (event: Event, stepper: (step: number) => void) => {\n      const {type} = event || {}\n\n      if (!props.disabled && !props.readonly) {\n        /* istanbul ignore if */\n        if (isMouseEvent(event)) {\n          if (type === 'mousedown' && event.button) {\n            // We only respond to left (main === 0) button clicks\n            return\n          }\n        }\n        resetTimers()\n        // Step the counter initially\n        stepper(1)\n        const threshold = computedThreshold.value\n        const multiplier = computedStepMultiplier.value\n        const delay = computedDelay.value\n        const interval = computedInterval.value\n\n        // Initiate the delay/repeat interval\n        $_autoDelayTimer = setTimeout(() => {\n          let count = 0\n          $_autoRepeatTimer = setInterval(() => {\n            // After N initial repeats, we increase the incrementing step amount\n            // We do this to minimize screen reader announcements of the value\n            // (values are announced every change, which can be chatty for SR users)\n            // And to make it easer to select a value when the range is large\n            stepper(count < threshold ? 1 : multiplier)\n            count++\n          }, interval)\n        }, delay)\n      }\n    }\n\n    function isMouseEvent(evt: Event): evt is MouseEvent {\n      return evt.type === 'mouseup' || evt.type === 'mousedown'\n    }\n    // eslint-disable-next-line no-undef\n    const onMouseup: EventListener = (event: Event) => {\n      // `<body>` listener, only enabled when mousedown starts\n\n      /* istanbul ignore if */\n      if (isMouseEvent(event)) {\n        if (event.type === 'mouseup' && event.button) {\n          // Ignore non left button (main === 0) mouse button click\n          return\n        }\n      }\n\n      stopEvent(event, {propagation: false})\n      resetTimers()\n      setMouseup(false)\n      // Trigger the change event\n      emitChange()\n    }\n\n    const setMouseup = (on: boolean) => {\n      // Enable or disabled the body mouseup/touchend handlers\n      // Use try/catch to handle case when called server side\n      try {\n        eventOnOff(on, [document.body, 'mouseup', onMouseup, false])\n        eventOnOff(on, [document.body, 'touchend', onMouseup, false])\n      } catch {\n        return 0\n      }\n    }\n    const resetTimers = () => {\n      clearTimeout($_autoDelayTimer)\n      clearInterval($_autoRepeatTimer)\n      $_autoDelayTimer = undefined\n      $_autoRepeatTimer = undefined\n    }\n\n    // const clearRepeat = () => {\n    //   resetTimers()\n    //   setMouseup(false)\n    //   $_keyIsDown = false\n    // }\n\n    // Render Helping functions\n    const makeButton = (\n      stepper: (multiplier?: number) => void,\n      label: string,\n      IconCmp: any,\n      keyRef: string,\n      shortcut: any,\n      btnDisabled: boolean,\n      slotName: string\n    ) => {\n      const $icon = h(IconCmp, {\n        props: {scale: hasFocus.value ? 1.5 : 1.25},\n        attrs: {'aria-hidden': true},\n      })\n\n      const scope = {hasFocus: hasFocus.value}\n\n      const handler = (event: Event) => {\n        if (!props.disabled && !props.readonly) {\n          stopEvent(event, {propagation: false})\n          setMouseup(true)\n          // Since we `preventDefault()`, we must manually focus the button\n          // attemptFocus(event.currentTarget)\n          handleStepRepeat(event, stepper)\n        }\n      }\n\n      return h(\n        'button',\n        {\n          'class': [{'py-0': !props.vertical}, 'btn', 'btn-sm', 'border-0', 'rounded-0'],\n          'tabindex': '-1',\n          'type': 'button',\n          'disabled': props.disabled || props.readonly || btnDisabled,\n          'aria-disabled': props.disabled || props.readonly || btnDisabled ? true : null,\n          'aria-controls': spinId.value,\n          'aria-label': label || null,\n          'aria-keyshortcuts': shortcut || null,\n          'onmousedown': handler,\n          'ontouchstart': handler,\n          // 'ref': keyRef,\n        },\n        [normalizeSlot(slotName, scope) || $icon]\n      )\n    }\n    return () => {\n      //component definitions\n      const $increment = makeButton(\n        stepUp,\n        props.labelIncrement,\n        h(\n          'svg',\n          {\n            xmlns: 'http://www.w3.org/2000/svg',\n            width: '16',\n            height: '16',\n            fill: 'currentColor',\n            class: 'bi bi-plus',\n            viewBox: '0 0 16 16',\n          },\n          h('path', {\n            d: 'M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z',\n          })\n        ),\n        'inc',\n        'ArrowUp',\n        false,\n        'increment'\n      )\n      const $decrement = makeButton(\n        stepDown,\n        props.labelDecrement,\n        h(\n          'svg',\n          {\n            xmlns: 'http://www.w3.org/2000/svg',\n            width: '16',\n            height: '16',\n            fill: 'currentColor',\n            class: 'bi bi-dash',\n            viewBox: '0 0 16 16',\n          },\n          h('path', {d: 'M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z'})\n        ),\n        'dec',\n        'ArrowDown',\n        false,\n        'decrement'\n      )\n\n      const $hidden = []\n\n      if (props.name && !props.disabled) {\n        $hidden.push(\n          h('input', {\n            type: 'hidden',\n            name: props.name,\n            form: props.form || null,\n            // TODO: Should this be set to '' if value is out of range?\n            value: valueAsFixed.value,\n            key: 'hidden',\n          })\n        )\n      }\n\n      const $spin = h(\n        // We use 'output' element to make this accept a `<label for=\"id\">` (Except IE)\n        'output',\n        {\n          class: [\n            {'d-flex': props.vertical},\n            {'align-self-center': !props.vertical},\n            {'align-items-center': props.vertical},\n            {'border-top': props.vertical},\n            {'border-bottom': props.vertical},\n            {'border-start': !props.vertical},\n            {'border-end': !props.vertical},\n            'flex-grow-1',\n          ],\n          ...computedSpinAttrs.value,\n          key: 'output',\n          // ref: 'spinner',\n        },\n        [\n          h(\n            'bdi',\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            //@ts-ignore How can we narrow this type down\n            hasValue.value ? computedFormatter.value(localValue.value) : props.placeholder || ''\n          ),\n        ]\n      )\n\n      return h(\n        'div',\n        {\n          class: [\n            'b-form-spinbutton form-control',\n            {disabled: props.disabled},\n            {readonly: props.readonly},\n            {focus: hasFocus},\n            {'d-inline-flex': props.inline || props.vertical},\n            {'d-flex': !props.inline && !props.vertical},\n            {'align-items-stretch': !props.vertical},\n            {'flex-column': props.vertical},\n            props.size ? `form-control-${props.size}` : null,\n            // this.stateClass //TODO\n          ],\n          ...computedAttrs.value,\n          onkeydown: onKeydown,\n          onkeyup: onKeyup,\n          // We use capture phase (`!` prefix) since focus and blur do not bubble\n          // 'focus': onFocusBlur, //TODO\n          // 'blur': onFocusBlur, //TODO\n        },\n        props.vertical\n          ? [$increment, $hidden, $spin, $decrement]\n          : [$decrement, $hidden, $spin, $increment]\n      )\n    }\n  },\n})\n</script>\n","<template>\n  <component\n    :is=\"tag\"\n    :id=\"computedId\"\n    :title=\"tagText\"\n    class=\"badge b-form-tag d-inline-flex align-items-center mw-100\"\n    :class=\"computedClasses\"\n    :aria-labelledby=\"taglabelId\"\n  >\n    <span :id=\"taglabelId\" class=\"b-form-tag-content flex-grow-1 text-truncate\">\n      <slot>{{ tagText }}</slot>\n    </span>\n    <BCloseButton\n      v-if=\"!disabledBoolean && !noRemoveBoolean\"\n      aria-keyshortcuts=\"Delete\"\n      :aria-label=\"removeLabel\"\n      class=\"b-form-tag-remove\"\n      :white=\"variant !== null && !['warning', 'info', 'light'].includes(variant)\"\n      :aria-describedby=\"taglabelId\"\n      :aria-controls=\"id\"\n      @click=\"emit('remove', tagText)\"\n    />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, useSlots} from 'vue'\nimport {useBooleanish, useId} from '../../composables'\nimport type {Booleanish, ColorVariant} from '../../types'\nimport BCloseButton from '../BButton/BCloseButton.vue'\n\nconst props = withDefaults(\n  defineProps<{\n    id?: string\n    title?: string\n    disabled?: Booleanish\n    noRemove?: Booleanish\n    pill?: Booleanish\n    removeLabel?: string\n    tag?: string\n    variant?: ColorVariant | null\n  }>(),\n  {\n    id: undefined,\n    title: undefined,\n    disabled: false,\n    noRemove: false,\n    pill: false,\n    removeLabel: 'Remove tag',\n    tag: 'span',\n    variant: 'secondary',\n  }\n)\n\nconst emit = defineEmits<{\n  remove: [value: string]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst slots = useSlots()\n\nconst computedId = useId(() => props.id)\n\nconst disabledBoolean = useBooleanish(() => props.disabled)\nconst noRemoveBoolean = useBooleanish(() => props.noRemove)\nconst pillBoolean = useBooleanish(() => props.pill)\n\nconst tagText = computed<string>(\n  () => ((slots.default?.()[0].children ?? '').toString() || props.title) ?? ''\n)\n\nconst taglabelId = computed<string>(() => `${computedId.value}taglabel__`)\n\nconst computedClasses = computed(() => ({\n  [`bg-${props.variant}`]: props.variant !== null,\n  'text-dark': props.variant !== null && ['warning', 'info', 'light'].includes(props.variant),\n  'rounded-pill': pillBoolean.value,\n  'disabled': disabledBoolean.value,\n}))\n</script>\n","<template>\n  <div\n    :id=\"computedId\"\n    class=\"b-form-tags form-control h-auto\"\n    :class=\"computedClasses\"\n    role=\"group\"\n    tabindex=\"-1\"\n    @focusin=\"onFocusin\"\n    @focusout=\"emit('focusout', $event)\"\n  >\n    <output\n      :id=\"`${computedId}selected_tags__`\"\n      class=\"visually-hidden\"\n      :for=\"_inputId\"\n      :aria-live=\"focused ? 'polite' : 'off'\"\n      aria-atomic=\"true\"\n      aria-relevant=\"additions text\"\n      >{{ tags.join(', ') }}</output\n    >\n    <div\n      :id=\"`${computedId}removed_tags__`\"\n      role=\"status\"\n      :aria-live=\"focused ? 'assertive' : 'off'\"\n      aria-atomic=\"true\"\n      class=\"visually-hidden\"\n    >\n      ({{ tagRemovedLabel }}) {{ lastRemovedTag }}\n    </div>\n\n    <slot v-bind=\"slotAttrs\">\n      <ul\n        :id=\"`${computedId}tag_list__`\"\n        class=\"b-form-tags-list list-unstyled mb-0 d-flex flex-wrap align-items-center\"\n      >\n        <template v-for=\"(tag, index) in tags\" :key=\"index\">\n          <slot\n            name=\"tag\"\n            v-bind=\"{tag, tagClass, tagVariant, tagPills: tagPillsBoolean, removeTag}\"\n          >\n            <BFormTag\n              :key=\"tag\"\n              :class=\"tagClass\"\n              tag=\"li\"\n              :variant=\"tagVariant\"\n              :pill=\"tagPills\"\n              @remove=\"removeTag\"\n              >{{ tag }}</BFormTag\n            >\n          </slot>\n        </template>\n        <li\n          role=\"none\"\n          aria-live=\"off\"\n          class=\"b-from-tags-field flex-grow-1\"\n          :aria-controls=\"`${computedId}tag_list__`\"\n        >\n          <div role=\"group\" class=\"d-flex\">\n            <input\n              :id=\"_inputId\"\n              ref=\"input\"\n              :disabled=\"disabledBoolean\"\n              :value=\"inputValue\"\n              :type=\"inputType\"\n              :placeholder=\"placeholder\"\n              class=\"b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0\"\n              style=\"outline: currentcolor none 0px; min-width: 5rem\"\n              v-bind=\"inputAttrs\"\n              :form=\"form\"\n              :required=\"requiredBoolean || undefined\"\n              :aria-required=\"requiredBoolean || undefined\"\n              @input=\"onInput\"\n              @change=\"onChange\"\n              @keydown=\"onKeydown\"\n              @focus=\"onFocus\"\n              @blur=\"onBlur\"\n            />\n            <button\n              v-if=\"disableAddButton\"\n              type=\"button\"\n              class=\"btn b-form-tags-button py-0\"\n              :class=\"[\n                inputClass,\n                {\n                  [`btn-${addButtonVariant}`]: addButtonVariant !== null,\n                  'disabled invisible': inputValue.length === 0,\n                },\n              ]\"\n              style=\"font-size: 90%\"\n              :disabled=\"disabledBoolean || inputValue.length === 0 || isLimitReached\"\n              @click=\"addTag(inputValue)\"\n            >\n              <slot name=\"add-button-text\">{{ addButtonText }}</slot>\n            </button>\n          </div>\n        </li>\n      </ul>\n      <div aria-live=\"polite\" aria-atomic=\"true\">\n        <div v-if=\"isInvalid\" class=\"d-block invalid-feedback\">\n          {{ invalidTagText }}: {{ inputValue }}\n        </div>\n        <small v-if=\"isDuplicate\" class=\"form-text text-muted\"\n          >{{ duplicateTagText }}: {{ inputValue }}</small\n        >\n        <small v-if=\"tags.length === limit\" class=\"form-text text-muted\">Tag limit reached</small>\n      </div>\n    </slot>\n    <template v-if=\"name\">\n      <input v-for=\"(tag, index) in tags\" :key=\"index\" type=\"hidden\" :name=\"name\" :value=\"tag\" />\n    </template>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, ref, watch} from 'vue'\nimport BFormTag from './BFormTag.vue'\nimport {useBooleanish, useId, useStateClass} from '../../composables'\nimport type {\n  Booleanish,\n  ButtonVariant,\n  ClassValue,\n  ColorVariant,\n  InputType,\n  Size,\n} from '../../types'\nimport {useFocus, useVModel} from '@vueuse/core'\nimport {escapeRegExpChars} from '../../utils'\n\nconst props = withDefaults(\n  defineProps<{\n    addButtonText?: string\n    addButtonVariant?: ButtonVariant | null\n    addOnChange?: Booleanish\n    autofocus?: Booleanish\n    disabled?: Booleanish\n    duplicateTagText?: string\n    inputAttrs?: Record<string, unknown>\n    inputClass?: ClassValue\n    inputId?: string\n    inputType?: InputType\n    invalidTagText?: string\n    form?: string\n    limit?: number\n    limitTagsText?: string\n    modelValue?: string[]\n    name?: string\n    noAddOnEnter?: Booleanish\n    noOuterFocus?: Booleanish\n    noTagRemove?: Booleanish\n    placeholder?: string\n    removeOnDelete?: Booleanish\n    required?: Booleanish\n    separator?: string | string[]\n    state?: Booleanish | null\n    size?: Size\n    tagClass?: ClassValue\n    tagPills?: Booleanish\n    tagRemoveLabel?: string\n    tagRemovedLabel?: string\n    tagValidator?: (t: string) => boolean\n    tagVariant?: ColorVariant | null\n  }>(),\n  {\n    inputAttrs: undefined,\n    tagRemoveLabel: undefined,\n    tagClass: undefined,\n    separator: undefined,\n    size: 'md',\n    name: undefined,\n    limit: undefined,\n    form: undefined,\n    inputClass: undefined,\n    inputId: undefined,\n    addButtonText: 'Add',\n    addButtonVariant: 'outline-secondary',\n    addOnChange: false,\n    autofocus: false,\n    disabled: false,\n    duplicateTagText: 'Duplicate tag(s)',\n    inputType: 'text',\n    invalidTagText: 'Invalid tag(s)',\n    limitTagsText: 'Tag limit reached',\n    modelValue: () => [],\n    noAddOnEnter: false,\n    noOuterFocus: false,\n    noTagRemove: false,\n    placeholder: 'Add tag...',\n    removeOnDelete: false,\n    required: false,\n    state: null,\n    tagPills: false,\n    tagRemovedLabel: 'Tag removed',\n    tagValidator: () => true,\n    tagVariant: 'secondary',\n  }\n)\n\nconst emit = defineEmits<{\n  'update:modelValue': [value: string[]]\n  'input': [value: string[]]\n  'tag-state': [...args: string[][]]\n  'focus': [value: FocusEvent]\n  'focusin': [value: FocusEvent]\n  'focusout': [value: FocusEvent]\n  'blur': [value: FocusEvent]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'default'?: (props: typeof slotAttrs.value) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'add-button-text'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'tag'?: (props: {\n    tag: string\n    tagClass: ClassValue\n    tagVariant: ColorVariant | null\n    tagPills: boolean\n    removeTag: (tag?: string) => void\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  }) => any\n}>()\n\nconst modelValue = useVModel(props, 'modelValue', emit)\n\nconst computedId = useId()\n\nconst addOnChangeBoolean = useBooleanish(() => props.addOnChange)\nconst autofocusBoolean = useBooleanish(() => props.autofocus)\nconst disabledBoolean = useBooleanish(() => props.disabled)\nconst noAddOnEnterBoolean = useBooleanish(() => props.noAddOnEnter)\nconst noOuterFocusBoolean = useBooleanish(() => props.noOuterFocus)\nconst noTagRemoveBoolean = useBooleanish(() => props.noTagRemove)\nconst removeOnDeleteBoolean = useBooleanish(() => props.removeOnDelete)\nconst requiredBoolean = useBooleanish(() => props.required)\nconst stateBoolean = useBooleanish(() => props.state)\nconst tagPillsBoolean = useBooleanish(() => props.tagPills)\n\nconst stateClass = useStateClass(stateBoolean)\n\nconst input = ref<HTMLInputElement | null>(null)\n\nconst {focused} = useFocus(input, {\n  initialValue: autofocusBoolean.value,\n})\n\nconst _inputId = computed<string>(() => props.inputId || `${computedId.value}input__`)\nconst tags = ref<string[]>(modelValue.value)\nconst inputValue = ref<string>('')\nconst shouldRemoveOnDelete = ref<boolean>(modelValue.value.length > 0)\nconst lastRemovedTag = ref<string>('')\nconst validTags = ref<string[]>([])\nconst invalidTags = ref<string[]>([])\nconst duplicateTags = ref<string[]>([])\n\nconst computedClasses = computed(() => [\n  stateClass.value,\n  {\n    [`form-control-${props.size}`]: props.size !== 'md',\n    disabled: disabledBoolean.value,\n    focus: focused.value,\n  },\n])\n\nconst isDuplicate = computed<boolean>(() => tags.value.includes(inputValue.value))\n\nconst isInvalid = computed<boolean>(() =>\n  inputValue.value === '' ? false : !props.tagValidator(inputValue.value)\n)\nconst isLimitReached = computed<boolean>(() => tags.value.length === props.limit)\n\nconst disableAddButton = computed<boolean>(() => !isInvalid.value && !isDuplicate.value)\n\nconst slotAttrs = computed(() => ({\n  addButtonText: props.addButtonText,\n  addButtonVariant: props.addButtonVariant,\n  addTag,\n  disableAddButton: disableAddButton.value,\n  disabled: disabledBoolean.value,\n  duplicateTagText: props.duplicateTagText,\n  duplicateTags: duplicateTags.value,\n  form: props.form,\n  inputAttrs: {\n    ...props.inputAttrs,\n    disabled: disabledBoolean.value,\n    form: props.form,\n    id: _inputId,\n    value: inputValue,\n  },\n  inputHandlers: {\n    input: onInput,\n    keydown: onKeydown,\n    change: onChange,\n  },\n  inputId: _inputId,\n  inputType: props.inputType,\n  invalidTagText: props.invalidTagText,\n  invalidTags: invalidTags.value,\n  isDuplicate: isDuplicate.value,\n  isInvalid: isInvalid.value,\n  isLimitReached: isLimitReached.value,\n  limitTagsText: props.limitTagsText,\n  limit: props.limit,\n  noTagRemove: noTagRemoveBoolean.value,\n  placeholder: props.placeholder,\n  removeTag,\n  required: requiredBoolean.value,\n  separator: props.separator,\n  size: props.size,\n  state: stateBoolean.value,\n  tagClass: props.tagClass,\n  tagPills: tagPillsBoolean.value,\n  tagRemoveLabel: props.tagRemoveLabel,\n  tagVariant: props.tagVariant,\n  tags: tags.value,\n}))\n\nwatch(modelValue, (newVal) => {\n  tags.value = newVal\n})\n\nconst onFocusin = (e: FocusEvent): void => {\n  if (disabledBoolean.value) {\n    const target = e.target as HTMLDivElement\n    target.blur()\n    return\n  }\n\n  emit('focusin', e)\n}\n\nconst onFocus = (e: FocusEvent): void => {\n  if (disabledBoolean.value || noOuterFocusBoolean.value) {\n    return\n  }\n\n  focused.value = true\n  emit('focus', e)\n}\n\nconst onBlur = (e: FocusEvent): void => {\n  focused.value = false\n  emit('blur', e)\n}\n\nconst onInput = (e: Event | string): void => {\n  const value = typeof e === 'string' ? e : (e.target as HTMLInputElement).value\n\n  shouldRemoveOnDelete.value = false\n\n  if (props.separator?.includes(value.charAt(0)) && value.length > 0) {\n    if (input.value) {\n      input.value.value = ''\n    }\n    return\n  }\n\n  inputValue.value = value\n\n  if (props.separator?.includes(value.charAt(value.length - 1))) {\n    addTag(value.slice(0, value.length - 1))\n    return\n  }\n\n  validTags.value = props.tagValidator(value) && !isDuplicate.value ? [value] : []\n  invalidTags.value = props.tagValidator(value) ? [] : [value]\n  duplicateTags.value = isDuplicate.value ? [value] : []\n\n  emit('tag-state', validTags.value, invalidTags.value, duplicateTags.value)\n}\n\nconst onChange = (e: Event): void => {\n  if (addOnChangeBoolean.value) {\n    onInput(e)\n\n    if (!isDuplicate.value) {\n      addTag(inputValue.value)\n    }\n  }\n}\n\nconst onKeydown = (e: KeyboardEvent): void => {\n  if (e.key === 'Enter' && !noAddOnEnterBoolean.value) {\n    addTag(inputValue.value)\n    return\n  }\n\n  if (\n    (e.key === 'Backspace' || e.key === 'Delete') &&\n    removeOnDeleteBoolean.value &&\n    inputValue.value === '' &&\n    shouldRemoveOnDelete.value &&\n    tags.value.length > 0\n  ) {\n    removeTag(tags.value[tags.value.length - 1])\n  } else {\n    shouldRemoveOnDelete.value = true\n  }\n}\n\nconst separator = computed(() => {\n  if (!props.separator) {\n    return\n  }\n\n  return typeof props.separator === 'string' ? props.separator : props.separator.join('')\n})\n\nconst separatorRegExp = computed(() => {\n  if (!separator.value) {\n    return\n  }\n\n  return new RegExp(`[${escapeRegExpChars(separator.value)}]+`)\n})\n\nconst addTag = (tag?: string): void => {\n  tag = (tag ?? inputValue.value).trim()\n\n  const newTags = separatorRegExp.value\n    ? tag.split(separatorRegExp.value).map((t) => t.trim())\n    : [tag]\n  const validTags: string[] = []\n\n  for (const newTag of newTags) {\n    if (newTag === '' || isDuplicate.value || !props.tagValidator(newTag)) {\n      continue\n    }\n\n    if (props.limit && isLimitReached.value) {\n      break\n    }\n\n    validTags.push(newTag)\n  }\n\n  const newValue = [...modelValue.value, ...validTags]\n  inputValue.value = ''\n  shouldRemoveOnDelete.value = true\n  modelValue.value = newValue\n  emit('input', newValue)\n  focused.value = true\n}\n\nconst removeTag = (tag?: string): void => {\n  const tagIndex = tags.value.indexOf(tag?.toString() ?? '')\n  lastRemovedTag.value = tags.value.splice(tagIndex, 1).toString()\n  modelValue.value = tags.value\n}\n\n// TODO these focus/blur events aren't quite in line with use useFormInput implementation. Perhaps we should bring them together?\ndefineExpose({\n  focus: () => {\n    focused.value = true\n  },\n  blur: () => {\n    focused.value = false\n  },\n})\n</script>\n","<template>\n  <textarea\n    :id=\"computedId\"\n    ref=\"input\"\n    :class=\"computedClasses\"\n    :name=\"name || undefined\"\n    :form=\"form || undefined\"\n    :disabled=\"disabledBoolean\"\n    :placeholder=\"placeholder\"\n    :required=\"requiredBoolean || undefined\"\n    :autocomplete=\"autocomplete || undefined\"\n    :readonly=\"readonlyBoolean || plaintextBoolean\"\n    :aria-required=\"required || undefined\"\n    :aria-invalid=\"computedAriaInvalid\"\n    :rows=\"rows\"\n    :style=\"computedStyles\"\n    :wrap=\"wrap || undefined\"\n    @input=\"onInput($event)\"\n    @change=\"onChange($event)\"\n    @blur=\"onBlur($event)\"\n  />\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish} from '../../types'\nimport {computed, type CSSProperties} from 'vue'\nimport {useBooleanish, useFormInput, useStateClass} from '../../composables'\nimport type {CommonInputProps} from '../../composables/useFormInput'\n\nconst props = withDefaults(\n  defineProps<\n    {\n      noResize?: Booleanish\n      rows?: string | number\n      wrap?: string\n    } & CommonInputProps\n  >(),\n  {\n    noResize: false,\n    rows: 2,\n    wrap: 'soft',\n    // CommonInputProps\n    ariaInvalid: undefined,\n    autocomplete: undefined,\n    autofocus: false,\n    disabled: false,\n    form: undefined,\n    formatter: undefined,\n    id: undefined,\n    lazy: false,\n    lazyFormatter: false,\n    list: undefined,\n    modelValue: '',\n    name: undefined,\n    number: false,\n    placeholder: undefined,\n    plaintext: false,\n    readonly: false,\n    required: false,\n    size: undefined,\n    state: null,\n    trim: false,\n  }\n)\n\nconst emit = defineEmits<{\n  'update:modelValue': [val: any]\n  'change': [val: any]\n  'blur': [val: any]\n  'input': [val: any]\n}>()\n\nconst {input, computedId, computedAriaInvalid, onInput, onChange, onBlur, focus, blur} =\n  useFormInput(props, emit)\n\nconst disabledBoolean = useBooleanish(() => props.disabled)\nconst requiredBoolean = useBooleanish(() => props.required)\nconst readonlyBoolean = useBooleanish(() => props.readonly)\nconst plaintextBoolean = useBooleanish(() => props.plaintext)\nconst noResizeBoolean = useBooleanish(() => props.noResize)\nconst stateBoolean = useBooleanish(() => props.state)\n\nconst stateClass = useStateClass(stateBoolean)\n\nconst computedClasses = computed(() => [\n  stateClass.value,\n  {\n    'form-control': !props.plaintext,\n    'form-control-plaintext': props.plaintext,\n    [`form-control-${props.size}`]: !!props.size,\n  },\n])\n\nconst computedStyles = computed<CSSProperties>(() => ({\n  resize: noResizeBoolean.value ? 'none' : undefined,\n}))\n\ndefineExpose({\n  focus,\n  blur,\n})\n</script>\n","<template>\n  <component :is=\"tag\" :id=\"id\" class=\"input-group\" :class=\"computedClasses\" role=\"group\">\n    <slot name=\"prepend\">\n      <span v-if=\"hasPrepend\" class=\"input-group-text\">\n        <!-- eslint-disable-next-line vue/no-v-html -->\n        <span v-if=\"!!prependHtml\" v-html=\"prependHtml\" />\n        <span v-else>{{ prepend }}</span>\n      </span>\n    </slot>\n    <slot />\n    <slot name=\"append\">\n      <span v-if=\"hasAppend\" class=\"input-group-text\">\n        <!-- eslint-disable-next-line vue/no-v-html -->\n        <span v-if=\"!!appendHtml\" v-html=\"appendHtml\" />\n        <span v-else>{{ append }}</span>\n      </span>\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport type {Size} from '../../types'\nimport {computed} from 'vue'\n\nconst props = withDefaults(\n  defineProps<{\n    append?: string\n    appendHtml?: string\n    id?: string\n    prepend?: string\n    prependHtml?: string\n    size?: Size\n    tag?: string\n  }>(),\n  {\n    append: undefined,\n    appendHtml: undefined,\n    id: undefined,\n    prepend: undefined,\n    prependHtml: undefined,\n    size: 'md',\n    tag: 'div',\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  append?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  prepend?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => ({\n  [`input-group-${props.size}`]: props.size !== 'md',\n}))\n\nconst hasAppend = computed<boolean>(() => !!props.append || !!props.appendHtml)\nconst hasPrepend = computed<boolean>(() => !!props.prepend || !!props.prependHtml)\n</script>\n","<template>\n  <BInputGroupText v-if=\"isTextBoolean\">\n    <slot />\n  </BInputGroupText>\n  <slot v-else />\n</template>\n\n<script setup lang=\"ts\">\nimport {useBooleanish} from '../../composables'\nimport type {Booleanish} from '../../types'\nimport BInputGroupText from './BInputGroupText.vue'\n\nconst props = withDefaults(\n  defineProps<{\n    isText?: Booleanish\n  }>(),\n  {\n    isText: false,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst isTextBoolean = useBooleanish(() => props.isText)\n</script>\n","<template>\n  <component :is=\"computedTag\" class=\"list-group\" :class=\"computedClasses\">\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, provide} from 'vue'\nimport {listGroupInjectionKey} from '../../utils'\nimport type {Booleanish, Breakpoint} from '../../types'\nimport {useBooleanish} from '../../composables'\n\nconst props = withDefaults(\n  defineProps<{\n    flush?: Booleanish\n    horizontal?: boolean | Breakpoint\n    numbered?: Booleanish\n    tag?: string\n  }>(),\n  {\n    flush: false,\n    horizontal: false,\n    numbered: false,\n    tag: 'div',\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst flushBoolean = useBooleanish(() => props.flush)\nconst numberedBoolean = useBooleanish(() => props.numbered)\n\nconst computedClasses = computed(() => {\n  const horizontal = flushBoolean.value ? false : props.horizontal\n  return {\n    'list-group-flush': flushBoolean.value,\n    'list-group-horizontal': horizontal === true,\n    [`list-group-horizontal-${horizontal}`]: typeof horizontal === 'string',\n    'list-group-numbered': numberedBoolean.value,\n  }\n})\n\nconst computedTag = computed<string>(() => (numberedBoolean.value === true ? 'ol' : props.tag))\n\nprovide(listGroupInjectionKey, {\n  numbered: numberedBoolean,\n})\n</script>\n","<template>\n  <component\n    :is=\"tagComputed\"\n    class=\"list-group-item\"\n    :class=\"computedClasses\"\n    :aria-current=\"activeBoolean ? true : undefined\"\n    :aria-disabled=\"disabledBoolean ? true : undefined\"\n    :target=\"link ? target : undefined\"\n    :href=\"!buttonBoolean ? href : undefined\"\n    :to=\"!buttonBoolean ? to : undefined\"\n    v-bind=\"computedAttrs\"\n  >\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, inject, useAttrs} from 'vue'\nimport type {RouteLocationRaw} from 'vue-router'\nimport type {Booleanish, ColorVariant, LinkTarget} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport BLink from '../BLink/BLink.vue'\nimport {listGroupInjectionKey} from '../../utils'\n\nconst props = withDefaults(\n  defineProps<{\n    action?: Booleanish\n    active?: Booleanish\n    // activeClass?: string\n    // append?: Booleanish\n    button?: Booleanish\n    disabled?: Booleanish\n    href?: string\n    // noPrefetch?: Booleanish\n    // prefetch?: Booleanish\n    // rel?: String\n    // replace?: Booleanish\n    // routerComponentName?: String\n    tag?: string\n    target?: LinkTarget\n    to?: RouteLocationRaw\n    variant?: ColorVariant | null\n  }>(),\n  {\n    to: undefined,\n    variant: null,\n    href: undefined,\n    action: false,\n    active: false,\n    button: false,\n    disabled: false,\n    tag: 'div',\n    target: '_self',\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst attrs = useAttrs()\n\nconst parentData = inject(listGroupInjectionKey, null)\n\nconst actionBoolean = useBooleanish(() => props.action)\nconst activeBoolean = useBooleanish(() => props.active)\nconst buttonBoolean = useBooleanish(() => props.button)\nconst disabledBoolean = useBooleanish(() => props.disabled)\n\nconst link = computed<boolean>(() => !buttonBoolean.value && (!!props.href || !!props.to))\n\nconst tagComputed = computed<string | typeof BLink>(() =>\n  parentData?.numbered.value\n    ? 'li'\n    : buttonBoolean.value\n    ? 'button'\n    : !link.value\n    ? props.tag\n    : BLink\n)\n\nconst isAction = computed(\n  () =>\n    actionBoolean.value ||\n    link.value ||\n    buttonBoolean.value ||\n    ['a', 'router-link', 'button', 'b-link'].includes(props.tag)\n)\n\nconst computedClasses = computed(() => ({\n  [`list-group-item-${props.variant}`]: props.variant !== null,\n  'list-group-item-action': isAction.value,\n  'active': activeBoolean.value,\n  'disabled': disabledBoolean.value,\n}))\n\nconst computedAttrs = computed(() => {\n  const localAttrs = {} as {type?: string; disabled?: boolean}\n  if (buttonBoolean.value) {\n    if (!attrs || !attrs.type) {\n      // Add a type for button is one not provided in passed attributes\n      localAttrs.type = 'button'\n    }\n    if (disabledBoolean.value) {\n      // Set disabled attribute if button and disabled\n      localAttrs.disabled = true\n    }\n  }\n  return localAttrs\n})\n</script>\n","<template>\n  <Teleport :to=\"teleportTo\" :disabled=\"teleportDisabledBoolean\">\n    <BTransition\n      :no-fade=\"true\"\n      :trans-props=\"{enterToClass: 'show'}\"\n      @before-enter=\"onBeforeEnter\"\n      @after-enter=\"onAfterEnter\"\n      @leave=\"onLeave\"\n      @after-leave=\"onAfterLeave\"\n    >\n      <div\n        v-show=\"modelValueBoolean\"\n        :id=\"computedId\"\n        ref=\"element\"\n        class=\"modal\"\n        :class=\"modalClasses\"\n        role=\"dialog\"\n        :aria-labelledby=\"`${computedId}-label`\"\n        :aria-describedby=\"`${computedId}-body`\"\n        tabindex=\"-1\"\n        v-bind=\"$attrs\"\n        @keyup.esc=\"hide('esc')\"\n      >\n        <div class=\"modal-dialog\" :class=\"modalDialogClasses\">\n          <div v-if=\"lazyShowing\" class=\"modal-content\" :class=\"contentClass\">\n            <div v-if=\"!hideHeaderBoolean\" class=\"modal-header\" :class=\"headerClasses\">\n              <slot name=\"header\">\n                <component\n                  :is=\"titleTag\"\n                  :id=\"`${computedId}-label`\"\n                  class=\"modal-title\"\n                  :class=\"titleClasses\"\n                >\n                  <slot name=\"title\">\n                    {{ title }}\n                  </slot>\n                </component>\n                <template v-if=\"!hideHeaderCloseBoolean\">\n                  <button v-if=\"hasHeaderCloseSlot\" type=\"button\" @click=\"hide('close')\">\n                    <slot name=\"header-close\" />\n                  </button>\n                  <BCloseButton\n                    v-else\n                    ref=\"closeButton\"\n                    :aria-label=\"headerCloseLabel\"\n                    :white=\"headerCloseWhite\"\n                    @click=\"hide('close')\"\n                  />\n                </template>\n              </slot>\n            </div>\n            <div :id=\"`${computedId}-body`\" class=\"modal-body\" :class=\"bodyClasses\">\n              <slot />\n            </div>\n            <div v-if=\"!hideFooterBoolean\" class=\"modal-footer\" :class=\"footerClasses\">\n              <slot name=\"footer\">\n                <slot name=\"cancel\">\n                  <BButton\n                    v-if=\"!okOnlyBoolean\"\n                    ref=\"cancelButton\"\n                    :disabled=\"disableCancel\"\n                    :size=\"buttonSize\"\n                    :variant=\"cancelVariant\"\n                    @click=\"hide('cancel')\"\n                  >\n                    {{ cancelTitle }}\n                  </BButton>\n                </slot>\n                <slot name=\"ok\">\n                  <BButton\n                    ref=\"okButton\"\n                    :disabled=\"disableOk\"\n                    :size=\"buttonSize\"\n                    :variant=\"okVariant\"\n                    @click=\"hide('ok')\"\n                  >\n                    {{ okTitle }}\n                  </BButton>\n                </slot>\n              </slot>\n            </div>\n          </div>\n        </div>\n        <slot v-if=\"!hideBackdropBoolean\" name=\"backdrop\">\n          <div class=\"modal-backdrop fade show\" @click=\"hide('backdrop')\" />\n        </slot>\n      </div>\n    </BTransition>\n  </Teleport>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, ref, type RendererElement, useSlots} from 'vue'\nimport {useBooleanish, useId, useModalManager, useSafeScrollLock} from '../composables'\nimport {useEventListener, useFocus, useVModel} from '@vueuse/core'\nimport type {Booleanish, ButtonVariant, ClassValue, ColorVariant, Size} from '../types'\nimport {BvTriggerableEvent, isEmptySlot} from '../utils'\nimport BButton from './BButton/BButton.vue'\nimport BCloseButton from './BButton/BCloseButton.vue'\nimport BTransition from './BTransition/BTransition.vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\n// aria\n// autofocus\n// close on escape when autofocus\n\n// Note, attempt to return focus to item that openned the modal after close\n// Implement auto focus props like autoFocusButton\n\nconst props = withDefaults(\n  defineProps<{\n    bodyBgVariant?: ColorVariant | null\n    bodyClass?: ClassValue\n    bodyTextVariant?: ColorVariant | null\n    busy?: Booleanish\n    lazy?: Booleanish\n    buttonSize?: Size\n    cancelDisabled?: Booleanish\n    cancelTitle?: string\n    cancelVariant?: ButtonVariant | null\n    centered?: Booleanish\n    contentClass?: ClassValue\n    dialogClass?: ClassValue\n    footerBgVariant?: ColorVariant | null\n    footerBorderVariant?: ColorVariant | null\n    footerClass?: ClassValue\n    footerTextVariant?: ColorVariant | null\n    fullscreen?: boolean | string\n    headerBgVariant?: ColorVariant | null\n    headerBorderVariant?: ColorVariant | null\n    headerClass?: ClassValue\n    headerCloseLabel?: string\n    headerCloseWhite?: Booleanish\n    headerTextVariant?: ColorVariant | null\n    hideBackdrop?: Booleanish\n    hideFooter?: Booleanish\n    hideHeader?: Booleanish\n    hideHeaderClose?: Booleanish\n    id?: string\n    modalClass?: ClassValue\n    modelValue?: Booleanish\n    noCloseOnBackdrop?: Booleanish\n    noCloseOnEsc?: Booleanish\n    noFade?: Booleanish\n    autoFocus?: Booleanish\n    okDisabled?: Booleanish\n    okOnly?: Booleanish\n    okTitle?: string\n    okVariant?: ButtonVariant | null\n    scrollable?: Booleanish\n    show?: Booleanish\n    size?: Size | 'xl'\n    title?: string\n    titleClass?: string\n    titleSrOnly?: Booleanish\n    titleTag?: string\n    autoFocusButton?: 'ok' | 'cancel' | 'close'\n    teleportDisabled?: Booleanish\n    teleportTo?: string | RendererElement | null | undefined\n    bodyScrolling?: Booleanish\n  }>(),\n  {\n    bodyBgVariant: null,\n    bodyClass: undefined,\n    bodyTextVariant: null,\n    contentClass: undefined,\n    headerTextVariant: null,\n    dialogClass: undefined,\n    headerBgVariant: null,\n    headerBorderVariant: null,\n    headerClass: undefined,\n    footerBgVariant: null,\n    footerBorderVariant: null,\n    footerClass: undefined,\n    footerTextVariant: null,\n    autoFocusButton: undefined,\n    titleClass: undefined,\n    title: undefined,\n    size: 'md',\n    modalClass: undefined,\n    id: undefined,\n    busy: false,\n    lazy: false,\n    buttonSize: 'md',\n    cancelDisabled: false,\n    cancelTitle: 'Cancel',\n    cancelVariant: 'secondary',\n    centered: false,\n    fullscreen: false,\n    headerCloseLabel: 'Close',\n    headerCloseWhite: false,\n    hideBackdrop: false,\n    hideFooter: false,\n    hideHeader: false,\n    hideHeaderClose: false,\n    modelValue: false,\n    noCloseOnBackdrop: false,\n    noCloseOnEsc: false,\n    noFade: false,\n    autoFocus: true,\n    okDisabled: false,\n    okOnly: false,\n    okTitle: 'Ok',\n    okVariant: 'primary',\n    scrollable: false,\n    show: false,\n    titleSrOnly: false,\n    titleTag: 'h5',\n    teleportDisabled: false,\n    teleportTo: 'body',\n    bodyScrolling: false,\n  }\n)\n\nconst emit = defineEmits<{\n  'update:modelValue': [value: boolean]\n  'show': [value: BvTriggerableEvent]\n  'shown': [value: BvTriggerableEvent]\n  'hide': [value: BvTriggerableEvent]\n  'hidden': [value: BvTriggerableEvent]\n  'hide-prevented': []\n  'show-prevented': []\n  'ok': [value: BvTriggerableEvent]\n  'cancel': [value: BvTriggerableEvent]\n  'close': [value: BvTriggerableEvent]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'header'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'title'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'header-close'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'default'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'footer'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'cancel'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'ok'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'backdrop'?: (props: Record<string, never>) => any\n}>()\n\nconst slots = useSlots()\n\nconst computedId = useId(() => props.id, 'modal')\n\nconst modelValue = useVModel(props, 'modelValue', emit)\n\nconst busyBoolean = useBooleanish(() => props.busy)\nconst lazyBoolean = useBooleanish(() => props.lazy)\nconst cancelDisabledBoolean = useBooleanish(() => props.cancelDisabled)\nconst centeredBoolean = useBooleanish(() => props.centered)\nconst hideBackdropBoolean = useBooleanish(() => props.hideBackdrop)\nconst hideFooterBoolean = useBooleanish(() => props.hideFooter)\nconst hideHeaderBoolean = useBooleanish(() => props.hideHeader)\nconst hideHeaderCloseBoolean = useBooleanish(() => props.hideHeaderClose)\nconst modelValueBoolean = useBooleanish(modelValue)\nconst noCloseOnBackdropBoolean = useBooleanish(() => props.noCloseOnBackdrop)\nconst noCloseOnEscBoolean = useBooleanish(() => props.noCloseOnEsc)\nconst noFadeBoolean = useBooleanish(() => props.noFade)\nconst autoFocusBoolean = useBooleanish(() => props.autoFocus)\nconst okDisabledBoolean = useBooleanish(() => props.okDisabled)\nconst okOnlyBoolean = useBooleanish(() => props.okOnly)\nconst scrollableBoolean = useBooleanish(() => props.scrollable)\nconst titleSrOnlyBoolean = useBooleanish(() => props.titleSrOnly)\nconst teleportDisabledBoolean = useBooleanish(() => props.teleportDisabled)\nconst bodyScrollingBoolean = useBooleanish(() => props.bodyScrolling)\n\nconst element = ref<HTMLElement | null>(null)\nconst okButton = ref<HTMLElement | null>(null)\nconst cancelButton = ref<HTMLElement | null>(null)\nconst closeButton = ref<HTMLElement | null>(null)\nconst isActive = ref(modelValueBoolean.value)\nconst lazyLoadCompleted = ref(false)\n\nuseSafeScrollLock(modelValueBoolean, bodyScrollingBoolean)\nconst {focused: modalFocus} = useFocus(element, {\n  initialValue: modelValueBoolean.value && props.autoFocusButton === undefined,\n})\nconst {focused: okButtonFocus} = useFocus(okButton, {\n  initialValue: modelValueBoolean.value && props.autoFocusButton === 'ok',\n})\nconst {focused: cancelButtonFocus} = useFocus(cancelButton, {\n  initialValue: modelValueBoolean.value && props.autoFocusButton === 'cancel',\n})\nconst {focused: closeButtonFocus} = useFocus(closeButton, {\n  initialValue: modelValueBoolean.value && props.autoFocusButton === 'close',\n})\n\nconst modalClasses = computed(() => [\n  props.modalClass,\n  {\n    fade: !noFadeBoolean.value,\n    show: isActive.value,\n  },\n])\n\nconst lazyShowing = computed(\n  () =>\n    lazyBoolean.value === false ||\n    (lazyBoolean.value === true && lazyLoadCompleted.value === true) ||\n    (lazyBoolean.value === true && modelValueBoolean.value === true)\n)\n\nconst hasHeaderCloseSlot = computed(() => !isEmptySlot(slots['header-close']))\n\nconst modalDialogClasses = computed(() => [\n  props.dialogClass,\n  {\n    'modal-fullscreen': props.fullscreen === true,\n    [`modal-fullscreen-${props.fullscreen}-down`]: typeof props.fullscreen === 'string',\n    [`modal-${props.size}`]: props.size !== 'md',\n    'modal-dialog-centered': centeredBoolean.value,\n    'modal-dialog-scrollable': scrollableBoolean.value,\n  },\n])\n\nconst bodyClasses = computed(() => [\n  props.bodyClass,\n  {\n    [`bg-${props.bodyBgVariant}`]: props.bodyBgVariant !== null,\n    [`text-${props.bodyTextVariant}`]: props.bodyTextVariant !== null,\n  },\n])\n\nconst headerClasses = computed(() => [\n  props.headerClass,\n  {\n    [`bg-${props.headerBgVariant}`]: props.headerBgVariant !== null,\n    [`border-${props.headerBorderVariant}`]: props.headerBorderVariant !== null,\n    [`text-${props.headerTextVariant}`]: props.headerTextVariant !== null,\n  },\n])\n\nconst footerClasses = computed(() => [\n  props.footerClass,\n  {\n    [`bg-${props.footerBgVariant}`]: props.footerBgVariant !== null,\n    [`border-${props.footerBorderVariant}`]: props.footerBorderVariant !== null,\n    [`text-${props.footerTextVariant}`]: props.footerTextVariant !== null,\n  },\n])\n\nconst titleClasses = computed(() => [\n  props.titleClass,\n  {\n    ['visually-hidden']: titleSrOnlyBoolean.value,\n  },\n])\nconst disableCancel = computed<boolean>(() => cancelDisabledBoolean.value || busyBoolean.value)\nconst disableOk = computed<boolean>(() => okDisabledBoolean.value || busyBoolean.value)\n\nconst buildTriggerableEvent = (\n  type: string,\n  opts: Partial<BvTriggerableEvent> = {}\n): BvTriggerableEvent =>\n  new BvTriggerableEvent(type, {\n    cancelable: false,\n    target: element.value || null,\n    relatedTarget: null,\n    trigger: null,\n    ...opts,\n    componentId: computedId.value,\n  })\n\nconst hide = (trigger = '') => {\n  const event = buildTriggerableEvent('hide', {cancelable: trigger !== '', trigger})\n\n  if (trigger === 'ok') {\n    emit(trigger, event)\n  }\n  if (trigger === 'cancel') {\n    emit(trigger, event)\n  }\n  if (trigger === 'close') {\n    emit(trigger, event)\n  }\n  emit('hide', event)\n\n  if (\n    event.defaultPrevented ||\n    (trigger === 'backdrop' && noCloseOnBackdropBoolean.value) ||\n    (trigger === 'esc' && noCloseOnEscBoolean.value)\n  ) {\n    emit('hide-prevented')\n    return\n  }\n  modelValue.value = false\n}\n\n// TODO: If a show is prevented, it will briefly show the animation. This is a bug\n// I'm not sure how to wait for the event to be determined. Before showing\nconst showFn = () => {\n  const event = buildTriggerableEvent('show', {cancelable: true})\n  emit('show', event)\n  if (event.defaultPrevented) {\n    modelValue.value = false\n    emit('show-prevented')\n    return\n  }\n  modelValue.value = true\n}\n\nconst pickFocusItem = () => {\n  if (autoFocusBoolean.value === false) return\n  props.autoFocusButton === 'ok'\n    ? (okButtonFocus.value = true)\n    : props.autoFocusButton === 'close'\n    ? (closeButtonFocus.value = true)\n    : props.autoFocusButton === 'cancel'\n    ? (cancelButtonFocus.value = true)\n    : (modalFocus.value = true)\n}\n\nconst onBeforeEnter = () => showFn()\nconst onAfterEnter = () => {\n  isActive.value = true\n  pickFocusItem()\n  emit('shown', buildTriggerableEvent('shown'))\n  if (lazyBoolean.value === true) lazyLoadCompleted.value = true\n}\nconst onLeave = () => {\n  isActive.value = false\n}\nconst onAfterLeave = () => {\n  emit('hidden', buildTriggerableEvent('hidden'))\n  if (lazyBoolean.value === true) lazyLoadCompleted.value = false\n}\n\nuseModalManager(isActive)\n\nuseEventListener(element, 'bv-toggle', () => {\n  modelValueBoolean.value ? hide() : showFn()\n})\n\ndefineExpose({\n  hide,\n  show: showFn,\n})\n</script>\n\n<style lang=\"scss\" scoped>\n.modal {\n  display: block;\n}\n.modal-dialog {\n  z-index: 1051;\n}\n</style>\n","<template>\n  <component :is=\"tag\" class=\"nav\" :class=\"computedClasses\">\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport type {AlignmentJustifyContent, Booleanish} from '../../types'\nimport {useAlignment, useBooleanish} from '../../composables'\nimport {computed} from 'vue'\n\nconst props = withDefaults(\n  defineProps<{\n    align?: AlignmentJustifyContent\n    cardHeader?: Booleanish\n    fill?: Booleanish\n    justified?: Booleanish\n    pills?: Booleanish\n    small?: Booleanish\n    tabs?: Booleanish\n    tag?: string\n    vertical?: Booleanish\n    underline?: Booleanish\n  }>(),\n  {\n    align: undefined,\n    cardHeader: false,\n    fill: false,\n    justified: false,\n    pills: false,\n    small: false,\n    tabs: false,\n    tag: 'ul',\n    vertical: false,\n    underline: false,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst cardHeaderBoolean = useBooleanish(() => props.cardHeader)\nconst fillBoolean = useBooleanish(() => props.fill)\nconst justifiedBoolean = useBooleanish(() => props.justified)\nconst pillsBoolean = useBooleanish(() => props.pills)\nconst smallBoolean = useBooleanish(() => props.small)\nconst tabsBoolean = useBooleanish(() => props.tabs)\nconst verticalBoolean = useBooleanish(() => props.vertical)\nconst alignment = useAlignment(() => props.align)\nconst underlineBoolean = useBooleanish(() => props.underline)\n\nconst computedClasses = computed(() => ({\n  'nav-tabs': tabsBoolean.value,\n  'nav-pills': pillsBoolean.value && !tabsBoolean.value,\n  'card-header-tabs': !verticalBoolean.value && cardHeaderBoolean.value && tabsBoolean.value,\n  'card-header-pills':\n    !verticalBoolean.value && cardHeaderBoolean.value && pillsBoolean.value && !tabsBoolean.value,\n  'flex-column': verticalBoolean.value,\n  'nav-fill': !verticalBoolean.value && fillBoolean.value,\n  'nav-justified': !verticalBoolean.value && justifiedBoolean.value,\n  [alignment.value]: !verticalBoolean.value && props.align !== undefined,\n  'small': smallBoolean.value,\n  'nav-underline': underlineBoolean.value,\n}))\n</script>\n","<template>\n  <BForm v-bind=\"computedAttrs\" class=\"d-flex\" @submit.prevent=\"submitted\">\n    <slot />\n  </BForm>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed} from 'vue'\nimport type {Booleanish} from '../../types'\nimport BForm from '../BForm/BForm.vue'\n\nconst props = withDefaults(\n  defineProps<{\n    role?: string\n    id?: string // Extend BFormProps\n    floating?: Booleanish\n    novalidate?: Booleanish\n    validated?: Booleanish\n  }>(),\n  {\n    role: undefined,\n    id: undefined,\n    floating: false,\n    novalidate: false,\n    validated: false,\n  }\n)\n\nconst emit = defineEmits<{\n  submit: [value: Event]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedAttrs = computed(() => ({\n  floating: props.floating,\n  role: props.role,\n  id: props.id,\n  novalidate: props.novalidate,\n  validated: props.validated,\n}))\n\nconst submitted = (e: Event): void => emit('submit', e)\n</script>\n","<template>\n  <li class=\"nav-item\">\n    <BLink\n      class=\"nav-link\"\n      :class=\"linkClasses\"\n      v-bind=\"{...linkProps, ...linkAttrs}\"\n      active-class=\"active\"\n      :tabindex=\"disabledBoolean ? -1 : undefined\"\n      :aria-disabled=\"disabledBoolean ? true : undefined\"\n    >\n      <slot />\n    </BLink>\n  </li>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed} from 'vue'\nimport BLink from '../BLink/BLink.vue'\nimport {useBooleanish} from '../../composables'\nimport type {BLinkProps} from '../../types/BLinkProps'\nimport {pluckProps} from '../../utils'\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst props = withDefaults(\n  defineProps<\n    {\n      linkClasses?: string\n      linkAttrs?: Record<string, unknown>\n    } & Omit<BLinkProps, 'event' | 'routerTag'>\n  >(),\n  {\n    linkClasses: undefined,\n    // Link props\n    active: undefined,\n    activeClass: 'router-link-active',\n    append: false,\n    linkAttrs: undefined,\n    disabled: false,\n    href: undefined,\n    // noPrefetch: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    // prefetch: {type: [Boolean, String] as PropType<Booleanish>, default: null},\n    rel: undefined,\n    replace: false,\n    routerComponentName: 'router-link',\n    target: '_self',\n    to: undefined,\n    variant: undefined,\n    opacity: undefined,\n    opacityHover: undefined,\n    underlineVariant: null,\n    underlineOffset: undefined,\n    underlineOffsetHover: undefined,\n    underlineOpacity: undefined,\n    underlineOpacityHover: undefined,\n    icon: false,\n    // End link props\n  }\n)\n\nconst disabledBoolean = useBooleanish(() => props.disabled)\n\nconst linkProps = computed(() =>\n  pluckProps(props, {\n    active: true,\n    activeClass: true,\n    append: true,\n    disabled: true,\n    href: true,\n    icon: true,\n    opacity: true,\n    opacityHover: true,\n    rel: true,\n    replace: true,\n    routerComponentName: true,\n    target: true,\n    to: true,\n    underlineOffset: true,\n    underlineOffsetHover: true,\n    underlineOpacity: true,\n    underlineOpacityHover: true,\n    underlineVariant: true,\n    variant: true,\n  } satisfies Record<keyof Omit<BLinkProps, 'event' | 'routerTag'>, true>)\n)\n</script>\n","<template>\n  <li class=\"nav-item dropdown\">\n    <BDropdown v-model=\"dropdownValue\" v-bind=\"usableProps\" is-nav>\n      <template #button-content>\n        <slot name=\"button-content\" />\n      </template>\n      <template #toggle-text>\n        <slot name=\"toggle-text\" />\n      </template>\n      <template #default>\n        <slot />\n      </template>\n    </BDropdown>\n  </li>\n</template>\n\n<script setup lang=\"ts\">\nimport type {Middleware, Strategy} from '@floating-ui/vue'\nimport {useVModel} from '@vueuse/core'\nimport {computed} from 'vue'\nimport {useBooleanish} from '../../composables'\nimport type {Booleanish, ButtonVariant, ClassValue, Size} from '../../types'\nimport {omit} from '../../utils'\nimport BDropdown from '../BDropdown/BDropdown.vue'\n\n// TODO see how this works in a b-collapse navbar ie https://bootstrap-vue.org/docs/components/navbar first example\nconst props = withDefaults(\n  defineProps<{\n    id?: string\n    text?: string\n    toggleClass?: ClassValue\n    size?: Size\n    offset?: string\n    autoClose?: boolean | 'inside' | 'outside'\n    dark?: Booleanish\n    splitVariant?: ButtonVariant | null\n    noCaret?: Booleanish\n    variant?: ButtonVariant | null\n    modelValue?: Booleanish\n    lazy?: Booleanish\n    strategy?: Strategy\n    floatingMiddleware?: Middleware[]\n    noFlip?: Booleanish\n    noShift?: Booleanish\n    dropup?: Booleanish\n    dropend?: Booleanish\n    dropstart?: Booleanish\n    center?: Booleanish\n    end?: Booleanish\n    menuClass?: ClassValue\n  }>(),\n  {\n    lazy: undefined,\n    strategy: undefined,\n    floatingMiddleware: undefined,\n    noFlip: undefined,\n    noShift: undefined,\n    dropup: undefined,\n    dropend: undefined,\n    dropstart: undefined,\n    center: undefined,\n    end: undefined,\n    menuClass: undefined,\n    id: undefined,\n    text: undefined,\n    toggleClass: undefined,\n    size: 'md',\n    offset: undefined,\n    autoClose: undefined,\n    dark: undefined,\n    splitVariant: undefined,\n    noCaret: undefined,\n    variant: 'link',\n    modelValue: false,\n  }\n)\n\nconst emit = defineEmits<{\n  'update:modelValue': [value: boolean]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'default'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'toggle-text'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'button-content'?: (props: Record<string, never>) => any\n}>()\n\nconst modelValue = useVModel(props, 'modelValue', emit, {passive: true})\n\nconst modelValueBoolean = useBooleanish(modelValue)\n\nconst dropdownValue = computed({\n  get: () => modelValueBoolean.value,\n  set: (value: boolean) => {\n    modelValue.value = value\n  },\n})\nconst usableProps = computed(() => omit(props, ['modelValue'] as const))\n\nconst close = () => {\n  modelValue.value = false\n}\nconst open = () => {\n  modelValue.value = true\n}\nconst toggle = () => {\n  modelValue.value = !modelValueBoolean.value\n}\n\ndefineExpose({\n  close,\n  open,\n  toggle,\n})\n</script>\n","<template>\n  <component :is=\"tag\" class=\"navbar\" :class=\"computedClasses\" :role=\"computedRole\">\n    <div v-if=\"container !== false\" :class=\"containerClass\">\n      <slot />\n    </div>\n    <slot v-else />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, provide, readonly, toRef} from 'vue'\nimport type {Booleanish, Breakpoint, ColorVariant} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {navbarInjectionKey} from '../../utils'\n\nconst props = withDefaults(\n  defineProps<{\n    fixed?: 'top' | 'bottom'\n    print?: Booleanish\n    sticky?: 'top' | 'bottom'\n    tag?: string\n    toggleable?: boolean | Breakpoint\n    dark?: Booleanish\n    variant?: ColorVariant | null\n    container?: 'fluid' | boolean\n  }>(),\n  {\n    variant: null,\n    sticky: undefined,\n    fixed: undefined,\n    print: false,\n    tag: 'nav',\n    dark: false,\n    toggleable: false,\n    container: 'fluid',\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst printBoolean = useBooleanish(() => props.print)\nconst darkBoolean = useBooleanish(() => props.dark)\n\nconst computedRole = computed<undefined | 'navigation'>(() =>\n  props.tag === 'nav' ? undefined : 'navigation'\n)\n\nconst computedNavbarExpand = computed<undefined | string>(() =>\n  typeof props.toggleable === 'string'\n    ? `navbar-expand-${props.toggleable}`\n    : props.toggleable === false\n    ? 'navbar-expand'\n    : undefined\n)\n\nconst containerClass = computed<'container' | 'container-fluid'>(() =>\n  props.container === true ? 'container' : `container-fluid`\n)\n\nconst computedClasses = computed(() => ({\n  'd-print': printBoolean.value,\n  [`sticky-${props.sticky}`]: props.sticky !== undefined,\n  'navbar-dark': darkBoolean.value,\n  [`bg-${props.variant}`]: props.variant !== null,\n  [`fixed-${props.fixed}`]: props.fixed !== undefined,\n  [`${computedNavbarExpand.value}`]: computedNavbarExpand.value !== undefined,\n}))\n\nprovide(navbarInjectionKey, {\n  tag: readonly(toRef(props, 'tag')),\n})\n</script>\n","<template>\n  <component :is=\"computedTag\" class=\"navbar-brand\" v-bind=\"computedLinkProps\">\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {isLink, pluckProps} from '../../utils'\nimport {computed} from 'vue'\nimport BLink from '../BLink/BLink.vue'\nimport type {BLinkProps} from '../../types/BLinkProps'\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst props = withDefaults(\n  defineProps<\n    {\n      tag?: string\n    } & Omit<BLinkProps, 'event' | 'routerTag'>\n  >(),\n  {\n    tag: 'div',\n    // Link props\n    active: undefined,\n    activeClass: 'router-link-active',\n    append: false,\n    disabled: false,\n    href: undefined,\n    // noPrefetch: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    // prefetch: {type: [Boolean, String] as PropType<Booleanish>, default: null},\n    rel: undefined,\n    replace: false,\n    routerComponentName: 'router-link',\n    target: '_self',\n    to: undefined,\n    variant: undefined,\n    opacity: undefined,\n    opacityHover: undefined,\n    underlineVariant: null,\n    underlineOffset: undefined,\n    underlineOffsetHover: undefined,\n    underlineOpacity: undefined,\n    underlineOpacityHover: undefined,\n    icon: false,\n    // End link props\n  }\n)\n\nconst computedLink = computed<boolean>(() => isLink(props))\nconst computedTag = computed<string | typeof BLink>(() => (computedLink.value ? BLink : props.tag))\n\nconst computedLinkProps = computed(() =>\n  computedLink.value\n    ? pluckProps(props, {\n        active: true,\n        activeClass: true,\n        append: true,\n        disabled: true,\n        href: true,\n        rel: true,\n        replace: true,\n        routerComponentName: true,\n        target: true,\n        to: true,\n        variant: true,\n        opacity: true,\n        opacityHover: true,\n        underlineVariant: true,\n        underlineOffset: true,\n        underlineOffsetHover: true,\n        underlineOpacity: true,\n        underlineOpacityHover: true,\n        icon: true,\n      } satisfies Record<keyof Omit<BLinkProps, 'event' | 'routerTag'>, true>)\n    : {}\n)\n</script>\n","<template>\n  <ul class=\"navbar-nav\" :class=\"computedClasses\">\n    <slot />\n  </ul>\n</template>\n\n<script setup lang=\"ts\">\nimport type {AlignmentJustifyContent, Booleanish} from '../../types'\nimport {computed} from 'vue'\nimport {useAlignment, useBooleanish} from '../../composables'\n\nconst props = withDefaults(\n  defineProps<{\n    align?: AlignmentJustifyContent\n    fill?: Booleanish\n    justified?: Booleanish\n    small?: Booleanish\n    tag?: string\n  }>(),\n  {\n    fill: false,\n    align: undefined,\n    justified: false,\n    small: false,\n    tag: 'ul',\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst fillBoolean = useBooleanish(() => props.fill)\nconst justifiedBoolean = useBooleanish(() => props.justified)\nconst smallBoolean = useBooleanish(() => props.small)\nconst alignment = useAlignment(() => props.align)\n\nconst computedClasses = computed(() => ({\n  'nav-fill': fillBoolean.value,\n  'nav-justified': justifiedBoolean.value,\n  [alignment.value]: props.align !== undefined,\n  'small': smallBoolean.value,\n}))\n</script>\n","import type {Directive, DirectiveBinding} from 'vue'\n\nconst setTheme = (el: HTMLElement, value: string): void => el.setAttribute('data-bs-theme', value)\n// TODO see if this works right\nexport default {\n  mounted(el, binding: DirectiveBinding): void {\n    setTheme(el, binding.value)\n  },\n  updated(el, binding: DirectiveBinding): void {\n    setTheme(el, binding.value)\n  },\n} as Directive<HTMLElement>\n","import {RX_HASH, RX_HASH_ID, RX_SPACE_SPLIT} from '../constants/regex'\nimport {getAttr, isTag} from '../utils'\nimport type {Directive, DirectiveBinding} from 'vue'\n\nconst getTargets = (binding: DirectiveBinding<string>, el: HTMLElement) => {\n  const {modifiers, arg, value} = binding\n  // Any modifiers are considered target Ids\n  const targets = Object.keys(modifiers || {})\n\n  // If value is a string, split out individual targets (if space delimited)\n  const localValue = typeof value === 'string' ? value.split(RX_SPACE_SPLIT) : value\n\n  // Support target Id as link href (`href=\"#id\"`)\n  if (isTag(el.tagName, 'a')) {\n    const href = getAttr(el, 'href') || ''\n    if (RX_HASH_ID.test(href)) {\n      targets.push(href.replace(RX_HASH, ''))\n    }\n  }\n\n  // Add Id from `arg` (if provided), and support value\n  // as a single string Id or an array of string Ids\n  // If `value` is not an array or string, then it gets filtered out\n  Array.prototype.concat\n    .apply([], [arg, localValue])\n    .forEach((t) => typeof t === 'string' && targets.push(t))\n\n  // Return only unique and truthy target Ids\n  return targets.filter((t, index, arr) => t && arr.indexOf(t) === index)\n}\n\nconst toggle = (binding: DirectiveBinding<string>, el: HTMLElement) => {\n  const targetIds = getTargets(binding, el)\n  targetIds.forEach((targetId) => {\n    const target = document.getElementById(targetId)\n\n    if (target !== null) {\n      target.dispatchEvent(new Event('bv-toggle'))\n    }\n  })\n  setTimeout(() => checkVisibility(binding, el), 50)\n}\n\nconst checkVisibility = (binding: DirectiveBinding<string>, el: HTMLElement) => {\n  const targetIds = getTargets(binding, el)\n  let visible = false\n  targetIds.forEach((targetId) => {\n    const target = document.getElementById(targetId)\n\n    if (target?.classList.contains('show')) {\n      visible = true\n    }\n    if (target?.classList.contains('closing')) {\n      visible = false\n    }\n  })\n  el.setAttribute('aria-expanded', visible ? 'true' : 'false')\n}\n\nexport interface WithToggle extends HTMLElement {\n  __toggle: () => void\n}\n\nexport default {\n  mounted(el: WithToggle, binding: DirectiveBinding<string>): void {\n    el.__toggle = () => toggle(binding, el)\n    el.addEventListener('click', el.__toggle)\n    checkVisibility(binding, el)\n    el.setAttribute('aria-controls', getTargets(binding, el).join(' '))\n  },\n  unmounted(el: WithToggle): void {\n    el.removeEventListener('click', el.__toggle)\n    el.removeAttribute('aria-controls')\n    el.removeAttribute('aria-expanded')\n  },\n} as Directive<WithToggle>\n","import {type Directive, ref} from 'vue'\nimport {\n  bind,\n  type ElementWithPopper,\n  resolveActiveStatus,\n  resolveContent,\n  resolveDirectiveProps,\n  unbind,\n} from '../utils/floatingUi'\n\nexport default {\n  mounted(el, binding) {\n    const isActive = resolveActiveStatus(binding.value)\n    if (!isActive) return\n\n    const text = resolveContent(binding.value, el)\n\n    if (!text.content && !text.title) return\n\n    el.$__state = ref({\n      ...resolveDirectiveProps(binding, el),\n      ...text,\n    })\n    bind(el, binding)\n  },\n  updated(el, binding) {\n    const isActive = resolveActiveStatus(binding.value)\n    if (!isActive) return\n\n    const text = resolveContent(binding.value, el)\n\n    if (!text.content && !text.title) return\n\n    if (!el.$__state) return\n    el.$__state.value = {\n      ...resolveDirectiveProps(binding, el),\n      ...text,\n    }\n  },\n  beforeUnmount(el) {\n    unbind(el)\n  },\n} satisfies Directive<ElementWithPopper>\n","import {type Directive, ref} from 'vue'\nimport {\n  bind,\n  type ElementWithPopper,\n  resolveActiveStatus,\n  resolveContent,\n  resolveDirectiveProps,\n  unbind,\n} from '../utils/floatingUi'\n\nexport default {\n  mounted(el, binding) {\n    const isActive = resolveActiveStatus(binding.value)\n    if (!isActive) return\n\n    const text = resolveContent(binding.value, el)\n\n    if (!text.content && !text.title) return\n\n    el.$__state = ref({\n      ...resolveDirectiveProps(binding, el),\n      title: text.title ?? text.content ?? '',\n      tooltip: isActive,\n    })\n    bind(el, binding)\n  },\n  updated(el, binding) {\n    const isActive = resolveActiveStatus(binding.value)\n    if (!isActive) return\n\n    const text = resolveContent(binding.value, el)\n\n    if (!text.content && !text.title) return\n\n    if (!el.$__state) return\n    el.$__state.value = {\n      ...resolveDirectiveProps(binding, el),\n      title: text.title ?? text.content ?? '',\n      tooltip: isActive,\n    }\n  },\n  beforeUnmount(el) {\n    unbind(el)\n  },\n} satisfies Directive<ElementWithPopper>\n","<template>\n  <button\n    v-b-toggle=\"!disabledBoolean ? target : undefined\"\n    class=\"navbar-toggler\"\n    type=\"button\"\n    :class=\"computedClasses\"\n    v-bind=\"computedAttrs\"\n    @click=\"onClick\"\n  >\n    <slot>\n      <span class=\"navbar-toggler-icon\" />\n    </slot>\n  </button>\n</template>\n\n<script setup lang=\"ts\">\nimport {vBToggle} from '../../directives'\nimport {computed} from 'vue'\nimport type {Booleanish} from '../../types'\nimport {useBooleanish} from '../../composables'\n\nconst props = withDefaults(\n  defineProps<{\n    disabled?: Booleanish\n    label?: string\n    target?: string | string[]\n  }>(),\n  {\n    label: 'Toggle navigation',\n    disabled: false,\n    target: undefined,\n  }\n)\n\nconst emit = defineEmits<{\n  click: [value: MouseEvent]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst disabledBoolean = useBooleanish(() => props.disabled)\n\nconst computedAttrs = computed(() => ({\n  'disabled': disabledBoolean.value,\n  'aria-label': props.label,\n}))\n\nconst computedClasses = computed(() => ({\n  disabled: disabledBoolean.value,\n}))\n\nconst onClick = (e: MouseEvent): void => {\n  if (!disabledBoolean.value) {\n    emit('click', e)\n  }\n}\n</script>\n","<template>\n  <component :is=\"wrapTag\" class=\"b-overlay-wrap position-relative\" :aria-busy=\"computedAriaBusy\">\n    <slot />\n    <BTransition\n      :no-fade=\"noFade\"\n      :trans-props=\"{enterToClass: 'show'}\"\n      name=\"fade\"\n      @on-after-enter=\"emit('shown')\"\n      @on-after-leave=\"emit('hidden')\"\n    >\n      <component\n        :is=\"overlayTag\"\n        v-if=\"showBoolean\"\n        :class=\"overlayClasses\"\n        :style=\"overlayStyles\"\n        @click=\"emit('click', $event)\"\n      >\n        <div class=\"position-absolute\" :class=\"blurClasses\" :style=\"blurStyles\" />\n\n        <div class=\"position-absolute\" :style=\"spinWrapperStyles\">\n          <slot name=\"overlay\" v-bind=\"spinnerAttrs\">\n            <BSpinner v-if=\"!noSpinnerBoolean\" v-bind=\"spinnerAttrs\" />\n          </slot>\n        </div>\n      </component>\n    </BTransition>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed} from 'vue'\nimport type {Booleanish, ColorVariant, SpinnerType} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport BTransition from '../BTransition/BTransition.vue'\nimport BSpinner from '../BSpinner.vue'\n\nconst props = withDefaults(\n  defineProps<{\n    bgColor?: string\n    blur?: string\n    fixed?: Booleanish\n    noCenter?: Booleanish\n    noFade?: Booleanish\n    noWrap?: Booleanish\n    opacity?: number | string\n    overlayTag?: string\n    rounded?: boolean | string\n    show?: Booleanish\n    spinnerSmall?: Booleanish\n    spinnerType?: SpinnerType\n    spinnerVariant?: ColorVariant | null\n    noSpinner?: Booleanish\n    variant?: ColorVariant | 'white' | 'transparent' | null\n    wrapTag?: string\n    zIndex?: number | string\n  }>(),\n  {\n    blur: '2px',\n    bgColor: undefined,\n    spinnerVariant: undefined,\n    fixed: false,\n    noCenter: false,\n    noSpinner: false,\n    noFade: false,\n    noWrap: false,\n    opacity: 0.85,\n    overlayTag: 'div',\n    rounded: false,\n    show: false,\n    spinnerSmall: false,\n    spinnerType: 'border',\n    variant: 'light',\n    wrapTag: 'div',\n    zIndex: 10,\n  }\n)\n\nconst emit = defineEmits<{\n  click: [value: MouseEvent]\n  hidden: []\n  shown: []\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  overlay?: (props: {\n    type: SpinnerType\n    variant: ColorVariant | null | undefined\n    small: boolean\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  }) => any\n}>()\n\nconst positionStyles = {top: 0, left: 0, bottom: 0, right: 0}\n\nconst fixedBoolean = useBooleanish(() => props.fixed)\nconst noSpinnerBoolean = useBooleanish(() => props.noSpinner)\nconst noCenterBoolean = useBooleanish(() => props.noCenter)\nconst noWrapBoolean = useBooleanish(() => props.noWrap)\nconst showBoolean = useBooleanish(() => props.show)\nconst spinnerSmallBoolean = useBooleanish(() => props.spinnerSmall)\n\nconst computedRounded = computed(() =>\n  props.rounded === true || props.rounded === ''\n    ? 'rounded'\n    : props.rounded === false\n    ? ''\n    : `rounded-${props.rounded}`\n)\n\nconst computedVariant = computed(() =>\n  props.variant !== null && !props.bgColor ? `bg-${props.variant}` : ''\n)\n\nconst computedAriaBusy = computed(() => (showBoolean.value ? true : null))\n\nconst spinnerAttrs = computed(() => ({\n  type: props.spinnerType,\n  variant: props.spinnerVariant,\n  small: spinnerSmallBoolean.value,\n}))\n\nconst overlayStyles = computed(() => ({\n  ...positionStyles,\n  zIndex: props.zIndex || 10,\n}))\n\nconst overlayClasses = computed(() => [\n  'b-overlay',\n  {\n    'position-absolute': !noWrapBoolean.value || !fixedBoolean.value,\n    'position-fixed': noWrapBoolean.value && fixedBoolean.value,\n  },\n])\n\nconst blurClasses = computed(() => [computedVariant.value, computedRounded.value])\n\nconst blurStyles = computed(() => ({\n  ...positionStyles,\n  opacity: props.opacity,\n  backgroundColor: props.bgColor || undefined,\n  backdropFilter: props.blur ? `blur(${props.blur})` : undefined,\n}))\n\nconst spinWrapperStyles = computed(() =>\n  noCenterBoolean.value\n    ? positionStyles\n    : {\n        top: '50%',\n        left: '50%',\n        transform: 'translateX(-50%) translateY(-50%)',\n      }\n)\n</script>\n","<template>\n  <Teleport :to=\"teleportTo\" :disabled=\"teleportDisabledBoolean\">\n    <BTransition\n      :no-fade=\"true\"\n      :trans-props=\"{\n        enterToClass: 'showing',\n        enterFromClass: '',\n        leaveToClass: 'hiding show',\n        leaveFromClass: 'show',\n      }\"\n      @before-enter=\"OnBeforeEnter\"\n      @after-enter=\"OnAfterEnter\"\n      @leave=\"onLeave\"\n      @after-leave=\"OnAfterLeave\"\n    >\n      <div\n        v-show=\"modelValue\"\n        :id=\"computedId\"\n        ref=\"element\"\n        aria-modal=\"true\"\n        role=\"dialog\"\n        :class=\"computedClasses\"\n        tabindex=\"-1\"\n        :aria-labelledby=\"`${computedId}-offcanvas-label`\"\n        data-bs-backdrop=\"false\"\n        v-bind=\"$attrs\"\n        @keyup.esc=\"hide('esc')\"\n      >\n        <template v-if=\"lazyShowing\">\n          <div v-if=\"!noHeaderBoolean\" class=\"offcanvas-header\" :class=\"headerClass\">\n            <slot name=\"header\" v-bind=\"{visible: modelValueBoolean, placement, hide}\">\n              <h5 :id=\"`${computedId}-offcanvas-label`\" class=\"offcanvas-title\">\n                <slot name=\"title\">\n                  {{ title }}\n                </slot>\n              </h5>\n              <BCloseButton\n                v-if=\"!noHeaderCloseBoolean\"\n                class=\"text-reset\"\n                :aria-label=\"dismissLabel\"\n                @click=\"hide('close')\"\n              />\n            </slot>\n          </div>\n          <div class=\"offcanvas-body\" :class=\"bodyClass\">\n            <slot />\n          </div>\n          <div v-if=\"hasFooterSlot\" :class=\"footerClass\">\n            <slot name=\"footer\" v-bind=\"{visible: modelValueBoolean, placement, hide}\" />\n          </div>\n        </template>\n      </div>\n    </BTransition>\n    <BOverlay\n      :variant=\"backdropVariant\"\n      :show=\"showBackdrop\"\n      :fixed=\"true\"\n      no-wrap\n      :no-spinner=\"true\"\n      @click=\"hide('backdrop')\"\n    />\n  </Teleport>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, nextTick, ref, type RendererElement, useSlots} from 'vue'\nimport {useEventListener, useFocus, useVModel} from '@vueuse/core'\nimport {useBooleanish, useId, useSafeScrollLock} from '../../composables'\nimport type {Booleanish, ColorVariant} from '../../types'\nimport {BvTriggerableEvent, isEmptySlot} from '../../utils'\nimport BOverlay from '../BOverlay/BOverlay.vue'\nimport BCloseButton from '../BButton/BCloseButton.vue'\nimport BTransition from '../BTransition/BTransition.vue'\n\n// TODO once the responsive stuff may be implemented correctly,\n// What needs to occur is a fixing of the \"body scrolling\".\n// If the offcanvas is on the screen on a large screen, body scrolling is not disabled\n// Even though the modelValue is true\n// When it's a small screen and close, it works, as normal,\n// But then when it opens up on a small screen, it must disable again\n// This is implemented on Layout.vue, but is not officially supported.\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(\n  defineProps<{\n    dismissLabel?: string\n    modelValue?: Booleanish\n    bodyScrolling?: Booleanish\n    backdrop?: Booleanish\n    noCloseOnBackdrop?: Booleanish\n    noCloseOnEsc?: Booleanish\n    // TODO standardize this. Create a dedicated type\n    // Then in components that use individual props (BImg)\n    // Make them just use prop placement\n    placement?: 'top' | 'bottom' | 'start' | 'end'\n    title?: string\n    noHeaderClose?: Booleanish\n    noHeader?: Booleanish\n    lazy?: Booleanish\n    id?: string\n    noFocus?: Booleanish\n    backdropVariant?: ColorVariant | null\n    headerClass?: string\n    bodyClass?: string\n    footerClass?: string\n    teleportDisabled?: Booleanish\n    teleportTo?: string | RendererElement | null | undefined\n    // TODO responsive doesn't work\n    // responsive?: Breakpoint\n  }>(),\n  {\n    dismissLabel: 'Close',\n    id: undefined,\n    title: undefined,\n    modelValue: false,\n    backdropVariant: 'dark',\n    noFocus: false,\n    bodyScrolling: false,\n    noCloseOnBackdrop: false,\n    noCloseOnEsc: false,\n    backdrop: true,\n    lazy: false,\n    placement: 'start',\n    noHeaderClose: false,\n    noHeader: false,\n    headerClass: undefined,\n    bodyClass: undefined,\n    footerClass: undefined,\n    teleportDisabled: false,\n    teleportTo: 'body',\n  }\n)\n\nconst emit = defineEmits<{\n  'update:modelValue': [value: boolean]\n  'show': [value: BvTriggerableEvent]\n  'shown': [value: BvTriggerableEvent]\n  'hide': [value: BvTriggerableEvent]\n  'hidden': [value: BvTriggerableEvent]\n  'hide-prevented': []\n  'show-prevented': []\n  'esc': [value: BvTriggerableEvent]\n  'close': [value: BvTriggerableEvent]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  title?: (props: Record<string, never>) => any\n  header?: (props: {\n    visible: boolean\n    placement: 'top' | 'bottom' | 'start' | 'end'\n    hide: (trigger?: string) => void\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  }) => any\n  footer?: (props: {\n    visible: boolean\n    placement: 'top' | 'bottom' | 'start' | 'end'\n    hide: (trigger?: string) => void\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  }) => any\n}>()\n\nconst slots = useSlots()\n\nconst modelValue = useVModel(props, 'modelValue', emit, {passive: true})\n\nconst modelValueBoolean = useBooleanish(modelValue)\nconst bodyScrollingBoolean = useBooleanish(() => props.bodyScrolling)\nconst backdropBoolean = useBooleanish(() => props.backdrop)\nconst noHeaderCloseBoolean = useBooleanish(() => props.noHeaderClose)\nconst noHeaderBoolean = useBooleanish(() => props.noHeader)\nconst noFocusBoolean = useBooleanish(() => props.noFocus)\nconst noCloseOnBackdropBoolean = useBooleanish(() => props.noCloseOnBackdrop)\nconst noCloseOnEscBoolean = useBooleanish(() => props.noCloseOnEsc)\nconst lazyBoolean = useBooleanish(() => props.lazy)\nconst teleportDisabledBoolean = useBooleanish(() => props.teleportDisabled)\n\nconst computedId = useId(() => props.id, 'offcanvas')\nuseSafeScrollLock(modelValueBoolean, bodyScrollingBoolean)\n\nconst element = ref<HTMLElement | null>(null)\n\nconst {focused} = useFocus(element, {\n  initialValue: modelValueBoolean.value && noFocusBoolean.value === false,\n})\n\nconst isActive = ref(modelValueBoolean.value)\nconst lazyLoadCompleted = ref(false)\n\nconst showBackdrop = computed(\n  () => backdropBoolean.value === true && modelValueBoolean.value === true\n)\n\nconst lazyShowing = computed(\n  () =>\n    lazyBoolean.value === false ||\n    (lazyBoolean.value === true && lazyLoadCompleted.value === true) ||\n    (lazyBoolean.value === true && modelValueBoolean.value === true)\n)\n\nconst hasFooterSlot = computed(() => !isEmptySlot(slots.footer))\nconst computedClasses = computed(() => [\n  // props.responsive === undefined ? 'offcanvas' : `offcanvas-${props.responsive}`,\n  'offcanvas', // Remove when above check is fixed\n  `offcanvas-${props.placement}`,\n  {\n    show: modelValueBoolean.value && isActive.value === true,\n  },\n])\n\nconst buildTriggerableEvent = (\n  type: string,\n  opts: Partial<BvTriggerableEvent> = {}\n): BvTriggerableEvent =>\n  new BvTriggerableEvent(type, {\n    cancelable: false,\n    target: element.value || null,\n    relatedTarget: null,\n    trigger: null,\n    ...opts,\n    componentId: computedId.value,\n  })\n\nconst hide = (trigger = '') => {\n  const event = buildTriggerableEvent('hide', {cancelable: trigger !== '', trigger})\n\n  if (trigger === 'close') {\n    emit(trigger, event)\n  }\n  if (trigger === 'esc') {\n    emit(trigger, event)\n  }\n  emit('hide', event)\n\n  if (\n    event.defaultPrevented ||\n    (trigger === 'backdrop' && noCloseOnBackdropBoolean.value) ||\n    (trigger === 'esc' && noCloseOnEscBoolean.value)\n  ) {\n    emit('hide-prevented')\n    return\n  }\n  modelValue.value = false\n}\n\nconst show = () => {\n  const event = buildTriggerableEvent('show', {cancelable: true})\n  emit('show', event)\n  if (event.defaultPrevented) {\n    modelValue.value = false\n    emit('show-prevented')\n    return\n  }\n  modelValue.value = true\n}\n\nconst focus = () => {\n  nextTick(() => {\n    if (noFocusBoolean.value === false) {\n      focused.value = true\n    }\n  })\n}\n\nconst OnBeforeEnter = () => show()\nconst OnAfterEnter = () => {\n  isActive.value = true\n  focus()\n  emit('shown', buildTriggerableEvent('shown'))\n  if (lazyBoolean.value === true) lazyLoadCompleted.value = true\n}\nconst onLeave = () => {\n  isActive.value = false\n}\nconst OnAfterLeave = () => {\n  emit('hidden', buildTriggerableEvent('hidden'))\n  if (lazyBoolean.value === true) lazyLoadCompleted.value = false\n}\nuseEventListener(element, 'bv-toggle', () => {\n  modelValueBoolean.value ? hide() : show()\n})\n\ndefineExpose({\n  hide,\n  show,\n})\n</script>\n","<script lang=\"ts\">\nimport {BvEvent, normalizeSlot, toInteger} from '../../utils'\nimport {computed, defineComponent, h, type PropType, reactive, watch} from 'vue'\nimport type {\n  AlignmentJustifyContent,\n  Booleanish,\n  Pagination,\n  PaginationPage,\n  Size,\n} from '../../types'\nimport {useAlignment, useBooleanish} from '../../composables'\nimport {useVModel} from '@vueuse/core'\n// Default # of buttons limit\nconst DEFAULT_LIMIT = 5\n\nconst DEFAULT_PER_PAGE = 20\nconst DEFAULT_TOTAL_ROWS = 0\n\n// Threshold of limit size when we start/stop showing ellipsis\nconst ELLIPSIS_THRESHOLD = 3\n\n// Slot Constants\nconst SLOT_NAME_ELLIPSIS_TEXT = 'ellipsis-text'\nconst SLOT_NAME_FIRST_TEXT = 'first-text'\nconst SLOT_NAME_LAST_TEXT = 'last-text'\nconst SLOT_NAME_NEXT_TEXT = 'next-text'\nconst SLOT_NAME_PAGE = 'page'\nconst SLOT_NAME_PREV_TEXT = 'prev-text'\n\nconst sanitizePerPage = (value: number): number => Math.max(toInteger(value) || DEFAULT_PER_PAGE, 1)\nconst sanitizeTotalRows = (value: number): number =>\n  Math.max(toInteger(value) || DEFAULT_TOTAL_ROWS, 0)\nconst sanitizeCurrentPage = (value: number, numberOfPages: number) => {\n  const page = toInteger(value) || 1\n  return page > numberOfPages ? numberOfPages : page < 1 ? 1 : page\n}\n\nexport default defineComponent({\n  name: 'BPagination',\n  props: {\n    align: {type: String as PropType<AlignmentJustifyContent | 'fill'>, default: 'start'},\n    ariaControls: {type: String, default: undefined},\n    ariaLabel: {type: String, default: 'Pagination'},\n    disabled: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    ellipsisClass: {type: [Array, String], default: () => []},\n    ellipsisText: {type: String, default: '\\u2026'},\n    firstClass: {type: [Array, String], default: () => []},\n    firstNumber: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    firstText: {type: String, default: '\\u00AB'},\n    hideEllipsis: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    hideGotoEndButtons: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    labelFirstPage: {type: String, default: 'Go to first page'},\n    labelLastPage: {type: String, default: 'Go to last page'},\n    labelNextPage: {type: String, default: 'Go to next page'},\n    labelPage: {type: String, default: 'Go to page'},\n    labelPrevPage: {type: String, default: 'Go to previous page'},\n    lastClass: {type: [Array, String], default: () => []},\n    lastNumber: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    lastText: {type: String, default: '\\u00BB'},\n    limit: {type: Number, default: DEFAULT_LIMIT},\n    modelValue: {type: Number, default: 1}, // V-model prop\n    nextClass: {type: [Array, String], default: () => []},\n    nextText: {type: String, default: '\\u203A'},\n    pageClass: {type: [Array, String], default: () => []},\n    perPage: {type: Number, default: DEFAULT_PER_PAGE},\n    pills: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    prevClass: {type: [Array, String], default: () => []},\n    prevText: {type: String, default: '\\u2039'},\n    size: {type: String as PropType<Size>, default: 'md'},\n    totalRows: {type: Number, default: DEFAULT_TOTAL_ROWS},\n  },\n  emits: ['update:modelValue', 'page-click'],\n  setup(props, {emit, slots}) {\n    const modelValue = useVModel(props, 'modelValue', emit)\n\n    const disabledBoolean = useBooleanish(() => props.disabled)\n    const firstNumberBoolean = useBooleanish(() => props.firstNumber)\n    const hideEllipsisBoolean = useBooleanish(() => props.hideEllipsis)\n    const hideGotoEndButtonsBoolean = useBooleanish(() => props.hideGotoEndButtons)\n    const lastNumberBoolean = useBooleanish(() => props.lastNumber)\n    const pillsBoolean = useBooleanish(() => props.pills)\n\n    const justifyAlign = computed<AlignmentJustifyContent>(() =>\n      props.align === 'fill' ? 'start' : props.align\n    )\n    const alignment = useAlignment(justifyAlign)\n\n    // Use Active to on page-item to denote active tab\n    const numberOfPages = computed(() =>\n      Math.ceil(sanitizeTotalRows(props.totalRows) / sanitizePerPage(props.perPage))\n    )\n\n    const startNumber = computed(() => {\n      let lStartNumber: number\n      const pagesLeft: number = numberOfPages.value - modelValue.value\n\n      if (pagesLeft + 2 < props.limit && props.limit > ELLIPSIS_THRESHOLD) {\n        lStartNumber = numberOfPages.value - numberOfLinks.value + 1\n      } else {\n        // Middle and beginning calculation.\n        lStartNumber = modelValue.value - Math.floor(numberOfLinks.value / 2)\n      }\n      // Negative due at times\n      if (lStartNumber < 1) {\n        lStartNumber = 1\n      } else if (lStartNumber > numberOfPages.value - numberOfLinks.value) {\n        lStartNumber = numberOfPages.value - numberOfLinks.value + 1\n      }\n      //why check for this?\n      // if (showFirstDots.value && cfirstNumber && lStartNumber < 4) {\n      //   lStartNumber = 1\n      // }\n\n      // Special handling for lower limits (where ellipsis are never shown)\n      if (props.limit <= ELLIPSIS_THRESHOLD) {\n        if (\n          lastNumberBoolean.value &&\n          numberOfPages.value === lStartNumber + numberOfLinks.value - 1\n        ) {\n          lStartNumber = Math.max(lStartNumber - 1, 1)\n        }\n      }\n      return lStartNumber\n    })\n\n    const showFirstDots = computed(() => {\n      const pagesLeft = numberOfPages.value - modelValue.value\n      let rShowDots = false\n\n      if (pagesLeft + 2 < props.limit && props.limit > ELLIPSIS_THRESHOLD) {\n        if (props.limit > ELLIPSIS_THRESHOLD) {\n          rShowDots = true\n        }\n      } else {\n        if (props.limit > ELLIPSIS_THRESHOLD) {\n          rShowDots = !!(!hideEllipsisBoolean.value || firstNumberBoolean.value)\n        }\n      }\n      if (startNumber.value <= 1) {\n        rShowDots = false\n      }\n\n      if (rShowDots && firstNumberBoolean.value && startNumber.value < 4) {\n        rShowDots = false\n      }\n\n      return rShowDots\n    })\n\n    //Calculate the number of links considering limit\n    const numberOfLinks = computed(() => {\n      let n: number = props.limit\n\n      if (numberOfPages.value <= props.limit) {\n        n = numberOfPages.value\n      } else if (modelValue.value < props.limit - 1 && props.limit > ELLIPSIS_THRESHOLD) {\n        if (!hideEllipsisBoolean.value || lastNumberBoolean.value) {\n          n = props.limit - (firstNumberBoolean.value ? 0 : 1)\n        }\n        n = Math.min(n, props.limit)\n      } else if (\n        numberOfPages.value - modelValue.value + 2 < props.limit &&\n        props.limit > ELLIPSIS_THRESHOLD\n      ) {\n        if (!hideEllipsisBoolean.value || firstNumberBoolean.value) {\n          n = props.limit - (lastNumberBoolean.value ? 0 : 1)\n        }\n      } else {\n        // We consider ellipsis tabs as their own page links\n        if (props.limit > ELLIPSIS_THRESHOLD) {\n          n = props.limit - (hideEllipsisBoolean.value ? 0 : 2)\n        }\n      }\n\n      return n\n    })\n\n    const showLastDots = computed(() => {\n      const paginationWindowEnd = numberOfPages.value - numberOfLinks.value // The start of the last window of page links\n\n      let rShowDots = false\n\n      if (modelValue.value < props.limit - 1 && props.limit > ELLIPSIS_THRESHOLD) {\n        if (!hideEllipsisBoolean.value || lastNumberBoolean.value) {\n          rShowDots = true\n        }\n      } else {\n        if (props.limit > ELLIPSIS_THRESHOLD) {\n          rShowDots = !!(!hideEllipsisBoolean.value || lastNumberBoolean.value)\n        }\n      }\n      if (startNumber.value > paginationWindowEnd) {\n        rShowDots = false\n      }\n      const lastPageNumber = startNumber.value + numberOfLinks.value - 1\n\n      if (rShowDots && lastNumberBoolean.value && lastPageNumber > numberOfPages.value - 3) {\n        rShowDots = false\n      }\n\n      return rShowDots\n    })\n\n    const pagination = reactive<Pagination>({\n      pageSize: sanitizePerPage(props.perPage),\n      totalRows: sanitizeTotalRows(props.totalRows),\n      numberOfPages: numberOfPages.value,\n    })\n\n    const pageClick = (event: MouseEvent, pageNumber: number) => {\n      if (pageNumber === modelValue.value) {\n        return\n      }\n\n      const {target} = event\n      // Emit a user-cancelable `page-click` event\n      const clickEvent = new BvEvent('page-click', {\n        cancelable: true,\n        target,\n      })\n      emit('page-click', clickEvent, pageNumber)\n      if (clickEvent.defaultPrevented) {\n        return\n      }\n\n      modelValue.value = pageNumber\n\n      //    nextTick(() => {\n      //  if (isVisible(target) && un_element.contains(target)) {\n      //  attemptFocus(target)\n      //} else {\n      //this.focusCurrent()\n      //}\n      // })\n    }\n\n    const btnSize = computed(() => (props.size ? `pagination-${props.size}` : ''))\n    const styleClass = computed(() => (pillsBoolean.value ? 'b-pagination-pills' : ''))\n\n    watch(modelValue, (newValue) => {\n      const calculatedValue = sanitizeCurrentPage(newValue, numberOfPages.value)\n      if (calculatedValue !== modelValue.value) {\n        modelValue.value = calculatedValue\n      }\n    })\n\n    watch(pagination, (oldValue, newValue) => {\n      if (!(oldValue === undefined || oldValue === null)) {\n        if (newValue.pageSize !== oldValue.pageSize && newValue.totalRows === oldValue.totalRows) {\n          // If the page size changes, reset to page 1\n          modelValue.value = 1\n        } else if (\n          newValue.numberOfPages !== oldValue.numberOfPages &&\n          modelValue.value > newValue.numberOfPages\n        ) {\n          // If `numberOfPages` changes and is less than\n          // the `currentPage` number, reset to page 1\n          modelValue.value = 1\n        }\n      }\n    })\n\n    //Render Helper Functions\n    const pages = computed(() => {\n      const result = []\n      for (let index = 0; index < numberOfLinks.value; index++) {\n        result.push({number: startNumber.value + index, classes: null})\n      }\n      return result\n    })\n\n    return () => {\n      const buttons = []\n      const pageNumbers = pages.value.map((p) => p.number) // array of numbers... Used in first and last number comparisons\n      const isActivePage = (pageNumber: number) => pageNumber === modelValue.value\n      const noCurrentPage: boolean = modelValue.value < 1\n      const fill = props.align === 'fill'\n\n      const makeEndBtn = (\n        linkTo: number,\n        ariaLabel: string,\n        btnSlot: string,\n        btnText: string,\n        btnClass: string | unknown[],\n        pageTest: number\n      ) => {\n        const isDisabled: boolean =\n          disabledBoolean.value ||\n          isActivePage(pageTest) ||\n          noCurrentPage ||\n          linkTo < 1 ||\n          linkTo > numberOfPages.value\n        const pageNumber: number =\n          linkTo < 1 ? 1 : linkTo > numberOfPages.value ? numberOfPages.value : linkTo\n        const scope = {disabled: isDisabled, page: pageNumber, index: pageNumber - 1}\n        const btnContent = normalizeSlot(btnSlot, scope, slots) || btnText || ''\n\n        return h(\n          'li',\n          {\n            class: [\n              'page-item',\n              {\n                'disabled': isDisabled,\n                'flex-fill': fill,\n                'd-flex': fill && !isDisabled,\n              },\n              btnClass,\n            ],\n          },\n          // render inner content\n          h(\n            isDisabled ? 'span' : 'button',\n            {\n              'class': ['page-link', {'flex-grow-1': !isDisabled && fill}],\n              'aria-label': ariaLabel,\n              'aria-controls': props.ariaControls || null,\n              'aria-disabled': isDisabled ? true : null,\n              'role': 'menuitem',\n              'type': isDisabled ? null : 'button',\n              'tabindex': isDisabled ? null : '-1',\n              'onClick': (event: MouseEvent) => {\n                if (isDisabled) {\n                  return\n                }\n                pageClick(event, pageNumber)\n              },\n            },\n            btnContent\n          )\n        )\n      }\n\n      const makeEllipsis = (isLast: boolean) =>\n        h(\n          'li',\n          {\n            class: [\n              'page-item',\n              'disabled',\n              'bv-d-xs-down-none',\n              fill ? 'flex-fill' : '',\n              props.ellipsisClass,\n            ],\n            role: 'separator',\n            key: `ellipsis-${isLast ? 'last' : 'first'}`,\n          },\n          [\n            h(\n              'span',\n              {class: ['page-link']},\n              normalizeSlot(SLOT_NAME_ELLIPSIS_TEXT, {}, slots) || props.ellipsisText || '...'\n            ),\n          ]\n        )\n\n      const makePageButton = (page: PaginationPage, idx: number) => {\n        const active: boolean = isActivePage(page.number) && !noCurrentPage\n        const tabIndex = disabledBoolean.value\n          ? null\n          : active || (noCurrentPage && idx === 0)\n          ? '0'\n          : '-1'\n        const scope = {\n          active,\n          disabled: disabledBoolean.value,\n          page: page.number,\n          index: page.number - 1,\n          content: page.number,\n        }\n        const btnContent = normalizeSlot(SLOT_NAME_PAGE, scope, slots) || page.number\n        const inner = h(\n          disabledBoolean.value ? 'span' : 'button',\n          {\n            'class': ['page-link', {'flex-grow-1': !disabledBoolean.value && fill}],\n            'aria-controls': props.ariaControls || null,\n            'aria-disabled': disabledBoolean.value ? true : null,\n            'aria-label': props.labelPage ? `${props.labelPage} ${page.number}` : null,\n            'role': 'menuitemradio',\n            'type': disabledBoolean.value ? null : 'button',\n            'tabindex': tabIndex,\n            'onClick': (event: MouseEvent) => {\n              if (!disabledBoolean.value) {\n                pageClick(event, page.number)\n              }\n            },\n          },\n          btnContent\n        )\n\n        return h(\n          'li',\n          {\n            class: [\n              'page-item',\n              {\n                'disabled': disabledBoolean.value,\n                active,\n                'flex-fill': fill,\n                'd-flex': fill && !disabledBoolean.value,\n              },\n              props.pageClass,\n            ],\n            role: 'presentation',\n            key: `page-${page.number}`,\n          },\n          inner\n        )\n      }\n\n      // Goto first page button. Don't render button when `hideGotoEndButtons` or `firstNumber` is set\n      if (!hideGotoEndButtonsBoolean.value && !firstNumberBoolean.value) {\n        const gotoFirstPageButton = makeEndBtn(\n          1,\n          props.labelFirstPage,\n          SLOT_NAME_FIRST_TEXT,\n          props.firstText,\n          props.firstClass,\n          1\n        )\n        buttons.push(gotoFirstPageButton)\n      }\n\n      //Previous Button\n      const previousButton = makeEndBtn(\n        modelValue.value - 1,\n        props.labelFirstPage,\n        SLOT_NAME_PREV_TEXT,\n        props.prevText,\n        props.prevClass,\n        1\n      )\n      buttons.push(previousButton)\n\n      // First Page Number Button\n      if (firstNumberBoolean.value && pageNumbers[0] !== 1) {\n        buttons.push(makePageButton({number: 1}, 0))\n      }\n\n      // first Ellipsis\n      if (showFirstDots.value) {\n        buttons.push(makeEllipsis(false))\n      }\n\n      pages.value.forEach((page, idx) => {\n        const offset =\n          showFirstDots.value && firstNumberBoolean.value && pageNumbers[0] !== 1 ? 1 : 0\n        buttons.push(makePageButton(page, idx + offset))\n      })\n\n      // last Ellipsis\n      if (showLastDots.value) {\n        buttons.push(makeEllipsis(true))\n      }\n\n      if (lastNumberBoolean.value && pageNumbers[pageNumbers.length - 1] !== numberOfPages.value) {\n        buttons.push(makePageButton({number: numberOfPages.value}, -1))\n      }\n\n      //Next Button\n      const nextButton = makeEndBtn(\n        modelValue.value + 1,\n        props.labelNextPage,\n        SLOT_NAME_NEXT_TEXT,\n        props.nextText,\n        props.nextClass,\n        numberOfPages.value\n      )\n      buttons.push(nextButton)\n\n      // Goto last page button\n      if (!lastNumberBoolean.value && !hideGotoEndButtonsBoolean.value) {\n        const gotoLastPageButton = makeEndBtn(\n          numberOfPages.value,\n          props.labelLastPage,\n          SLOT_NAME_LAST_TEXT,\n          props.lastText,\n          props.lastClass,\n          numberOfPages.value\n        )\n        buttons.push(gotoLastPageButton)\n      }\n\n      //pagination\n      return h(\n        'ul',\n        {\n          'class': ['pagination', btnSize.value, alignment.value, styleClass.value],\n          'role': 'menubar',\n          'aria-disabled': disabledBoolean.value,\n          'aria-label': props.ariaLabel || null,\n        },\n        buttons\n      )\n    }\n  },\n})\n</script>\n","<template>\n  <component :is=\"wrapperTag\" :class=\"wrapperClasses\">\n    <component\n      v-bind=\"$attrs\"\n      :is=\"tag\"\n      class=\"placeholder\"\n      :class=\"computedClasses\"\n      :style=\"computedStyle\"\n    />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, type CSSProperties} from 'vue'\nimport type {ColorVariant, PlaceholderAnimation, PlaceholderSize} from '../../types'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(\n  defineProps<{\n    tag?: string\n    wrapperTag?: string\n    width?: string | number\n    cols?: string | number\n    variant?: ColorVariant | null\n    size?: PlaceholderSize\n    animation?: PlaceholderAnimation\n  }>(),\n  {\n    variant: null,\n    size: 'md',\n    animation: undefined,\n    width: undefined,\n    tag: 'span',\n    wrapperTag: 'span',\n    cols: 12,\n  }\n)\n\nconst widthString = computed<string | undefined>(() =>\n  props.width === undefined\n    ? undefined\n    : typeof props.width === 'number'\n    ? props.width.toString()\n    : props.width.replace('%', '')\n)\n\nconst colsString = computed<string | undefined>(() =>\n  props.cols === undefined\n    ? undefined\n    : typeof props.cols === 'number'\n    ? props.cols.toString()\n    : props.cols\n)\n\nconst computedClasses = computed(() => ({\n  [`col-${colsString.value}`]: colsString.value !== undefined && widthString.value === undefined,\n  [`bg-${props.variant}`]: props.variant !== null,\n  [`placeholder-${props.size}`]: props.size !== 'md',\n}))\n\nconst wrapperClasses = computed(() => ({\n  [`placeholder-${props.animation}`]: props.animation !== undefined,\n}))\n\nconst computedStyle = computed<CSSProperties>(() => ({\n  width: widthString.value === undefined ? undefined : `${widthString.value}%`,\n}))\n</script>\n","<template>\n  <BPlaceholder class=\"btn disabled\" :class=\"computedClasses\" v-bind=\"computedAttrs\" />\n</template>\n\n<script setup lang=\"ts\">\nimport BPlaceholder from './BPlaceholder.vue'\nimport type {ColorVariant, PlaceholderAnimation} from '../../types'\nimport {computed} from 'vue'\n\nconst props = withDefaults(\n  defineProps<{\n    tag?: string\n    width?: string | number\n    cols?: string | number\n    variant?: ColorVariant | null\n    animation?: PlaceholderAnimation\n  }>(),\n  {\n    tag: 'div',\n    width: undefined,\n    cols: undefined,\n    animation: undefined,\n    variant: 'primary',\n  }\n)\n\nconst computedClasses = computed(() => ({\n  [`btn-${props.variant}`]: props.variant !== null,\n}))\n\nconst computedAttrs = computed(() => ({\n  animation: props.animation,\n  width: props.width,\n  cols: props.cols,\n  tag: props.tag,\n}))\n</script>\n","<template>\n  <BCard :img-bottom=\"imgBottom\">\n    <template v-if=\"!noImgBoolean\" #img>\n      <slot name=\"img\">\n        <BCardImg v-bind=\"imgAttrs\" />\n      </slot>\n    </template>\n\n    <template v-if=\"!noHeaderBoolean\" #header>\n      <slot name=\"header\">\n        <BPlaceholder v-bind=\"headerAttrs\" />\n      </slot>\n    </template>\n    <slot>\n      <BPlaceholder cols=\"7\" v-bind=\"defaultAttrs\" />\n      <BPlaceholder cols=\"4\" v-bind=\"defaultAttrs\" />\n      <BPlaceholder cols=\"4\" v-bind=\"defaultAttrs\" />\n      <BPlaceholder cols=\"6\" v-bind=\"defaultAttrs\" />\n      <BPlaceholder cols=\"8\" v-bind=\"defaultAttrs\" />\n    </slot>\n    <template v-if=\"!noFooterBoolean\" #footer>\n      <slot name=\"footer\">\n        <BPlaceholderButton v-if=\"!noButtonBoolean\" v-bind=\"footerAttrs\" />\n        <BPlaceholder v-else v-bind=\"footerAttrs\" />\n      </slot>\n    </template>\n  </BCard>\n</template>\n\n<script setup lang=\"ts\">\nimport BCard from '../BCard/BCard.vue'\nimport BCardImg from '../BCard/BCardImg.vue'\nimport BPlaceholder from './BPlaceholder.vue'\nimport BPlaceholderButton from './BPlaceholderButton.vue'\nimport type {Booleanish, ColorVariant, PlaceholderAnimation, PlaceholderSize} from '../../types'\nimport {computed} from 'vue'\nimport {useBooleanish} from '../../composables'\n\nconst props = withDefaults(\n  defineProps<{\n    noHeader?: Booleanish\n    headerWidth?: string | number\n    headerVariant?: ColorVariant | null\n    headerAnimation?: PlaceholderAnimation\n    headerSize?: PlaceholderSize\n    noFooter?: Booleanish\n    footerWidth?: string | number\n    footerVariant?: ColorVariant | null\n    footerAnimation?: PlaceholderAnimation\n    footerSize?: PlaceholderSize\n    animation?: PlaceholderAnimation\n    size?: PlaceholderSize\n    variant?: ColorVariant | null\n    noButton?: Booleanish\n    imgBottom?: Booleanish\n    imgSrc?: string\n    imgBlankColor?: string\n    imgHeight?: string | number\n    noImg?: Booleanish\n  }>(),\n  {\n    footerVariant: undefined,\n    footerAnimation: undefined,\n    footerSize: 'md',\n    animation: undefined,\n    size: 'md',\n    variant: undefined,\n    imgSrc: undefined,\n    headerAnimation: undefined,\n    headerSize: 'md',\n    headerVariant: undefined,\n    noButton: false,\n    headerWidth: 100,\n    footerWidth: 100,\n    noHeader: false,\n    noFooter: false,\n    imgBlankColor: '#868e96',\n    imgHeight: 100,\n    imgBottom: false,\n    noImg: false,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  img?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  header?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  footer?: (props: Record<string, never>) => any\n}>()\n\nconst noButtonBoolean = useBooleanish(() => props.noButton)\nconst noHeaderBoolean = useBooleanish(() => props.noHeader)\nconst noFooterBoolean = useBooleanish(() => props.noFooter)\nconst noImgBoolean = useBooleanish(() => props.noImg)\n\nconst headerAttrs = computed(() => ({\n  width: props.headerWidth,\n  variant: props.headerVariant,\n  animation: props.headerAnimation,\n  size: props.headerSize,\n}))\n\nconst footerAttrs = computed(() => ({\n  width: props.footerWidth,\n  animation: props.footerAnimation,\n  size: noButtonBoolean.value ? props.footerSize : undefined,\n  variant: props.footerVariant,\n}))\n\nconst defaultAttrs = computed(() => ({\n  animation: props.animation,\n  size: props.size,\n  variant: props.variant,\n}))\n\nconst imgAttrs = computed(() => ({\n  blank: !props.imgSrc ? true : false,\n  blankColor: props.imgBlankColor,\n  height: !props.imgSrc ? props.imgHeight : undefined,\n  src: props.imgSrc,\n  top: !props.imgBottom,\n  bottom: props.imgBottom,\n}))\n</script>\n","<template>\n  <table v-if=\"!responsive\" :class=\"computedClasses\">\n    <slot />\n  </table>\n  <div v-else :class=\"responsiveClasses\">\n    <table :class=\"computedClasses\">\n      <slot />\n    </table>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\n// import type {Breakpoint} from '../../types'\nimport {computed} from 'vue'\nimport {useBooleanish} from '../../composables'\nimport type {Booleanish, Breakpoint, ClassValue, ColorVariant} from '../../types'\n\nconst props = withDefaults(\n  defineProps<{\n    bordered?: Booleanish\n    borderless?: Booleanish\n    borderVariant?: ColorVariant | null\n    captionTop?: Booleanish\n    dark?: Booleanish\n    hover?: Booleanish\n    responsive?: boolean | Breakpoint\n    stacked?: boolean | Breakpoint\n    striped?: Booleanish\n    small?: Booleanish\n    tableClass?: ClassValue\n    tableVariant?: ColorVariant | null\n    stickyHeader?: Booleanish\n  }>(),\n  {\n    borderVariant: null,\n    tableClass: undefined,\n    tableVariant: null,\n    bordered: false,\n    borderless: false,\n    captionTop: false,\n    dark: false,\n    hover: false,\n    responsive: false,\n    stacked: false,\n    striped: false,\n    small: false,\n    stickyHeader: false,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst captionTopBoolean = useBooleanish(() => props.captionTop)\nconst borderlessBoolean = useBooleanish(() => props.borderless)\nconst borderedBoolean = useBooleanish(() => props.bordered)\nconst darkBoolean = useBooleanish(() => props.dark)\nconst hoverBoolean = useBooleanish(() => props.hover)\nconst smallBoolean = useBooleanish(() => props.small)\nconst stripedBoolean = useBooleanish(() => props.striped)\nconst stickyHeaderBoolean = useBooleanish(() => props.stickyHeader)\n\nconst computedClasses = computed(() => [\n  'table',\n  'b-table',\n  {\n    'table-bordered': borderedBoolean.value,\n    'table-borderless': borderlessBoolean.value,\n    [`border-${props.borderVariant}`]: props.borderVariant !== null,\n    'caption-top': captionTopBoolean.value,\n    'table-dark': darkBoolean.value,\n    'table-hover': hoverBoolean.value,\n    'b-table-stacked': typeof props.stacked === 'boolean' && props.stacked,\n    [`b-table-stacked-${props.stacked}`]: typeof props.stacked === 'string',\n    'table-striped': stripedBoolean.value,\n    'table-sm': smallBoolean.value,\n    [`table-${props.tableVariant}`]: props.tableVariant !== null,\n  },\n  props.tableClass,\n])\n\nconst responsiveClasses = computed(() => [\n  {\n    'table-responsive': props.responsive === true,\n    [`table-responsive-${props.responsive}`]: typeof props.responsive === 'string',\n    'b-table-sticky-header': stickyHeaderBoolean.value,\n  },\n])\n</script>\n","<template>\n  <BTableSimple>\n    <slot v-if=\"!hideHeaderBoolean\" name=\"thead\">\n      <thead>\n        <tr>\n          <th v-for=\"(_, i) in computedHeaderColumnsLength\" :key=\"i\">\n            <BPlaceholder v-bind=\"headerAttrs\" />\n          </th>\n        </tr>\n      </thead>\n    </slot>\n    <slot>\n      <tbody>\n        <tr v-for=\"(_, j) in rowsNumber\" :key=\"j\">\n          <td v-for=\"(__, k) in columnsNumber\" :key=\"k\">\n            <BPlaceholder v-bind=\"placeholderAttrs\" />\n          </td>\n        </tr>\n      </tbody>\n    </slot>\n    <slot v-if=\"showFooterBoolean\" name=\"tfoot\">\n      <tfoot>\n        <tr>\n          <th v-for=\"(_, l) in computedFooterColumnsLength\" :key=\"l\">\n            <BPlaceholder v-bind=\"footerAttrs\" />\n          </th>\n        </tr>\n      </tfoot>\n    </slot>\n  </BTableSimple>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed} from 'vue'\nimport type {Booleanish, ColorVariant, PlaceholderAnimation, PlaceholderSize} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport BTableSimple from '../BTable/BTableSimple.vue'\nimport BPlaceholder from './BPlaceholder.vue'\nimport {useToNumber} from '@vueuse/core'\n\nconst props = withDefaults(\n  defineProps<{\n    rows?: string | number\n    columns?: string | number\n    cellWidth?: string | number\n    size?: PlaceholderSize\n    animation?: PlaceholderAnimation\n    variant?: ColorVariant | null\n    headerColumns?: string | number\n    hideHeader?: Booleanish\n    headerCellWidth?: string | number\n    headerSize?: PlaceholderSize\n    headerAnimation?: PlaceholderAnimation\n    headerVariant?: ColorVariant | null\n    footerColumns?: string | number\n    showFooter?: Booleanish\n    footerCellWidth?: string | number\n    footerSize?: PlaceholderSize\n    footerAnimation?: PlaceholderAnimation\n    footerVariant?: ColorVariant | null\n  }>(),\n  {\n    headerSize: 'md',\n    headerAnimation: undefined,\n    headerVariant: undefined,\n    footerColumns: undefined,\n    footerSize: 'md',\n    footerAnimation: undefined,\n    footerVariant: undefined,\n    size: 'md',\n    animation: undefined,\n    variant: undefined,\n    headerColumns: undefined,\n    columns: 5,\n    rows: 3,\n    cellWidth: 100,\n    showFooter: false,\n    footerCellWidth: 100,\n    hideHeader: false,\n    headerCellWidth: 100,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  thead?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  tfoot?: (props: Record<string, never>) => any\n}>()\n\nconst columnsToNumber = useToNumber(() => props.columns, {nanToZero: true, method: 'parseInt'})\nconst rowsToNumber = useToNumber(() => props.rows, {nanToZero: true, method: 'parseInt'})\nconst computedHeaderColumns = computed(() => props.headerColumns ?? NaN)\nconst computedFooterColumns = computed(() => props.footerColumns ?? NaN)\nconst headerColumnsNumber = useToNumber(computedHeaderColumns, {\n  nanToZero: true,\n  method: 'parseInt',\n})\nconst footerColumnsNumber = useToNumber(computedFooterColumns, {\n  nanToZero: true,\n  method: 'parseInt',\n})\n\nconst columnsNumber = computed<number>(() => columnsToNumber.value || 5)\nconst rowsNumber = computed<number>(() => rowsToNumber.value || 3)\n\nconst computedHeaderColumnsLength = computed<number>(() =>\n  props.headerColumns === undefined ? columnsNumber.value : headerColumnsNumber.value\n)\nconst computedFooterColumnsLength = computed<number>(() =>\n  props.footerColumns === undefined ? columnsNumber.value : footerColumnsNumber.value\n)\n\nconst placeholderAttrs = computed(() => ({\n  size: props.size,\n  variant: props.variant,\n  animation: props.animation,\n  width: props.cellWidth,\n}))\n\nconst headerAttrs = computed(() => ({\n  size: props.headerSize,\n  variant: props.headerVariant,\n  animation: props.headerAnimation,\n  width: props.headerCellWidth,\n}))\n\nconst footerAttrs = computed(() => ({\n  size: props.footerSize,\n  variant: props.footerVariant,\n  animation: props.footerAnimation,\n  width: props.footerCellWidth,\n}))\n\nconst hideHeaderBoolean = useBooleanish(() => props.hideHeader)\nconst showFooterBoolean = useBooleanish(() => props.showFooter)\n</script>\n","<template>\n  <slot v-if=\"loadingBoolean\" name=\"loading\" />\n  <slot v-else />\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish} from '../../types'\nimport {useBooleanish} from '../../composables'\n\nconst props = withDefaults(\n  defineProps<{\n    loading?: Booleanish\n  }>(),\n  {\n    loading: false,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  loading?: (props: Record<string, never>) => any\n}>()\n\nconst loadingBoolean = useBooleanish(() => props.loading)\n</script>\n","<template>\n  <div\n    class=\"progress-bar\"\n    :class=\"computedClasses\"\n    role=\"progressbar\"\n    :aria-valuenow=\"value\"\n    aria-valuemin=\"0\"\n    :aria-valuemax=\"max\"\n    :style=\"{width: computedWidth}\"\n  >\n    <slot>\n      {{ computedLabel }}\n    </slot>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish, ColorVariant} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {computed, inject} from 'vue'\nimport {progressInjectionKey} from '../../utils'\n\nconst props = withDefaults(\n  defineProps<{\n    animated?: Booleanish\n    label?: string\n    labelHtml?: string\n    max?: string | number\n    precision?: string | number\n    showProgress?: Booleanish\n    showValue?: Booleanish\n    striped?: Booleanish\n    value?: string | number\n    variant?: ColorVariant | null\n  }>(),\n  {\n    label: undefined,\n    labelHtml: undefined,\n    max: undefined,\n    variant: null,\n    animated: false,\n    precision: 0,\n    showProgress: false,\n    showValue: false,\n    striped: false,\n    value: 0,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst parentData = inject(progressInjectionKey, null)\n\nconst animatedBoolean = useBooleanish(() => props.animated)\nconst showProgressBoolean = useBooleanish(() => props.showProgress)\nconst showValueBoolean = useBooleanish(() => props.showValue)\nconst stripedBoolean = useBooleanish(() => props.striped)\n\nconst computedClasses = computed(() => ({\n  'progress-bar-animated': animatedBoolean.value || parentData?.animated.value,\n  'progress-bar-striped':\n    stripedBoolean.value ||\n    parentData?.striped.value ||\n    animatedBoolean.value ||\n    parentData?.animated.value,\n  [`bg-${props.variant}`]: props.variant !== null,\n}))\n\nconst numberPrecision = computed<number>(() =>\n  typeof props.precision === 'number' ? props.precision : Number.parseFloat(props.precision)\n)\n\nconst numberValue = computed<number>(() =>\n  typeof props.value === 'number' ? props.value : Number.parseFloat(props.value)\n)\n\nconst numberMax = computed<number | undefined>(() =>\n  typeof props.max === 'number'\n    ? props.max\n    : props.max === undefined\n    ? undefined\n    : Number.parseFloat(props.max)\n)\n\nconst computedLabel = computed<string>(() =>\n  props.labelHtml !== undefined\n    ? props.labelHtml\n    : showValueBoolean.value || parentData?.showValue.value\n    ? numberValue.value.toFixed(numberPrecision.value)\n    : showProgressBoolean.value || parentData?.showProgress.value\n    ? ((numberValue.value * 100) / (numberMax.value || 100)).toFixed(numberPrecision.value)\n    : props.label !== undefined\n    ? props.label\n    : ''\n)\n\nconst computedWidth = computed<string>(() =>\n  parentData?.max.value\n    ? `${\n        (numberValue.value * 100) /\n        (typeof parentData.max.value === 'number'\n          ? parentData.max.value\n          : Number.parseInt(parentData.max.value))\n      }%`\n    : props.max\n    ? `${\n        (numberValue.value * 100) /\n        (typeof props.max === 'number' ? props.max : Number.parseInt(props.max))\n      }%`\n    : typeof props.value === 'string'\n    ? props.value\n    : `${props.value}%`\n)\n</script>\n","<template>\n  <div class=\"progress\" :style=\"{height}\">\n    <slot>\n      <BProgressBar v-bind=\"computedAttrs\" />\n    </slot>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport BProgressBar from './BProgressBar.vue'\nimport type {Booleanish, ColorVariant} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {computed, provide, readonly, toRef} from 'vue'\nimport {progressInjectionKey} from '../../utils'\n\nconst props = withDefaults(\n  defineProps<{\n    variant?: ColorVariant | null\n    max?: number | string\n    height?: string\n    animated?: Booleanish\n    precision?: number | string\n    showProgress?: Booleanish\n    showValue?: Booleanish\n    striped?: Booleanish\n    value?: number | string\n  }>(),\n  {\n    variant: undefined,\n    max: 100,\n    height: undefined,\n    animated: false,\n    precision: 0,\n    showProgress: false,\n    showValue: false,\n    striped: false,\n    value: 0,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst animatedBoolean = useBooleanish(() => props.animated)\nconst showProgressBoolean = useBooleanish(() => props.showProgress)\nconst showValueBoolean = useBooleanish(() => props.showValue)\nconst stripedBoolean = useBooleanish(() => props.striped)\n\nconst computedAttrs = computed(() => ({\n  animated: props.animated,\n  max: props.max,\n  precision: props.precision,\n  showProgress: props.showProgress,\n  showValue: props.showValue,\n  striped: props.striped,\n  value: props.value,\n  variant: props.variant,\n}))\n\nprovide(progressInjectionKey, {\n  animated: animatedBoolean,\n  max: readonly(toRef(props, 'max')),\n  showProgress: showProgressBoolean,\n  showValue: showValueBoolean,\n  striped: stripedBoolean,\n})\n</script>\n","<template>\n  <component :is=\"tag\" class=\"row\" :class=\"computedClasses\">\n    <slot />\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport {computed, defineComponent, type PropType, type SlotsType} from 'vue'\nimport {getBreakpointProps, getClasses} from '../utils'\nimport type {\n  AlignmentContent,\n  AlignmentJustifyContent,\n  AlignmentVertical,\n  Booleanish,\n} from '../types'\nimport {useAlignment, useBooleanish} from '../composables'\n\nconst rowColsProps = getBreakpointProps('cols', [''], {type: [String, Number], default: null})\n\nexport default defineComponent({\n  name: 'BRow',\n  slots: Object as SlotsType<{\n    default?: Record<string, never>\n  }>,\n  props: {\n    tag: {type: String, default: 'div'},\n    gutterX: {type: String, default: null},\n    gutterY: {type: String, default: null},\n    noGutters: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    alignV: {type: String as PropType<AlignmentVertical>, default: null},\n    alignH: {type: String as PropType<AlignmentJustifyContent>, default: null},\n    alignContent: {type: String as PropType<AlignmentContent>, default: null},\n    ...rowColsProps,\n  },\n  setup(props) {\n    const noGuttersBoolean = useBooleanish(() => props.noGutters)\n    const alignment = useAlignment(() => props.alignH)\n\n    const rowColsClasses = computed(() => getClasses(props, rowColsProps, 'cols', 'row-cols'))\n\n    const computedClasses = computed(() => [\n      rowColsClasses.value,\n      {\n        [`gx-${props.gutterX}`]: props.gutterX !== null,\n        [`gy-${props.gutterY}`]: props.gutterY !== null,\n        'g-0': noGuttersBoolean.value,\n        [`align-items-${props.alignV}`]: props.alignV !== null,\n        [alignment.value]: props.alignH !== null,\n        [`align-content-${props.alignContent}`]: props.alignContent !== null,\n      },\n    ])\n\n    return {\n      computedClasses,\n    }\n  },\n})\n</script>\n","import {closest, getAttr, getById, matches, select} from '../../../utils/dom'\n\nconst TABLE_TAG_NAMES = ['TD', 'TH', 'TR']\n\n// Filter CSS selector for click/dblclick/etc. events\n// If any of these selectors match the clicked element, we ignore the event\nexport const EVENT_FILTER = [\n  'a',\n  'a *', // Include content inside links\n  'button',\n  'button *', // Include content inside buttons\n  'input:not(.disabled):not([disabled])',\n  'select:not(.disabled):not([disabled])',\n  'textarea:not(.disabled):not([disabled])',\n  '[role=\"link\"]',\n  '[role=\"link\"] *',\n  '[role=\"button\"]',\n  '[role=\"button\"] *',\n  '[tabindex]:not(.disabled):not([disabled])',\n].join(',')\n\n// Returns `true` if we should ignore the click/double-click/keypress event\n// Avoids having the user need to use `@click.stop` on the form control\nexport const filterEvent = (event: Event) => {\n  // Exit early when we don't have a target element\n  if (!event || !event.target) {\n    return false\n  }\n  const el = event.target as HTMLElement\n  // Exit early when element is disabled or a table element\n  if (('disabled' in el && (el as any).disabled) || TABLE_TAG_NAMES.indexOf(el.tagName) !== -1) {\n    return false\n  }\n  // Ignore the click when it was inside a dropdown menu\n  if (closest('.dropdown-menu', el)) {\n    return true\n  }\n  const label = el.tagName === 'LABEL' ? el : closest('label', el)\n  // If the label's form control is not disabled then we don't propagate event\n  // Modern browsers have `label.control` that references the associated input, but IE 11\n  // does not have this property on the label element, so we resort to DOM lookups\n  if (label) {\n    const labelFor = getAttr(label, 'for')\n    const input = labelFor ? getById(labelFor) : select('input, select, textarea', label)\n    if (input && !input.disabled) {\n      return true\n    }\n  }\n  // Otherwise check if the event target matches one of the selectors in the\n  // event filter (i.e. anchors, non disabled inputs, etc.)\n  // Return `true` if we should ignore the event\n  return matches(el, EVENT_FILTER)\n}\n","import {ref, type Ref} from 'vue'\nimport type {BTableSortCompare, TableField, TableFieldObject, TableItem} from '../../types'\nimport {isObject, startCase} from '../../utils'\nimport {cloneDeep, cloneDeepAsync} from '../../utils/object'\n\nexport default () => {\n  const normaliseFields = (origFields: TableField[], items: TableItem[]): TableFieldObject[] => {\n    const fields: TableFieldObject[] = []\n\n    if (!origFields?.length && items?.length) {\n      Object.keys(items[0]).forEach((k) => fields.push({key: k, label: startCase(k)}))\n      return fields\n    }\n\n    if (Array.isArray(origFields)) {\n      origFields.forEach((f) => {\n        if (typeof f === 'string') {\n          fields.push({key: f, label: startCase(f)})\n        } else if (isObject(f) && f.key && typeof f.key === 'string') {\n          fields.push({...f})\n        }\n        // todo handle Shortcut object (i.e. { 'foo_bar': 'This is Foo Bar' }\n      })\n      return fields\n    }\n    return fields\n  }\n\n  const internalItems = ref<TableItem[]>([])\n\n  const mapItems = (\n    fields: TableField[],\n    items: TableItem[],\n    props: any,\n    flags: Record<string, Ref<boolean>>\n  ): TableItem[] => {\n    internalItems.value = cloneDeep(items)\n    if ('isFilterableTable' in flags && flags.isFilterableTable.value === true && props.filter) {\n      internalItems.value = filterItems(internalItems.value, props.filter, props.filterable)\n      // if (filterEvent.value) {\n      //   filterEvent.value(internalItems.value)\n      // }\n    }\n    if ('isSortable' in flags && flags.isSortable.value === true) {\n      internalItems.value = sortItems(\n        fields,\n        internalItems.value,\n        {\n          key: props.sortBy,\n          desc: flags.sortDescBoolean.value,\n        },\n        props.sortCompare\n      )\n    }\n    // if (props.perPage !== undefined) {\n    //   const startIndex = (props.currentPage - 1) * props.perPage\n    //   internalItems.value = internalItems.value.splice(startIndex, props.perPage)\n    // }\n    return internalItems.value\n  }\n\n  const filterEvent: Ref<((items: TableItem[]) => void) | undefined> = ref(undefined)\n\n  const sortItems = (\n    fields: TableField[],\n    items: TableItem<Record<string, any>>[],\n    sort: {key: string; desc: boolean},\n    sorter?: BTableSortCompare\n  ) => {\n    if (!sort || !sort.key) return items\n    const sortKey = sort.key\n    return items.sort((a, b) => {\n      if (sorter !== undefined) {\n        return sorter(a, b, sort.key, sort.desc)\n      }\n      const realVal = (ob: any) => (typeof ob === 'object' ? JSON.stringify(ob) : ob)\n      const aHigher = realVal(a[sortKey]) > realVal(b[sortKey])\n      if (aHigher) {\n        return sort.desc ? -1 : 1\n      }\n      const bHigher = realVal(b[sortKey]) > realVal(a[sortKey])\n      if (bHigher) {\n        return sort.desc ? 1 : -1\n      }\n      return 0\n    })\n  }\n\n  const filterItems = (\n    items: TableItem<Record<string, any>>[],\n    filter: string,\n    filterable: string[]\n  ) =>\n    items.filter(\n      (item) =>\n        Object.entries(item).filter((item) => {\n          const [key, val] = item\n          if (!val || key[0] === '_' || (filterable.length > 0 && !filterable.includes(key)))\n            return false\n          const itemValue: string =\n            typeof val === 'object'\n              ? JSON.stringify(Object.values(val))\n              : typeof val === 'string'\n              ? val\n              : val.toString()\n          return itemValue.toLowerCase().includes(filter.toLowerCase())\n        }).length > 0\n    )\n\n  const updateInternalItems = async (\n    items: TableItem<Record<string, any>>[]\n  ): Promise<TableItem[] | undefined> => {\n    try {\n      internalItems.value = await cloneDeepAsync(items)\n      return internalItems.value\n    } catch (err) {\n      return undefined\n    }\n  }\n\n  const notifyFilteredItems = () => {\n    if (filterEvent.value) {\n      filterEvent.value(internalItems.value)\n    }\n  }\n\n  const formatItem = (item: TableItem, fields: TableFieldObject) => {\n    const value = item[fields.key]\n    if (fields.formatter && typeof fields.formatter === 'function') {\n      return fields.formatter(value, fields.key, item)\n    }\n    return item[fields.key]\n  }\n\n  return {\n    normaliseFields,\n    mapItems,\n    internalItems,\n    updateInternalItems,\n    filterEvent,\n    notifyFilteredItems,\n    formatItem,\n  }\n}\n","<template>\n  <BTableSimple v-bind=\"containerAttrs\">\n    <!-- <table :class=\"classes\"> -->\n    <thead>\n      <slot v-if=\"$slots['thead-top']\" name=\"thead-top\" />\n      <tr>\n        <th\n          v-if=\"addSelectableCell\"\n          class=\"b-table-selection-column\"\n          :class=\"{\n            'b-table-sticky-column': stickySelectBoolean,\n          }\"\n        >\n          <slot name=\"select-head\">\n            {{ typeof selectHead === 'boolean' ? 'Selected' : selectHead }}\n          </slot>\n        </th>\n        <th\n          v-for=\"field in computedFields\"\n          :key=\"field.key\"\n          scope=\"col\"\n          :class=\"getFieldColumnClasses(field)\"\n          :title=\"field.headerTitle\"\n          :abbr=\"field.headerAbbr\"\n          :style=\"field.thStyle\"\n          v-bind=\"field.thAttr\"\n          @click=\"headerClicked(field, $event)\"\n        >\n          <div class=\"d-inline-flex flex-nowrap align-items-center gap-1\">\n            <slot\n              name=\"sort-icon\"\n              :field=\"field\"\n              :sort-by=\"sortBy\"\n              :selected=\"field.key === sortBy\"\n              :is-desc=\"sortDescBoolean\"\n              :direction=\"sortDescBoolean ? 'desc' : 'asc'\"\n            >\n              <span\n                v-if=\"isSortable && field.sortable\"\n                class=\"b-table-sort-icon\"\n                :class=\"{\n                  sorted: field.key === sortBy,\n                  [`sorted-${sortDescBoolean ? 'desc' : 'asc'}`]: field.key === sortBy,\n                }\"\n              />\n            </slot>\n            <div>\n              <slot\n                v-if=\"$slots['head(' + field.key + ')'] || $slots['head()']\"\n                :name=\"$slots['head(' + field.key + ')'] ? 'head(' + field.key + ')' : 'head()'\"\n                :label=\"field.label\"\n                :column=\"field.key\"\n                :field=\"field\"\n                :is-foot=\"false\"\n                :select-all-rows=\"selectAllRows\"\n                :clear-selected=\"clearSelected\"\n              />\n              <template v-else>{{ getFieldHeadLabel(field) }}</template>\n            </div>\n          </div>\n        </th>\n      </tr>\n      <tr v-if=\"$slots['thead-sub']\">\n        <td\n          v-for=\"field in computedFields\"\n          :key=\"field.key\"\n          scope=\"col\"\n          :class=\"[field.class, field.thClass, field.variant ? `table-${field.variant}` : '']\"\n        >\n          <slot\n            v-if=\"$slots['thead-sub']\"\n            name=\"thead-sub\"\n            :items=\"computedFields\"\n            v-bind=\"field\"\n          />\n          <template v-else>{{ field.label }}</template>\n        </td>\n      </tr>\n    </thead>\n    <tbody>\n      <template v-for=\"(item, itemIndex) in computedItems\" :key=\"itemIndex\">\n        <tr\n          :class=\"getRowClasses(item)\"\n          @click=\"!filterEvent($event) && onRowClick(item, itemIndex, $event)\"\n          @dblclick=\"!filterEvent($event) && onRowDblClick(item, itemIndex, $event)\"\n          @mouseenter=\"!filterEvent($event) && onRowMouseEnter(item, itemIndex, $event)\"\n          @mouseleave=\"!filterEvent($event) && onRowMouseLeave(item, itemIndex, $event)\"\n        >\n          <td\n            v-if=\"addSelectableCell\"\n            class=\"b-table-selection-column\"\n            :class=\"{\n              'b-table-sticky-column': stickySelectBoolean,\n            }\"\n          >\n            <slot name=\"select-cell\">\n              <span :class=\"selectedItems.has(item) ? 'text-primary' : ''\">ð¹</span>\n            </slot>\n          </td>\n          <td\n            v-for=\"field in computedFields\"\n            :key=\"field.key\"\n            v-bind=\"field.tdAttr\"\n            :class=\"getFieldRowClasses(field, item)\"\n          >\n            <label v-if=\"stacked && labelStackedBoolean\" class=\"b-table-stacked-label\">{{\n              getFieldHeadLabel(field)\n            }}</label>\n            <slot\n              v-if=\"$slots['cell(' + field.key + ')'] || $slots['cell()']\"\n              :name=\"$slots['cell(' + field.key + ')'] ? 'cell(' + field.key + ')' : 'cell()'\"\n              :value=\"item[field.key]\"\n              :index=\"itemIndex\"\n              :item=\"item\"\n              :field=\"field\"\n              :items=\"items\"\n              :toggle-details=\"() => toggleRowDetails(item)\"\n              :details-showing=\"item._showDetails\"\n            />\n            <template v-else>{{ itemHelper.formatItem(item, field) }}</template>\n          </td>\n        </tr>\n\n        <tr v-if=\"item._showDetails === true && $slots['row-details']\" :class=\"getRowClasses(item)\">\n          <td :colspan=\"computedFieldsTotal\">\n            <slot name=\"row-details\" :item=\"item\" :toggle-details=\"() => toggleRowDetails(item)\" />\n          </td>\n        </tr>\n      </template>\n      <tr\n        v-if=\"busyBoolean\"\n        class=\"b-table-busy-slot\"\n        :class=\"{'b-table-static-busy': computedItems.length === 0}\"\n      >\n        <td :colspan=\"computedFieldsTotal\">\n          <slot name=\"table-busy\">\n            <div class=\"d-flex align-items-center justify-content-center gap-2\">\n              <BSpinner class=\"align-middle\" />\n              <strong>Loading...</strong>\n            </div>\n          </slot>\n        </td>\n      </tr>\n      <tr v-if=\"showEmptyBoolean && computedItems.length === 0\" class=\"b-table-empty-slot\">\n        <td :colspan=\"computedFieldsTotal\">\n          <slot name=\"empty\" :items=\"computedItems\" :filtered=\"isFilterableTable\">\n            {{ isFilterableTable ? emptyFilteredText : emptyText }}\n          </slot>\n        </td>\n      </tr>\n    </tbody>\n    <tfoot v-if=\"footCloneBoolean\">\n      <tr>\n        <th\n          v-for=\"field in computedFields\"\n          :key=\"field.key\"\n          v-bind=\"field.thAttr\"\n          scope=\"col\"\n          :class=\"[field.class, field.thClass, field.variant ? `table-${field.variant}` : '']\"\n          :title=\"field.headerTitle\"\n          :abbr=\"field.headerAbbr\"\n          :style=\"field.thStyle\"\n          @click=\"headerClicked(field, $event, true)\"\n        >\n          {{ field.label }}\n        </th>\n      </tr>\n    </tfoot>\n    <tfoot v-else-if=\"$slots['custom-foot']\">\n      <slot\n        name=\"custom-foot\"\n        :fields=\"computedFields\"\n        :items=\"items\"\n        :columns=\"computedFields?.length\"\n      />\n    </tfoot>\n    <caption v-if=\"$slots['table-caption']\">\n      <slot name=\"table-caption\" />\n    </caption>\n    <caption v-else-if=\"caption\">\n      {{\n        caption\n      }}\n    </caption>\n    <!-- </table> -->\n  </BTableSimple>\n</template>\n\n<script setup lang=\"ts\">\n// import type {Breakpoint} from '../../types'\nimport {computed, onMounted, ref, useSlots, watch} from 'vue'\nimport {useBooleanish} from '../../composables'\nimport {cloneDeepAsync} from '../../utils/object'\nimport {titleCase} from '../../utils/stringUtils'\nimport BSpinner from '../BSpinner.vue'\nimport type {\n  Booleanish,\n  Breakpoint,\n  BTableProvider,\n  BTableSortCompare,\n  ColorVariant,\n  TableField,\n  TableFieldObject,\n  TableItem,\n  VerticalAlign,\n} from '../../types'\nimport BTableSimple from './BTableSimple.vue'\nimport {filterEvent} from './helpers/filter-event'\nimport useItemHelper from './itemHelper'\nimport {useVModel} from '@vueuse/core'\n\ntype NoProviderTypes = 'paging' | 'sorting' | 'filtering'\n\nconst props = withDefaults(\n  defineProps<{\n    align?: VerticalAlign\n    caption?: string\n    captionTop?: Booleanish\n    borderless?: Booleanish\n    bordered?: Booleanish\n    borderVariant?: ColorVariant | null\n    dark?: Booleanish\n    fields?: TableField[]\n    footClone?: Booleanish\n    hover?: Booleanish\n    items?: TableItem[]\n    provider?: BTableProvider\n    sortCompare?: BTableSortCompare\n    noProvider?: NoProviderTypes[]\n    noProviderPaging?: Booleanish\n    noProviderSorting?: Booleanish\n    noProviderFiltering?: Booleanish\n    responsive?: boolean | Breakpoint\n    small?: Booleanish\n    striped?: Booleanish\n    stacked?: boolean | Breakpoint\n    labelStacked?: boolean\n    variant?: ColorVariant | null\n    sortBy?: string\n    sortDesc?: Booleanish\n    sortInternal?: Booleanish\n    selectable?: Booleanish\n    stickySelect?: Booleanish\n    selectHead?: boolean | string\n    selectMode?: 'multi' | 'single' | 'range'\n    selectionVariant?: ColorVariant | null\n    stickyHeader?: Booleanish\n    busy?: Booleanish\n    showEmpty?: Booleanish\n    perPage?: number\n    currentPage?: number\n    filter?: string\n    filterable?: string[]\n    emptyText?: string\n    emptyFilteredText?: string\n  }>(),\n  {\n    perPage: undefined,\n    sortBy: undefined,\n    variant: undefined,\n    borderVariant: undefined,\n    caption: undefined,\n    align: undefined,\n    filter: undefined,\n    filterable: undefined,\n    provider: undefined,\n    sortCompare: undefined,\n    noProvider: undefined,\n    noProviderPaging: undefined,\n    noProviderSorting: undefined,\n    noProviderFiltering: undefined,\n    captionTop: false,\n    borderless: false,\n    bordered: false,\n    dark: false,\n    fields: () => [],\n    footClone: false,\n    hover: false,\n    items: () => [],\n    responsive: false,\n    small: false,\n    striped: false,\n    labelStacked: false,\n    stacked: false,\n    sortDesc: false,\n    sortInternal: true,\n    selectable: false,\n    stickySelect: false,\n    selectHead: true,\n    selectMode: 'single',\n    selectionVariant: 'primary',\n    stickyHeader: false,\n    busy: false,\n    showEmpty: false,\n    currentPage: 1,\n    emptyText: 'There are no records to show',\n    emptyFilteredText: 'There are no records matching your request',\n  }\n)\n\nconst emit = defineEmits<{\n  'headClicked': [\n    key: TableFieldObject['key'],\n    field: TableField,\n    event: MouseEvent,\n    isFooter: boolean\n  ]\n  'rowClicked': [item: TableItem, index: number, event: MouseEvent]\n  'rowDblClicked': [item: TableItem, index: number, event: MouseEvent]\n  'rowHovered': [item: TableItem, index: number, event: MouseEvent]\n  'rowUnhovered': [item: TableItem, index: number, event: MouseEvent]\n  'rowSelected': [value: TableItem]\n  'rowUnselected': [value: TableItem]\n  'selection': [value: TableItem[]]\n  'update:busy': [value: boolean]\n  'update:sortBy': [value: string]\n  'update:sortDesc': [value: boolean]\n  'sorted': [sortBy: string, isDesc: boolean]\n  'filtered': [value: TableItem[]]\n}>()\n\nconst sortByModel = useVModel(props, 'sortBy', emit)\nconst busyModel = useVModel(props, 'busy', emit, {passive: true})\nconst sortDescModel = useVModel(props, 'sortDesc', emit, {passive: true})\n\nconst slots = useSlots()\n\nconst itemHelper = useItemHelper()\n\nconst footCloneBoolean = useBooleanish(() => props.footClone)\nconst sortDescBoolean = useBooleanish(sortDescModel)\nconst sortInternalBoolean = useBooleanish(() => props.sortInternal)\nconst selectableBoolean = useBooleanish(() => props.selectable)\nconst stickySelectBoolean = useBooleanish(() => props.stickySelect)\nconst labelStackedBoolean = useBooleanish(() => props.labelStacked)\nconst busyBoolean = useBooleanish(busyModel)\nconst showEmptyBoolean = useBooleanish(() => props.showEmpty)\nconst noProviderPagingBoolean = useBooleanish(() => props.noProviderPaging)\nconst noProviderSortingBoolean = useBooleanish(() => props.noProviderSorting)\nconst noProviderFilteringBoolean = useBooleanish(() => props.noProviderFiltering)\n\nitemHelper.filterEvent.value = async (items) => {\n  if (usesProvider.value) {\n    await callItemsProvider()\n    return\n  }\n  const clone = await cloneDeepAsync(items)\n  emit('filtered', clone)\n}\n\nconst selectedItems = ref<Set<TableItem>>(new Set([]))\nconst isSelecting = computed(() => selectedItems.value.size > 0)\n\nconst tableClasses = computed(() => ({\n  [`align-${props.align}`]: props.align !== undefined,\n  'b-table-selectable': selectableBoolean.value,\n  [`b-table-select-${props.selectMode}`]: selectableBoolean.value,\n  'b-table-selecting user-select-none': selectableBoolean.value && isSelecting.value,\n  'b-table-busy': busyBoolean.value,\n  'b-table-sortable': isSortable.value,\n  'b-table-sort-desc': isSortable.value && sortDescBoolean.value === true,\n  'b-table-sort-asc': isSortable.value && sortDescBoolean.value === false,\n}))\n\nconst containerAttrs = computed(() => ({\n  bordered: props.bordered,\n  borderless: props.borderless,\n  borderVariant: props.borderVariant,\n  captionTop: props.captionTop,\n  dark: props.dark,\n  hover: props.hover,\n  responsive: props.responsive,\n  striped: props.striped,\n  stacked: props.stacked,\n  small: props.small,\n  tableClass: tableClasses.value,\n  tableVariant: props.variant,\n  stickyHeader: props.stickyHeader,\n}))\n\nconst computedFields = computed(() => itemHelper.normaliseFields(props.fields, props.items))\nconst computedFieldsTotal = computed(\n  () => computedFields.value.length + (selectableBoolean.value ? 1 : 0)\n)\n\nconst isFilterableTable = computed(() => props.filter !== undefined && props.filter !== '')\nconst usesProvider = computed(() => props.provider !== undefined)\n\nconst addSelectableCell = computed(\n  () => selectableBoolean.value && (!!props.selectHead || slots.selectHead !== undefined)\n)\n\nconst isSortable = computed(\n  () =>\n    props.fields.filter((field) => (typeof field === 'string' ? false : field.sortable)).length > 0\n)\n\nconst requireItemsMapping = computed(() => isSortable.value && sortInternalBoolean.value === true)\nconst computedItems = computed(() => {\n  const items = usesProvider.value\n    ? itemHelper.internalItems.value\n    : requireItemsMapping.value\n    ? itemHelper.mapItems(props.fields, props.items, props, {\n        isSortable,\n        isFilterableTable,\n        sortDescBoolean,\n      })\n    : props.items\n\n  if (usesProvider.value && !noProviderPagingBoolean.value) {\n    return items\n  }\n\n  if (props.perPage !== undefined) {\n    const startIndex = (props.currentPage - 1) * props.perPage\n    const endIndex =\n      startIndex + props.perPage > items.length ? items.length : startIndex + props.perPage\n    return items.slice(startIndex, endIndex)\n  }\n  return items\n})\n\nconst getFieldHeadLabel = (field: TableField) => {\n  if (typeof field === 'string') return titleCase(field)\n  if (field.label !== undefined) return field.label\n  if (typeof field.key === 'string') return titleCase(field.key)\n  return field.key\n}\n\nconst headerClicked = (field: TableField, event: MouseEvent, isFooter = false) => {\n  const fieldKey = typeof field === 'string' ? field : field.key\n  emit('headClicked', fieldKey, field, event, isFooter)\n\n  handleFieldSorting(field)\n}\n\nconst onRowClick = (row: TableItem, index: number, e: MouseEvent) => {\n  emit('rowClicked', row, index, e)\n\n  handleRowSelection(row, index, e.shiftKey, e.ctrlKey, e.metaKey)\n}\nconst onRowDblClick = (row: TableItem, index: number, e: MouseEvent) =>\n  emit('rowDblClicked', row, index, e)\n\nconst onRowMouseEnter = (row: TableItem, index: number, e: MouseEvent) =>\n  emit('rowHovered', row, index, e)\n\nconst onRowMouseLeave = (row: TableItem, index: number, e: MouseEvent) =>\n  emit('rowUnhovered', row, index, e)\n\nconst handleFieldSorting = (field: TableField) => {\n  if (!isSortable.value) return\n\n  const fieldKey = typeof field === 'string' ? field : field.key\n  const fieldSortable = typeof field === 'string' ? false : field.sortable\n  if (isSortable.value === true && fieldSortable === true) {\n    const sortDesc = !sortDescBoolean.value\n    if (fieldKey !== props.sortBy) {\n      sortByModel.value = fieldKey\n    }\n    sortDescModel.value = sortDesc\n    emit('sorted', fieldKey, sortDesc)\n  }\n}\n\nconst notifySelectionEvent = () => {\n  if (!selectableBoolean.value) return\n  emit('selection', Array.from(selectedItems.value))\n}\n\nconst handleRowSelection = (\n  row: TableItem,\n  index: number,\n  shiftClicked = false,\n  ctrlClicked = false,\n  metaClicked = false\n) => {\n  if (!selectableBoolean.value) return\n\n  if (shiftClicked && props.selectMode === 'range' && selectedItems.value.size > 0) {\n    const lastSelectedItem = Array.from(selectedItems.value).pop()\n    const lastSelectedIndex = computedItems.value.findIndex((i) => i === lastSelectedItem)\n    const selectStartIndex = Math.min(lastSelectedIndex, index)\n    const selectEndIndex = Math.max(lastSelectedIndex, index)\n    computedItems.value.slice(selectStartIndex, selectEndIndex + 1).forEach((item) => {\n      if (!selectedItems.value.has(item)) {\n        selectedItems.value.add(item)\n        emit('rowSelected', item)\n      }\n    })\n  } else if (ctrlClicked || metaClicked) {\n    if (selectedItems.value.has(row)) {\n      selectedItems.value.delete(row)\n      emit('rowUnselected', row)\n    } else if (props.selectMode === 'range' || props.selectMode === 'multi') {\n      selectedItems.value.add(row)\n      emit('rowSelected', row)\n    } else {\n      selectedItems.value.forEach((item) => emit('rowUnselected', item))\n      selectedItems.value.clear()\n      selectedItems.value.add(row)\n      emit('rowSelected', row)\n    }\n  } else {\n    selectedItems.value.forEach((item) => emit('rowUnselected', item))\n    selectedItems.value.clear()\n    selectedItems.value.add(row)\n    emit('rowSelected', row)\n  }\n\n  notifySelectionEvent()\n}\n\nconst callItemsProvider = async () => {\n  if (!usesProvider.value || !props.provider || busyBoolean.value) return\n  busyModel.value = true\n  const context = new Proxy(\n    {\n      currentPage: props.currentPage,\n      filter: props.filter,\n      sortBy: props.sortBy,\n      sortDesc: props.sortDesc,\n      perPage: props.perPage,\n    },\n    {\n      get: (target: any, prop) => (prop in target ? target[prop] : undefined),\n      set: () => {\n        // eslint-disable-next-line no-console\n        console.error('BTable provider context is a read-only object.')\n        return true\n      },\n    }\n  )\n  const response = props.provider(context, itemHelper.updateInternalItems)\n  if (response === undefined) return\n  if (response instanceof Promise) {\n    try {\n      const items = await response\n      if (!Array.isArray(items)) return\n      const internalItems = await itemHelper.updateInternalItems(items)\n      return internalItems\n    } finally {\n      if (busyBoolean.value) {\n        busyModel.value = false\n      }\n    }\n  }\n\n  try {\n    const internalItems = await itemHelper.updateInternalItems(response)\n    return internalItems\n  } finally {\n    if (busyBoolean.value) {\n      busyModel.value = false\n    }\n  }\n}\n\nconst toggleRowDetails = (tr: TableItem) => {\n  tr._showDetails = !tr._showDetails\n}\n\nconst getFieldColumnClasses = (field: TableFieldObject) => [\n  field.class,\n  field.thClass,\n  {\n    [`table-${field.variant}`]: field.variant !== null,\n    'b-table-sortable-column': isSortable.value && field.sortable,\n    'b-table-sticky-column': field.stickyColumn,\n  },\n]\n\nconst getFieldRowClasses = (field: TableFieldObject, tr: TableItem) => [\n  field.class,\n  field.tdClass,\n  tr?._cellVariants && tr?._cellVariants[field.key]\n    ? `table-${tr?._cellVariants[field.key]}`\n    : undefined,\n  {\n    [`table-${field.variant}`]: field.variant !== null,\n    'b-table-sticky-column': field.stickyColumn,\n  },\n]\n\nconst getRowClasses = (item: TableItem) => [\n  item._rowVariant ? `table-${item._rowVariant}` : null,\n  item._rowVariant ? `table-${item._rowVariant}` : null,\n  selectableBoolean.value && selectedItems.value.has(item)\n    ? `selected table-${props.selectionVariant}`\n    : null,\n]\n\nconst selectAllRows = () => {\n  if (!selectableBoolean.value) return\n  const unselectableItems = selectedItems.value.size > 0 ? Array.from(selectedItems.value) : []\n  selectedItems.value = new Set([...computedItems.value])\n  selectedItems.value.forEach((item) => {\n    if (unselectableItems.includes(item)) return\n    emit('rowSelected', item)\n  })\n  notifySelectionEvent()\n}\n\nconst clearSelected = () => {\n  if (!selectableBoolean.value) return\n  selectedItems.value.forEach((item) => {\n    emit('rowUnselected', item)\n  })\n  selectedItems.value = new Set([])\n  notifySelectionEvent()\n}\n\nconst selectRow = (index: number) => {\n  if (!selectableBoolean.value) return\n  const item = computedItems.value[index]\n  if (!item || selectedItems.value.has(item)) return\n  selectedItems.value.add(item)\n  emit('rowSelected', item)\n  notifySelectionEvent()\n}\n\nconst unselectRow = (index: number) => {\n  if (!selectableBoolean.value) return\n  const item = computedItems.value[index]\n  if (!item || !selectedItems.value.has(item)) return\n  selectedItems.value.delete(item)\n  emit('rowUnselected', item)\n  notifySelectionEvent()\n}\n\nconst providerPropsWatch = async (prop: string, val: any, oldVal: any) => {\n  if (val === oldVal) return\n\n  //stop provide when paging\n  const inNoProvider = (key: NoProviderTypes) => props.noProvider && props.noProvider.includes(key)\n  const notifyFiltered = !['currentPage', 'perPage'].includes(prop)\n  const noProvideWhenPaging =\n    ['currentPage', 'perPage'].includes(prop) &&\n    (inNoProvider('paging') || noProviderPagingBoolean.value === true)\n  const noProvideWhenFiltering =\n    ['filter'].includes(prop) &&\n    (inNoProvider('filtering') || noProviderFilteringBoolean.value === true)\n  const noProvideWhenSorting =\n    ['sortBy', 'sortDesc'].includes(prop) &&\n    (inNoProvider('sorting') || noProviderSortingBoolean.value === true)\n\n  if (noProvideWhenPaging || noProvideWhenFiltering || noProvideWhenSorting) {\n    return\n  }\n\n  await callItemsProvider()\n\n  if (notifyFiltered) itemHelper.notifyFilteredItems()\n}\n\nwatch(\n  () => props.filter,\n  (filter, oldFilter) => {\n    if (filter === oldFilter || usesProvider.value) return\n    if (!filter) {\n      cloneDeepAsync(props.items).then((item) => emit('filtered', item))\n    }\n  }\n)\n\nwatch(\n  () => props.filter,\n  (val, oldVal) => providerPropsWatch('filter', val, oldVal)\n)\nwatch(\n  () => props.currentPage,\n  (val, oldVal) => providerPropsWatch('currentPage', val, oldVal)\n)\nwatch(\n  () => props.perPage,\n  (val, oldVal) => providerPropsWatch('perPage', val, oldVal)\n)\nwatch(\n  () => props.sortBy,\n  (val, oldVal) => providerPropsWatch('sortBy', val, oldVal)\n)\nwatch(\n  () => props.sortDesc,\n  (val, oldVal) => providerPropsWatch('sortDesc', val, oldVal)\n)\n\nonMounted(() => {\n  if (usesProvider.value) {\n    callItemsProvider()\n  }\n})\n\ndefineExpose({\n  selectAllRows,\n  clearSelected,\n  selectRow,\n  unselectRow,\n  refresh: callItemsProvider,\n})\n</script>\n","<template>\n  <tbody :class=\"computedClasses\">\n    <slot />\n  </tbody>\n</template>\n\n<script setup lang=\"ts\">\nimport type {ColorVariant} from '../../types'\nimport {computed} from 'vue'\n\nconst props = withDefaults(\n  defineProps<{\n    variant?: ColorVariant | null\n  }>(),\n  {\n    variant: null,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => ({\n  [`thead-${props.variant}`]: props.variant !== null,\n}))\n</script>\n","<template>\n  <td\n    :scope=\"scope\"\n    :class=\"computedClasses\"\n    :colspan=\"colspan\"\n    :rowspan=\"rowspan\"\n    :data-label=\"stackedHeading\"\n  >\n    <div v-if=\"stackedHeading\">\n      <slot />\n    </div>\n    <slot v-else />\n  </td>\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish, ColorVariant} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {computed} from 'vue'\n\nconst props = withDefaults(\n  defineProps<{\n    colspan?: string | number\n    rowspan?: string | number\n    stackedHeading?: string\n    stickyColumn?: Booleanish\n    variant?: ColorVariant | null\n  }>(),\n  {\n    colspan: undefined,\n    variant: null,\n    rowspan: undefined,\n    stackedHeading: undefined,\n    stickyColumn: false,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst stickyColumnBoolean = useBooleanish(() => props.stickyColumn)\n\nconst computedClasses = computed(() => ({\n  [`table-${props.variant}`]: props.variant !== null,\n  'b-table-sticky-column': stickyColumnBoolean.value,\n  'table-b-table-default': stickyColumnBoolean.value && props.variant === null,\n}))\n\nconst scope = computed(() => (props.colspan ? 'colspan' : props.rowspan ? 'rowspan' : 'col'))\n</script>\n","<template>\n  <tfoot :class=\"computedClasses\">\n    <slot />\n  </tfoot>\n</template>\n\n<script setup lang=\"ts\">\nimport type {ColorVariant} from '../../types'\nimport {computed} from 'vue'\n\nconst props = withDefaults(\n  defineProps<{\n    variant?: ColorVariant | null\n  }>(),\n  {\n    variant: null,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => ({\n  [`table-${props.variant}`]: props.variant !== null,\n}))\n</script>\n","<template>\n  <th\n    :scope=\"scope\"\n    :class=\"computedClasses\"\n    :colspan=\"colspan\"\n    :rowspan=\"rowspan\"\n    :data-label=\"stackedHeading\"\n  >\n    <div v-if=\"stackedHeading !== undefined\">\n      <slot />\n    </div>\n    <slot v-else />\n  </th>\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish, ColorVariant} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {computed} from 'vue'\n\nconst props = withDefaults(\n  defineProps<{\n    colspan?: string | number\n    rowspan?: string | number\n    stackedHeading?: string\n    stickyColumn?: Booleanish\n    variant?: ColorVariant | null\n  }>(),\n  {\n    colspan: undefined,\n    rowspan: undefined,\n    variant: null,\n    stackedHeading: undefined,\n    stickyColumn: false,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst stickyColumnBoolean = useBooleanish(() => props.stickyColumn)\n\nconst computedClasses = computed(() => ({\n  [`table-${props.variant}`]: props.variant !== null,\n  'b-table-sticky-column': stickyColumnBoolean.value,\n  'table-b-table-default': stickyColumnBoolean.value && props.variant === null,\n}))\n\nconst scope = computed(() => (props.colspan ? 'colspan' : props.rowspan ? 'rowspan' : 'col'))\n</script>\n","<template>\n  <thead :class=\"computedClasses\">\n    <slot />\n  </thead>\n</template>\n\n<script setup lang=\"ts\">\nimport type {ColorVariant} from '../../types'\nimport {computed} from 'vue'\n\nconst props = withDefaults(\n  defineProps<{\n    variant?: ColorVariant | null\n  }>(),\n  {\n    variant: null,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => ({\n  [`table-${props.variant}`]: props.variant !== null,\n}))\n</script>\n","<template>\n  <tr :class=\"computedClasses\">\n    <slot />\n  </tr>\n</template>\n\n<script setup lang=\"ts\">\nimport type {ColorVariant} from '../../types'\nimport {computed} from 'vue'\n\nconst props = withDefaults(\n  defineProps<{\n    variant?: ColorVariant | null\n  }>(),\n  {\n    variant: null,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => ({\n  [`table-${props.variant}`]: props.variant !== null,\n}))\n</script>\n","<template>\n  <component\n    :is=\"tag\"\n    :id=\"id\"\n    class=\"tab-pane\"\n    :class=\"computedClasses\"\n    role=\"tabpanel\"\n    aria-labelledby=\"profile-tab\"\n  >\n    <slot v-if=\"showSlot\" />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, inject, ref, watch} from 'vue'\nimport {useBooleanish} from '../../composables'\nimport type {Booleanish, ClassValue} from '../../types'\nimport {tabsInjectionKey} from '../../utils'\n\nconst props = withDefaults(\n  defineProps<{\n    id?: string\n    title?: string\n    active?: Booleanish\n    buttonId?: string\n    disabled?: Booleanish\n    lazy?: Booleanish\n    lazyOnce?: Booleanish\n    noBody?: boolean | string\n    tag?: string\n    titleItemClass?: ClassValue\n    titleLinkAttributes?: Record<string, unknown>\n    titleLinkClass?: ClassValue\n  }>(),\n  {\n    titleItemClass: undefined,\n    titleLinkClass: undefined,\n    id: undefined,\n    title: undefined,\n    active: false,\n    // TODO this is unused - Compat issue\n    buttonId: undefined,\n    disabled: false,\n    lazy: undefined,\n    lazyOnce: undefined,\n    noBody: false,\n    tag: 'div',\n    titleLinkAttributes: undefined,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst parentData = inject(tabsInjectionKey, null)\n\nconst activeBoolean = useBooleanish(() => props.active)\nconst disabledBoolean = useBooleanish(() => props.disabled)\nconst lazyBoolean = useBooleanish(\n  computed(() => (props.lazyOnce !== undefined ? props.lazyOnce : props.lazy))\n)\n\nconst lazyRenderCompleted = ref(false)\n\nconst computedLazy = computed<boolean>(() => !!(parentData?.lazy.value || lazyBoolean.value))\nconst computedLazyOnce = computed<boolean>(() => props.lazyOnce !== undefined)\n\nconst computedActive = computed<boolean>(() => activeBoolean.value && !disabledBoolean.value)\nconst showSlot = computed<boolean>(() => {\n  const hasLazyRenderedOnce =\n    computedLazy.value && computedLazyOnce.value && lazyRenderCompleted.value\n  return computedActive.value || !computedLazy.value || hasLazyRenderedOnce\n})\nconst show = ref(activeBoolean.value)\nwatch(activeBoolean, (active) => {\n  setTimeout(() => {\n    show.value = active\n  }, 0)\n})\nconst computedClasses = computed(() => ({\n  'active': activeBoolean.value,\n  'show': show.value,\n  'card-body': parentData?.card.value && props.noBody === false,\n}))\n\nwatch(showSlot, (shown) => {\n  if (shown && !lazyRenderCompleted.value) lazyRenderCompleted.value = true\n})\n</script>\n","<template>\n  <component :is=\"tag\" :id=\"id\" class=\"tabs\" :class=\"computedClasses\">\n    <!-- Tab Content Above Tabs -->\n    <div v-if=\"endBoolean\" class=\"tab-content\" :class=\"contentClass\">\n      <component\n        :is=\"tabComponent()\"\n        v-for=\"({tabComponent, contentId, tabClasses, active}, i) in tabs\"\n        :id=\"contentId\"\n        :key=\"i\"\n        :class=\"tabClasses\"\n        :active=\"active\"\n      />\n      <div\n        v-if=\"showEmpty\"\n        key=\"bv-empty-tab\"\n        class=\"tab-pane active\"\n        :class=\"{'card-body': cardBoolean}\"\n      >\n        <slot name=\"empty\" />\n      </div>\n    </div>\n    <div\n      :class=\"[navWrapperClass, {'card-header': cardBoolean, 'ms-auto': vertical && endBoolean}]\"\n    >\n      <!-- Render Tabs -->\n      <ul class=\"nav\" :class=\"[navTabsClasses, navClass]\" role=\"tablist\">\n        <slot name=\"tabs-start\" />\n        <li\n          v-for=\"({tab, buttonId, contentId, navItemClasses, active, target}, idx) in tabs\"\n          :key=\"idx\"\n          class=\"nav-item\"\n          :class=\"tab?.props?.['title-item-class']\"\n          role=\"presentation\"\n        >\n          <button\n            :id=\"buttonId\"\n            class=\"nav-link\"\n            :class=\"navItemClasses\"\n            data-bs-toggle=\"tab\"\n            :data-bs-target=\"target\"\n            role=\"tab\"\n            :aria-controls=\"contentId\"\n            :aria-selected=\"active\"\n            v-bind=\"tab?.props?.['title-link-attributes']\"\n            @click.stop.prevent=\"(e) => handleClick(e, idx)\"\n          >\n            <component\n              :is=\"(tab.children as any).title\"\n              v-if=\"tab.children && (tab.children as any).title\"\n            />\n            <template v-else>\n              {{ tab?.props?.title }}\n            </template>\n          </button>\n        </li>\n        <slot name=\"tabs-end\" />\n      </ul>\n    </div>\n    <!-- Tab Content Below Tabs-->\n    <div v-if=\"!endBoolean\" class=\"tab-content\" :class=\"contentClass\">\n      <component\n        :is=\"tabComponent()\"\n        v-for=\"({tabComponent, contentId, tabClasses, active}, i) in tabs\"\n        :id=\"contentId\"\n        :key=\"i\"\n        :class=\"tabClasses\"\n        :active=\"active\"\n      />\n      <div\n        v-if=\"showEmpty\"\n        key=\"bv-empty-tab\"\n        class=\"tab-pane active\"\n        :class=\"{'card-body': cardBoolean}\"\n      >\n        <slot name=\"empty\" />\n      </div>\n    </div>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, onMounted, provide, ref, useSlots, type VNode, watch} from 'vue'\nimport {BvEvent, getId, getSlotElements, tabsInjectionKey} from '../../utils'\nimport {useAlignment, useBooleanish} from '../../composables'\nimport type {AlignmentJustifyContent, Booleanish, ClassValue} from '../../types'\nimport {useVModel} from '@vueuse/core'\n// TODO this component needs a desperate refactoring to use provide/inject and not the complicated slot manipulation logic it's doing now\n\nconst props = withDefaults(\n  defineProps<{\n    activeNavItemClass?: ClassValue\n    activeTabClass?: ClassValue\n    align?: AlignmentJustifyContent\n    contentClass?: ClassValue\n    card?: Booleanish\n    end?: Booleanish\n    fill?: Booleanish\n    id?: string\n    justified?: Booleanish\n    lazy?: Booleanish\n    navClass?: ClassValue\n    navWrapperClass?: ClassValue\n    noFade?: Booleanish\n    // noKeyNav?: Booleanish\n    noNavStyle?: Booleanish\n    pills?: Booleanish\n    small?: Booleanish\n    tag?: string\n    vertical?: Booleanish\n    modelValue?: number\n  }>(),\n  {\n    navClass: undefined,\n    navWrapperClass: undefined,\n    id: undefined,\n    activeNavItemClass: undefined,\n    activeTabClass: undefined,\n    align: undefined,\n    contentClass: undefined,\n    card: false,\n    end: false,\n    fill: false,\n    justified: false,\n    lazy: false,\n    noFade: false,\n    noNavStyle: false,\n    pills: false,\n    small: false,\n    tag: 'div',\n    vertical: false,\n    modelValue: -1,\n  }\n)\n\nconst emit = defineEmits<{\n  'update:modelValue': [value: number]\n  'activate-tab': [v1: number, v2: number, v3: BvEvent]\n  'click': [] // TODO click event is never used\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'tabs-start'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'empty'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'tabs-end'?: (props: Record<string, never>) => any\n}>()\n\nconst modelValue = useVModel(props, 'modelValue', emit)\n\nconst slots = useSlots()\n\nconst cardBoolean = useBooleanish(() => props.card)\nconst endBoolean = useBooleanish(() => props.end)\nconst fillBoolean = useBooleanish(() => props.fill)\nconst justifiedBoolean = useBooleanish(() => props.justified)\nconst lazyBoolean = useBooleanish(() => props.lazy)\nconst noFadeBoolean = useBooleanish(() => props.noFade)\nconst noNavStyleBoolean = useBooleanish(() => props.noNavStyle)\nconst pillsBoolean = useBooleanish(() => props.pills)\nconst smallBoolean = useBooleanish(() => props.small)\nconst verticalBoolean = useBooleanish(() => props.vertical)\n\nconst _tabIndex = ref(modelValue.value)\nconst _currentTabButton = ref('')\n\nconst tabIndex = computed({\n  get: () => _tabIndex.value,\n  set: (value: number) => {\n    _tabIndex.value = value\n    if (tabs.value.length > 0 && value >= 0 && value < tabs.value.length) {\n      _currentTabButton.value = tabs.value[value].buttonId\n    } else {\n      _currentTabButton.value = ''\n    }\n    modelValue.value = value\n  },\n})\nconst tabsInternal = ref<\n  {\n    buttonId: string\n    contentId: string\n    disabled: boolean\n    target: string\n    title: string\n    titleItemClass: ClassValue\n    titleLinkAttributes: Record<string, unknown>\n    onClick: (e: Event) => void\n    tab: VNode\n    tabComponent: () => VNode\n  }[]\n>([])\n\n// TODO simplify this! YOu cannot do things like nest BTab in a wrapper component!\nwatch(\n  () => slots.default?.(),\n  () => {\n    tabsInternal.value =\n      slots.default === undefined\n        ? []\n        : getSlotElements(slots.default, 'BTab').map((tab, idx) => {\n            if (!tab.props) tab.props = {}\n            const buttonId = tab.props['button-id'] || getId('tab')\n            const contentId = tab.props.id || getId()\n            const titleItemClass = tab.props['title-item-class']\n            const titleLinkAttributes = tab.props['title-link-attributes']\n\n            return {\n              buttonId,\n              contentId,\n              disabled: tab.props.disabled === '' || tab.props.disabled === true,\n              target: `#${contentId}`,\n              title: tab.props.title,\n              titleItemClass,\n              titleLinkAttributes,\n              onClick: tab.props.onClick,\n              tab,\n              tabComponent: () => getSlotElements(slots.default, 'BTab')[idx],\n            }\n          })\n  },\n  {immediate: true}\n)\n\nconst tabs = computed(() =>\n  tabsInternal.value.map((item, idx) => {\n    const {tab} = item\n    if (!tab.props) tab.props = {}\n    const active = tabIndex.value > -1 ? idx === tabIndex.value : tab.props.active === ''\n\n    return {\n      ...item,\n      active,\n      navItemClasses: [\n        {\n          active,\n          disabled: tab.props.disabled === '' || tab.props.disabled === true,\n        },\n        active && props.activeNavItemClass ? props.activeNavItemClass : null,\n        tab.props['title-link-class'],\n      ],\n      tabClasses: [\n        {\n          fade: !noFadeBoolean.value,\n        },\n        active && props.activeTabClass ? props.activeTabClass : null,\n      ],\n    }\n  })\n)\n\nconst showEmpty = computed(() => !(tabs?.value && tabs.value.length > 0))\n\nconst computedClasses = computed(() => ({\n  'd-flex': verticalBoolean.value,\n  'align-items-start': verticalBoolean.value,\n}))\n\nconst alignment = useAlignment(() => props.align)\n\nconst navTabsClasses = computed(() => ({\n  'nav-pills': pillsBoolean.value,\n  'flex-column me-3': verticalBoolean.value,\n  [alignment.value]: props.align !== undefined,\n  'nav-fill': fillBoolean.value,\n  'card-header-tabs': cardBoolean.value,\n  'nav-justified': justifiedBoolean.value,\n  'nav-tabs': !noNavStyleBoolean.value && !pillsBoolean.value,\n  'small': smallBoolean.value,\n}))\n\nconst activateTab = (index: number): boolean => {\n  let result = false\n  if (index !== undefined) {\n    if (\n      index > -1 &&\n      index < tabs.value.length &&\n      !tabs.value[index].disabled &&\n      (tabIndex.value < 0 || tabs.value[index].buttonId !== _currentTabButton.value)\n    ) {\n      const tabEvent = new BvEvent('activate-tab', {cancelable: true})\n      emit('activate-tab', index, tabIndex.value, tabEvent)\n      if (!tabEvent.defaultPrevented) {\n        tabIndex.value = index\n        result = true\n      }\n    }\n  }\n  if (!result && modelValue.value !== tabIndex.value) {\n    modelValue.value = tabIndex.value\n  }\n  return result\n}\n\nconst handleClick = (event: MouseEvent, index: number) => {\n  activateTab(index)\n  if (\n    index >= 0 &&\n    !tabs.value[index].disabled &&\n    tabs.value[index]?.onClick &&\n    typeof tabs.value[index].onClick === 'function'\n  ) {\n    tabs.value[index].onClick(event)\n  }\n}\n\nactivateTab(_tabIndex.value)\n\nwatch(modelValue, (newValue, oldValue) => {\n  if (newValue === oldValue) return\n  newValue = Math.max(newValue, -1)\n  oldValue = Math.max(oldValue, -1)\n\n  if (tabs.value.length <= 0) {\n    tabIndex.value = -1\n    return\n  }\n\n  const goForward = newValue > oldValue\n  let index = newValue\n  const maxIdx = tabs.value.length - 1\n  while (index >= 0 && index <= maxIdx && tabs.value[index].disabled) {\n    index += goForward ? 1 : -1\n  }\n\n  if (index < 0) {\n    activateTab(0)\n    return\n  }\n  if (index >= tabs.value.length) {\n    activateTab(tabs.value.length - 1)\n    return\n  }\n  activateTab(index)\n})\n\nwatch(tabs, () => {\n  // find last active tab\n  let activeTabIndex = tabs.value.map((tab) => tab.active && !tab.disabled).lastIndexOf(true)\n\n  if (activeTabIndex < 0) {\n    if (tabIndex.value >= tabs.value.length) {\n      // handle last tab removed, so find the last non-disabled tab\n      activeTabIndex = tabs.value.map((tab) => !tab.disabled).lastIndexOf(true)\n    } else {\n      if (tabs.value[tabIndex.value] && !tabs.value[tabIndex.value].disabled)\n        activeTabIndex = tabIndex.value\n    }\n  }\n  // still no active tab found, find first non-disabled tab\n  if (activeTabIndex < 0) {\n    activeTabIndex = tabs.value.map((tab) => !tab.disabled).indexOf(true)\n  }\n  // ensure only one tab active at a time\n  tabs.value.forEach((tab, idx) => {\n    tab.active = idx === activeTabIndex\n  })\n\n  activateTab(activeTabIndex)\n})\n\nonMounted(() => {\n  // If there are tabs available, make sure a tab is set active\n  if (tabIndex.value < 0 && tabs.value.length > 0 && !tabs.value.some((tab) => tab.active)) {\n    const firstTab = tabs.value.map((t) => !t.disabled).indexOf(true)\n    activateTab(firstTab >= 0 ? firstTab : -1)\n  }\n})\n\nprovide(tabsInjectionKey, {\n  lazy: lazyBoolean,\n  card: cardBoolean,\n})\n</script>\n","<template>\n  <BPopover ref=\"popover\" tooltip>\n    <template v-for=\"(_, name) in $slots\" #[name]=\"slotData\">\n      <slot :name=\"name\" v-bind=\"slotData\" />\n    </template>\n  </BPopover>\n</template>\n\n<script setup lang=\"ts\">\nimport {ref} from 'vue'\nimport BPopover from './BPopover.vue'\n\nconst popover = ref<null | InstanceType<typeof BPopover>>(null)\n\ndefineExpose({\n  hide: popover.value?.hideFn,\n  show: popover.value?.show,\n  toggle: popover.value?.toggle,\n})\n</script>\n","import type {App, Plugin} from 'vue'\nimport {BToastPlugin} from './components'\nimport type {BootstrapVueOptions} from './types'\n\nimport './styles/styles.scss'\n\nimport * as Components from './components'\nimport * as Directives from './directives'\nimport type {ComponentType, DirectiveType} from './types/BootstrapVueOptions'\nimport parseActiveImports from './utils/parseActiveImports'\n\ndeclare module '@vue/runtime-core' {\n  export interface GlobalComponents {\n    BFormFile: typeof Components.BFormFile\n    BAccordion: typeof Components.BAccordion\n    BAccordionItem: typeof Components.BAccordionItem\n    BAlert: typeof Components.BAlert\n    BAvatar: typeof Components.BAvatar\n    BAvatarGroup: typeof Components.BAvatarGroup\n    BBadge: typeof Components.BBadge\n    BBreadcrumb: typeof Components.BBreadcrumb\n    BBreadcrumbItem: typeof Components.BBreadcrumbItem\n    BButton: typeof Components.BButton\n    BButtonGroup: typeof Components.BButtonGroup\n    BButtonToolbar: typeof Components.BButtonToolbar\n    BCard: typeof Components.BCard\n    BCardBody: typeof Components.BCardBody\n    BCardFooter: typeof Components.BCardFooter\n    BCardGroup: typeof Components.BCardGroup\n    BCardHeader: typeof Components.BCardHeader\n    BCardImg: typeof Components.BCardImg\n    BCardSubtitle: typeof Components.BCardSubtitle\n    BCardText: typeof Components.BCardText\n    BCardTitle: typeof Components.BCardTitle\n    BCarousel: typeof Components.BCarousel\n    BCarouselSlide: typeof Components.BCarouselSlide\n    BCloseButton: typeof Components.BCloseButton\n    BCol: typeof Components.BCol\n    BCollapse: typeof Components.BCollapse\n    BContainer: typeof Components.BContainer\n    BDropdown: typeof Components.BDropdown\n    BDropdownDivider: typeof Components.BDropdownDivider\n    BDropdownForm: typeof Components.BDropdownForm\n    BDropdownGroup: typeof Components.BDropdownGroup\n    BDropdownHeader: typeof Components.BDropdownHeader\n    BDropdownItem: typeof Components.BDropdownItem\n    BDropdownItemButton: typeof Components.BDropdownItemButton\n    BDropdownText: typeof Components.BDropdownText\n    BForm: typeof Components.BForm\n    BFormCheckbox: typeof Components.BFormCheckbox\n    BFormCheckboxGroup: typeof Components.BFormCheckboxGroup\n    BFormFloatingLabel: typeof Components.BFormFloatingLabel\n    BFormGroup: typeof Components.BFormGroup\n    BFormInput: typeof Components.BFormInput\n    BFormInvalidFeedback: typeof Components.BFormInvalidFeedback\n    BFormRadio: typeof Components.BFormRadio\n    BFormRadioGroup: typeof Components.BFormRadioGroup\n    BFormRow: typeof Components.BFormRow\n    BFormSelect: typeof Components.BFormSelect\n    BFormSelectOption: typeof Components.BFormSelectOption\n    BFormSelectOptionGroup: typeof Components.BFormSelectOptionGroup\n    BFormText: typeof Components.BFormText\n    BFormTextarea: typeof Components.BFormTextarea\n    BFormTag: typeof Components.BFormTag\n    BFormTags: typeof Components.BFormTags\n    BFormSpinButton: typeof Components.BFormSpinButton\n    BFormValidFeedback: typeof Components.BFormValidFeedback\n    BImg: typeof Components.BImg\n    BInputGroup: typeof Components.BInputGroup\n    BInputGroupAddon: typeof Components.BInputGroupAddon\n    BInputGroupAppend: typeof Components.BInputGroupAppend\n    BInputGroupPrepend: typeof Components.BInputGroupPrepend\n    BInputGroupText: typeof Components.BInputGroupText\n    BLink: typeof Components.BLink\n    BListGroup: typeof Components.BListGroup\n    BListGroupItem: typeof Components.BListGroupItem\n    BModal: typeof Components.BModal\n    BNav: typeof Components.BNav\n    BNavForm: typeof Components.BNavForm\n    BNavText: typeof Components.BNavText\n    BNavbar: typeof Components.BNavbar\n    BNavbarBrand: typeof Components.BNavbarBrand\n    BNavbarNav: typeof Components.BNavbarNav\n    BNavbarToggle: typeof Components.BNavbarToggle\n    BNavItem: typeof Components.BNavItem\n    BNavItemDropdown: typeof Components.BNavItemDropdown\n    BOffcanvas: typeof Components.BOffcanvas\n    BOverlay: typeof Components.BOverlay\n    BPagination: typeof Components.BPagination\n    BPlaceholder: typeof Components.BPlaceholder\n    BPlaceholderButton: typeof Components.BPlaceholderButton\n    BPlaceholderCard: typeof Components.BPlaceholderCard\n    BPlaceholderTable: typeof Components.BPlaceholderTable\n    BPlaceholderWrapper: typeof Components.BPlaceholderWrapper\n    BPopover: typeof Components.BPopover\n    BProgress: typeof Components.BProgress\n    BProgressBar: typeof Components.BProgressBar\n    BRow: typeof Components.BRow\n    BSpinner: typeof Components.BSpinner\n    BTab: typeof Components.BTab\n    BTable: typeof Components.BTable\n    BTableSimple: typeof Components.BTableSimple\n    BTbody: typeof Components.BTbody\n    BTd: typeof Components.BTd\n    BTfoot: typeof Components.BTfoot\n    BTh: typeof Components.BTh\n    BThead: typeof Components.BThead\n    BTr: typeof Components.BTr\n    BToast: typeof Components.BToast\n    BToaster: typeof Components.BToaster\n    BToastContainer: typeof Components.BToastContainer\n    BTooltip: typeof Components.BTooltip\n    BTabs: typeof Components.BTabs\n    BTransition: typeof Components.BTransition\n    BToastPlugin: typeof Components.BToastPlugin\n  }\n}\n\n// Main app plugin\nconst plugin: Plugin = {\n  install(app: App, options: BootstrapVueOptions = {components: true, directives: true}) {\n    const selectedComponents =\n      typeof options.components === 'boolean' || typeof options.components === 'undefined'\n        ? {all: true}\n        : options.components\n\n    const componentKeys = Object.keys(Components) as unknown as ComponentType[]\n    parseActiveImports(selectedComponents, componentKeys).forEach((name) => {\n      const component = Components[name]\n      app.component(name, component)\n    })\n\n    const selectedDirectives =\n      typeof options?.directives === 'boolean' || typeof options.directives === 'undefined'\n        ? {all: true}\n        : options?.directives\n\n    const directiveKeys = Object.keys(Directives) as unknown as DirectiveType[]\n    parseActiveImports(selectedDirectives, directiveKeys).forEach((name) => {\n      const parsedName = name.toLowerCase().startsWith('v') ? name.slice(1) : name\n      const directive = Directives[name]\n      app.directive(parsedName, directive)\n    })\n\n    if (options?.BToast) app.use(BToastPlugin, options)\n  },\n}\n\nexport * from './components'\nexport * as Components from './components'\nexport * from './directives'\nexport * as Directives from './directives'\nexport * from './composables/exports'\nexport * as Composables from './composables/exports'\nexport * from './utils/exports'\nexport * as Utils from './utils/exports'\nexport * from './types/exports'\nexport * as Types from './types/exports'\nexport {useToast} from './components/BToast'\n\nexport {plugin as BootstrapVueNext}\nexport default plugin\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}